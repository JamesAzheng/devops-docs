# 网络基础概念

**网络作用范围分类：**

- 广域网(WAN,Wide Area Network)
- 城域网(MAN,Metropolitan Area Network)
- 局域网(LAN,Local Area Network)



**三种通讯模式：**

- 单播 unicast

  - 一对一  点对点通讯 (目标唯一)

  - 其他人也能监听到，但是看到不是给自己的所以抛弃

  - 网卡如果设置为混杂模式一样能收到单播给其他人发送的信息


- 广播 broadcast
  - 一对多 


- 组播(多播) multicast
  - 一对部分




**冲突域和广播域：**

- 冲突域：两个网络设备同时发送数据，如果发生了冲突，则两个设备处于同一个冲突域，反之，则各自处于不同的冲突域。
- 广播域：一个网络设备发送广播，另一个设备收到了，则两个设备处于同一个广播域，反之，则各自处于不同的广播域。



**三种通讯机制：**

- 单工
  - 只能单向发送（收音机）


- 半双工
  - 双向都可以互相发送，但是一方发送时另一方不能发送（对讲机）


- 全双工
  - 双向都可以互相同时发送且不影响（打电话） 










# OSI & TCP/IP

## OSI

OSI（Open Systems Interconnection）是一个开放式的通信模型，又称OSI七层参考模型，由国际标准化组织（ISO）制定，旨在标准化不同厂商和不同系统之间的通信。OSI 模型将网络通信过程分为七个层次，每个层次都定义了不同的协议和功能。

OSI 模型的七层结构提供了一种通用的框架，可以帮助开发人员理解网络通信的不同方面，并将复杂的通信过程分解为不同的层次进行设计和管理。同时，OSI 模型也为网络技术的发展提供了基础和标准，成为了计算机网络领域中的重要参考模型。

以下是 OSI 模型的七个层次和相应的功能：

### 物理层（Physical Layer）

- 负责在物理介质上传输比特流，定义了物理连接和传输速率等特性。
- 0101，高低电平，光信号。
- 物理层在局部局域网上传送数据帧（Data Frame），它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等



### 数据链路层（Data Link Layer）

- 负责将比特流转换为数据帧，并提供帧的传输和检错等功能，还定义了数据帧的格式和传输方式等规范。
- 源MAC，目标MAC。
- 数据链路层负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成信息框（Data Frame）。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。
- 分为两个子层：
  - 逻辑链路控制（logical link control，LLC）子层
  - 介质访问控制（Media access control，MAC）子层

#### 不属于同一二层网络

- "不属于同一二层网络"指的是在网络中的两个节点或设备不具有相同的二层网络标识或地址范围。
- 在计算机网络中，二层网络（Layer 2 network）是指在数据链路层（第二层）上运行的网络，通常使用 MAC 地址来标识设备。**在一个二层网络中，设备可以通过二层交换机或桥接器直接通信，无需经过路由器。**
- 当两个节点或设备不属于同一二层网络时，它们之间的通信通常需要通过路由器或者进行跨二层网络的中继。这是因为二层网络的边界由物理或逻辑隔离所定义，不同的二层网络之间无法直接进行通信。
- 例如，如果有两个具有不同 VLAN ID 的交换机，每个交换机上连接的设备属于各自的 VLAN，那么这两个交换机上的设备就不属于同一二层网络。要使这两个设备能够相互通信，需要一个路由器或者三层交换机来连接这两个二层网络，并进行跨网络的数据转发。
- 总结而言，**当两个节点或设备不属于同一二层网络时，它们之间的通信需要经过路由器**或者跨网络的中继来实现。这通常涉及不同的二层网络标识、地址范围或 VLAN 分割等因素。



### 网络层（Network Layer）

- 负责将数据帧从源地址传输到目的地址，定义了路由选择、分组和寻址等功能。
- 源IP，目标IP。
- 网络层决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成报文。网络表头包含了网络数据。例如:互联网协议（IP）等。



### 传输层（Transport Layer）

- 负责提供端到端的数据传输和可靠性保障，定义了传输协议和连接管理等功能。
- TCP或UDP协议进行数据传输。
- 传输层把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。



### 会话层（Session Layer）

- 负责在通信双方之间建立和维护会话，并提供会话控制和同步等功能。
- 建立、管理、终止会话。
- 会话层负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接。



### 表示层（Presentation Layer）

- 负责数据的格式转换和编码，提供数据压缩、数据加密和数据格式转换等功能。
- 数据的表现形式，例如：图片、音频、文本等。
- 表示层把数据转换为能与接收者的系统格式兼容并适合传输的格式



### 应用层（Application Layer）

- 负责为用户提供各种应用程序和服务，例如文件传输、电子邮件、Web 浏览器等。
- 具体的应用协议
- 应用层提供为应用软件而设的接口，以设置与另一应用软件之间的通信。例如: HTTP、HTTPS、FTP、TELNET、SSH、SMTP、POP3、MySQL等









### 数据封装与数据解封过程

**数据封装：应用层 --> 表示层 --> 会话层 --> 传输层 --> 网络层 --> 数据链路层 --> 物理层**

数据封装指的是将上层协议数据加上下层协议需要的头部和尾部信息，从而构成一个完整的数据包的过程。以下是数据包从客户端发送到服务端的整个流程：

1. 应用层：应用程序调用应用层协议，将数据转换为应用层协议数据，如HTTP请求报文。
2. 表示层：将应用层数据转换为表示层数据，如将HTTP请求报文转换为XML格式。
3. 会话层：将表示层数据添加会话层信息，如会话ID，以便于服务器识别会话。
4. 传输层：将会话层数据添加传输层协议信息，如TCP头部信息，以便于保证数据的可靠传输和流量控制。
5. 网络层：将传输层数据添加网络层协议信息，如IP头部信息，以便于路由器识别目标地址，进行跨网络传输。
6. 数据链路层：将网络层数据添加数据链路层协议信息，如以太网头部信息，以便于局域网内的设备进行通信。
7. 物理层：将数据链路层数据转换为物理层数据，如电子信号，在物理介质上进行传输。

数据包从客户端到服务端的过程与从服务端到客户端的过程相似，只是数据包的方向不同。在服务端接收数据包时，数据解封的过程则是以上述相反的顺序逐层解析数据包，取出相应的数据和信息，直到达到应用层，交给应用程序进行处理。



**数据解封：物理层 --> 数据链路层 --> 网络层 --> 传输层 --> 会话层 --> 表示层 -->  应用层**

您的理解是正确的，数据包在发送端进行了从应用层到物理层的封装，在接收端进行了从物理层到应用层的解封。这个过程符合OSI模型的分层结构，每一层都有自己的功能和协议，并且在数据传输过程中参与其中。



在数据传输过程中，接收端需要对接收到的数据包进行解封以还原原始数据。具体的数据解封过程如下：

1. 物理层：接收端接收到数据包后，通过物理层进行比特流的接收和解码，将比特流还原为数字信号。
2. 数据链路层：接收端通过数据链路层进行数据包的帧同步、差错检测和纠正。如果发现数据帧中存在错误，则数据包将被丢弃。
3. 网络层：接收端通过网络层检查目的IP地址，判断数据包是否需要被接收。如果目的IP地址和接收端IP地址匹配，则数据包被接收。
4. 传输层：接收端通过传输层协议（如TCP或UDP）将数据包的数据传输到相应的应用程序。
5. 会话层：接收端通过会话层建立与发送端相同的会话，并协调数据传输。
6. 表示层：接收端通过表示层将数据包的数据解码，还原为原始数据的数据格式。
7. 应用层：接收端将还原后的原始数据传递给相应的应用程序进行处理。





**请结合OSI模型，详细的描述一下数据包从服务端发送到客户端的整个流程，就是数据封装与数据解封的过程之类的**

假设我们有一个基于客户端-服务端模型的网络应用程序，下面是数据包从服务端发送到客户端的整个流程，结合OSI模型进行详细描述：

1. 应用层：服务器的应用程序生成要发送到客户端的数据，将其传递给应用层协议，例如HTTP、FTP等，这些协议将为数据添加头部信息，例如协议版本、请求方法、状态码等，并将数据传递给下一层传输层。
2. 传输层：在传输层，数据被分割为更小的数据包，每个数据包都添加了传输层头部信息，例如端口号、序列号和确认号，以确保数据的可靠传输。然后，传输层将这些数据包传递给下一层网络层。
3. 网络层：在网络层，数据包被添加了网络层头部信息，例如源IP地址和目标IP地址，然后被封装成一个或多个网络层数据包，并传递给下一层数据链路层。
4. 数据链路层：在数据链路层，数据被添加了数据链路层头部信息，例如源MAC地址和目标MAC地址，然后被封装成一个或多个数据链路层数据帧，并传递给下一层物理层。
5. 物理层：在物理层，数据被转换成适合于物理介质传输的信号，例如电信号或光信号，并通过物理介质发送到网络上的接收方。

以上是数据包从服务端发送到客户端的封装过程，当数据包到达客户端时，会按照相反的顺序进行解封过程。从物理层开始，数据包被逐层解开，直到应用层，最终被传递给客户端的应用程序。





**请结合OSI模型，详细的描述一下数据包从客户端发送到服务端的整个流程，就是数据封装与数据解封的过程之类的**

当客户端发送数据包到服务端时，数据包将会经历以下流程：

1. 应用层数据封装：客户端应用程序将数据封装成应用层协议数据单元（PDU），例如HTTP、FTP或SMTP等协议。
2. 传输层数据封装：传输层将应用层数据添加传输层协议头，如TCP或UDP头，用于标识端口号和序列号等信息，并将数据传输到网络层。
3. 网络层数据封装：网络层添加网络层协议头，如IP头，包含源IP地址和目的IP地址等信息，并将数据包发送到链路层。
4. 数据链路层数据封装：数据链路层将网络层数据包封装成数据帧，添加数据链路层协议头和协议尾（如以太网头和尾部），并发送到物理层。
5. 物理层传输：物理层将数据帧转换成比特流，通过物理介质传输到服务端。

在服务端接收到数据包后，数据包将会经历以下过程：

1. 物理层接收：物理层接收到数据包后将比特流转换成数据帧，去掉帧头和帧尾等信息，并将数据帧发送到数据链路层。
2. 数据链路层解封装：数据链路层解封装数据帧，去掉数据链路层头和尾部等信息，将网络层数据包发送到网络层。
3. 网络层解封装：网络层解封装网络层数据包，去掉网络层头部等信息，将传输层数据包发送到传输层。
4. 传输层解封装：传输层解封装传输层数据包，去掉传输层头部等信息，将应用层协议数据单元发送到应用层。
5. 应用层处理：应用层接收到应用层协议数据单元后进行解析和处理，获取客户端发送的数据内容。



## TCP/IP

OSI（Open Systems Interconnection，开放系统互联）和TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是两种不同的网络通信模型或协议栈。

OSI是由国际标准化组织（ISO）在20世纪80年代开发的一个概念性框架，旨在描述计算机网络中不同层次的功能和交互。它将网络通信分为七个不同的层级：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。每个层级都有特定的功能，并通过接口与相邻的层级进行通信。OSI模型提供了一种理论框架，用于理解和设计网络协议和通信系统。

而TCP/IP是一组实际应用的网络协议，广泛用于互联网中。TCP/IP协议栈由一系列不同的协议组成，包括IP、TCP、UDP、HTTP、FTP等。TCP/IP协议栈并不完全符合OSI模型的七层结构，但它可以被视为一个网络通信体系，其中各个协议相互配合，实现数据的可靠传输和网络的连接。

虽然OSI和TCP/IP是两个不同的网络模型和协议栈，但它们之间有一定的关系。事实上，TCP/IP协议栈的设计在一定程度上受到了OSI模型的影响。TCP/IP协议栈的网络层对应于OSI模型中的网络层，传输层对应于传输层，应用层对应于应用层。但是，TCP/IP协议栈没有像OSI模型那样明确定义会话层、表示层和数据链路层，而是将这些功能融合到更高或更低的层级中。

总的来说，OSI是一个理论模型，描述了网络通信的不同层级和功能，而TCP/IP是一组实际应用的网络协议，用于在互联网中进行数据通信。TCP/IP协议栈部分地基于OSI模型，但并不完全遵循其结构。



## 协议数据单元 PDU

PDU：Protocol Data Unit，协议数据单元是指对等层次之间传递的数据单位

- 物理层的 PDU 是数据位 bit
- 数据链路层的 PDU 是数据帧 frame
- 网络层的 PDU 是数据包 packet
- 传输层的 PDU 是数据段 segment
- 其他更高层次的 PDU 是消息 message





# 网速换算

网速通常以比特（bit）或字节（byte）每秒来衡量。比特是计量信息传输速度的基本单位，而字节则是计量数据存储容量的基本单位。换算网速涉及到不同的前缀和单位，下面是一些常见的网速换算和详解：

1. 位（bit）和字节（byte）的关系：
   - 1字节（byte）= 8比特（bit）
   - 1比特（bit）= 0.125字节（byte）
2. 常见的网速单位：
   - 千字节每秒（KB/s）：指的是每秒传输的数据量为千字节。换算关系为：1KB/s = 8Kbps。
   - 兆字节每秒（MB/s）：指的是每秒传输的数据量为兆字节。换算关系为：1MB/s = 8Mbps。
   - 千兆字节每秒（GB/s）：指的是每秒传输的数据量为千兆字节。换算关系为：1GB/s = 8Gbps。
3. 常见的网速表示方式：
   - 比特每秒（bps）：最基本的网速单位，指的是每秒传输的比特数量。
   - 千比特每秒（Kbps）：指的是每秒传输的千比特数量。换算关系为：1Kbps = 1000bps。
   - 兆比特每秒（Mbps）：指的是每秒传输的兆比特数量。换算关系为：1Mbps = 1000Kbps。
   - 千兆比特每秒（Gbps）：指的是每秒传输的千兆比特数量。换算关系为：1Gbps = 1000Mbps。

举个例子，如果你的下载速度是10Mbps，意味着每秒传输10兆比特的数据量。根据换算关系，你可以将其转换为字节每秒（B/s）：10Mbps = 10 * 1000Kbps = 10 * 1000 * 8bps = 80,000B/s。

需要注意的是，上述换算关系中的数字都是近似值，实际数值可能存在轻微的变化。此外，这些换算关系适用于传统的十进制换算。在计算机领域，还存在二进制换算，其中比特的换算关系是严格的二的幂关系，例如：1字节 = 8比特，1千字节（KiB）= 1024字节，1兆字节（MiB）= 1024千字节，依此类推。

总之，网速的换算涉及到比特和字节的关系，以及不同的前缀和单位。通过理解这些换算关系，可以更好地理解和转换网速的表示方式。









# 以太网（局域网）

以太网和局域网是两个不同但相关的概念。

以太网（Ethernet）是一种计算机网络技术，它定义了计算机之间如何通过物理介质（如电缆）进行通信的标准。以太网使用CSMA/CD（载波监听多路访问/碰撞检测）协议，允许多台计算机共享同一物理网络，并通过以太网帧（Ethernet Frame）进行数据传输。以太网通常以太网局域网的形式存在。

局域网（Local Area Network，LAN）是一种局限于较小地理范围内的计算机网络，用于连接位于同一地理区域内的多台计算机和网络设备。局域网通常由路由器、交换机或集线器等设备来连接多个计算机，并提供高速数据传输和资源共享的能力。以太网是最常用的局域网技术，但也可以使用其他技术，如无线局域网（WLAN）。

因此，以太网是一种通信技术，而局域网是一种网络拓扑结构，其中以太网是实现局域网的常见选择。以太网作为局域网的基础设施，允许局域网中的计算机和设备之间进行快速和可靠的数据传输。



**以太网工作在物理层和数据链路层**



## 局域网标准

- 目前主流**有线**局域网国际标准：802.3
- 目前主流**无线**局域网国际标准：802.11
- 中国无线网络标准：WAPI
- 局域网关注的层：物理层、数据链路层



## 以太网帧结构

以太网第二代（Ethernet II）是最常用的以太网帧结构，也被称为DIX帧（Digital, Intel, Xerox）或以太网V2帧。以下是以太网二代帧结构的详细解释：

1. 前导码（Preamble）：一个7字节（56位）的字段，由连续的101010...组成，用于同步接收方和发送方的时钟。
2. 起始帧定界符（Start Frame Delimiter，SFD）：一个1字节（8位）的字段，固定为10101011，标志着帧的开始。
3. 目标MAC地址（Destination MAC Address）：一个6字节（48位）的字段，指示接收方的物理地址。
4. 源MAC地址（Source MAC Address）：一个6字节（48位）的字段，指示发送方的物理地址。
5. 以太网类型（Ethernet Type）：一个2字节（16位）的字段，指示上层协议的类型。常见的以太网类型包括IPv4（0x0800）、IPv6（0x86DD）、ARP（0x0806）等。
   - 以太网二代帧结构中的类型字段指示上层协议的类型，而不是数据长度。（以太网一代指示的是长度）
   - 这种结构广泛应用于现代以太网网络，支持多种上层协议的数据传输。
6. 数据（Data）：一个46-1500字节的字段，包含上层协议的数据。
   - 至少为46个字节，是因为包含20字节的IP头、20字节的TCP、6字节的数据（IP报文中的数据）
   - 如果数据部分少于46字节，则填充字段（Padding）会被添加，以确保帧达到最小长度。
7. 帧校验序列（Frame Check Sequence，FCS）：一个4字节（32位）的字段，用于检测帧在传输过程中是否发生错误。通常使用循环冗余校验（CRC）算法计算得出。

**以太网二代（Ethernet II）帧结构的总长度最小为72字节，最大为1526字节。**

- 8字节前导码 + 6字节目标MAC地址 + 6字节源MAC地址 + 2字节以太网类型 + **46**字节数据 + 4字节帧校验序列 = 72字节。
- 8字节前导码 + 6字节目标MAC地址 + 6字节源MAC地址 + 2字节以太网类型 + **1500**字节数据 + 4字节帧校验序列 = 1526字节。



## MCA地址

- mac地址占48位（6byte）
- 前24位表示生产厂家的唯一编号
- 后24位表示厂家对设备设置的编号



MAC地址（Media Access Control address）是一个用于唯一标识网络设备的地址。它是一个由48位二进制数字（通常以十六进制表示）组成的地址。

以下是MAC地址的一些详细解释：

1. 唯一性：MAC地址在全球范围内应该是唯一的，以确保每个网络设备都有一个独特的标识。这是通过MAC地址由网络设备制造商分配和管理来实现的。
2. 格式：MAC地址由6个字节（48位）组成，通常以冒号（:）或连字符（-）分隔为六组。例如，00:1A:2B:3C:4D:5E。
3. OUI（Organizationally Unique Identifier）：MAC地址的前三个字节表示OUI，用于识别MAC地址的制造商或组织。OUI由IEEE（Institute of Electrical and Electronics Engineers）分配给各个制造商。
4. 可组织本地地址（Locally Administered Address）和全球唯一地址（Universally Administered Address）：MAC地址的第一个字节的最低有效位（LSB）用于指示地址的类型。如果LSB为0，表示这是一个全球唯一地址，由OUI分配；如果LSB为1，表示这是一个可组织本地地址，由网络设备的管理员分配。
5. 广播地址：MAC地址全为1的地址（FF:FF:FF:FF:FF:FF）被用作广播地址，用于将数据帧发送到网络中的所有设备。

MAC地址在数据链路层起着重要的作用，用于在局域网中识别和定位网络设备。它是网络通信中实现数据帧传输和设备识别的基础。





# VLAN

- VLAN 虚拟局域网

- 主要功能：分割广播域

- VLAN是属于交换机技术
- 每个不同的VLAN都是属于一个局域网，同一个VLAN中发送广播报文后其他同VLAN的主机也可以收到
- 不同VLAN之间通讯因为不在同一个网段，所以需要路由器（三层交换机不需要路由器，因为三层交换机本身就已经带有路由器的功能）
- 多台交换机的VLAN通讯需要一根trunk，trunk走的是802.EQ协议





# VXLAN

## VXLAN 概述

- Virtual eXtensible Local Area Network 虚拟可扩展的局域网
- **虽然从名字上看，VXLAN是VLAN的一种扩展协议，但其实它和VLAN完全不兼容。一句话来总结：VXLAN是一个隧道协议，利用一种协议来传输另外一种协议。**
- 一种虚拟化隧道通信技术。它是一种overlay（覆盖网络）技术，通过三层的网络搭建虚拟的二层网络
- VXLAN是在底层物理网络（underlay）之上使用隧道技术，依托UDP层构建的overlay的逻辑网络，使逻辑网络与物理网络解耦，实现灵活的组网需求

## VXLAN 相关术语

**VTEP（VXLAN Tunnel Endpoints）**

- VXLAN网络的边缘设备
- 它是VXLAN隧道的起点和终点，VXLAN对用户原始数据帧的封装和解封装均在VTEP上进行
- 用来进行VXLAN报文的处理（封包和解包）。VTEP可以是网络设备（例如交换机），也可以是一台机器（例如虚拟机集群中的宿主机）

**VNI（VXLAN Network Identifier）**

- VNI是每个VXLAN的标识，是个24位整数，因此最大值是2^24，如果一个VNI对应一个租户，那么理论上VXLAN可以支撑千万级别的租户

**tunnel**

- 隧道是一个逻辑上的概念，在VXLAN模型中并没有具体的物理实体相对应。
- 隧道可以看作一种虚拟通道，VXLAN通信双方都认为自己在直接通信，并不知道底层网络的存在。从整体看，每个VXLAN网络像是为通信的虚拟机搭建了一个单独的通信通道，也就是隧道



## VXLAN 工作模型

![VXLAN 工作模型](Net_images\VXLAN 工作模型.png)

- 如上图所示为VXLAN的工作模型，**它创建在原来的IP网络（三层）上，只要是三层可达（能够通过IP互相通信）的网络就能部署VXLAN**

1. 源VM发出的原始数据帧，在左端VTEP上被封装成VXLAN格式的报文，并塞进UDP payload中。
2. 报文通过UDP协议在IP网络中传递到右端VTEP上。
3. 右端VTEP解封装还原出原始的数据帧，最后转发给目的VM。
4. 虽然实际上网络包还是在IP网络中传输的，通信双方分别是源IP 1.1.1.1和目的IP 2.2.2.2这两个VTEP，但是从躲在这两个VTEP后面的VM的眼中看来，就好像它俩之间有一个隧道，源数据从隧道这端塞进去，那端就能原样收到了。

- 物理网络上可以创建多个VXLAN网络，可以将这些VXLAN看作一个隧道，不同节点上的虚拟机/容器能够通过隧道直连。通过VNI标识不同的VXLAN网络，使得不同的VXLAN可以相互隔离



## VXLAN 封包格式

- VXLAN其实是在三层网络上构建出来的一个二层网络的隧道。VNI相同的机器逻辑上处理同一个二层网络中
- VXLAN封包格式如下图：

![VXLAN 工作模型](Net_images\VXLAN 封包格式.png)

- VXLAN的报文就是MAC in UDP，**即在三层网络的基础上构建一个虚拟的二层网络**。
- **VXLAN的封包格式显示原来的二层以太网帧（包含MAC头部、IP头部和传输层头部的报文），被放在VXLAN包头里进行封装，再套到标准的UDP头部（UDP头部、IP头部和MAC头部）用来在底层网络上传输报文**
- UDP目的端口是接收方VTEP设备使用的端口，IANA（互联网号码分配局）分配了4789作为VXLAN的目的UDP端口



## VXLAN 组网的必要信息

VXLAN报文的转发过程就是：原始报文经过VTEP，被Linux内核添加上VXLAN包头及外层的UDP头部，再发送出去，对端VTEP接收到VXLAN报文后拆除外层UDP头部，并根据VXLAN头部的VNI把原始报文发送到目的的服务器

一个完整的VXLAN报文需要以下信息：

- **内层报文**：通信双方的IP地址已经确定，需要VXLAN填充的是对方的MAC地址，VXLAN需要一个机制实现ARP的功能
- **VXLAN头部**：只需要知道VNI。它一般是直接配置在VTEP上的，即要么是提前规划的，要么是根据内部报文自动生成的
- **UDP头部**：最重要的是源地址和目的地址的端口，源地址端口是由系统自动生成并管理的，目的端口一般固定位IANA分配的4789端口
- **IP头部**：IP头部关系的是对端VTEP的IP地址，源地址可以用简单的方式确定，目的地址是虚拟机所在地址宿主机VTEP的IP地址，需要由某种方式来确定
- **MAC头部**：确定了VTEP的IP地址，MAC地址可以通过ARP方式获取，毕竟VTEP在同一个三层网络内

**总结**：一个VXLAN报文需要确定两个地址信息：内层报文（对应目的虚拟机/容器）的MAC地址和外层报文（对应目的虚拟机/容器所在宿主机的VTEP）IP地址



## 实现点对点的 VXLAN

- 点对点的VXLAN即两台机器构成一个VXLAN网络，每台机器上有一个VTEP，VTEP之间通过它们的IP地址进行通信。
- 点对点VXLAN网络拓扑如下图：

![VXLAN 工作模型](Net_images\点对点 VXLAN.png)

### host1 创建 VXLAN 接口

- 创建了一个名为vxlan0，类型为vxlan的网络接口

```bash
# ip link add vxlan0 type vxlan id 42 dstport 4789 remote 172.19.216.112 local 172.19.216.111 dev eth0


# 选项说明
id 42 # 指定VNI的值，有效值在1到2^24之间
dstport # VTEP通信的端口，IANA分配的端口是4789
remote 172.19.216.112 # 对端VTEP的地址
local 172.19.216.111 # 当前节点VTEP要使用的IP地址，即当前节点隧道口的IP地址
dev eth0 # 当前节点用于VTEP通信的网卡设备，用来获取VTEP IP地址


# 详细信息
# ip -d link show dev vxlan0
3: vxlan0: <BROADCAST,MULTICAST> mtu 1450 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 26:1a:4d:9b:a3:ed brd ff:ff:ff:ff:ff:ff promiscuity 0 minmtu 68 maxmtu 65535 
    vxlan id 42 remote 172.19.216.112 local 172.19.216.111 dev eth0 srcport 0 0 dstport 4789 ttl auto ageing 300 udpcsum noudp6zerocsumtx noudp6zerocsumrx addrgenmode eui64 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535
    
    
# 为刚创建的VXLAN网卡配置IP地址并启用它
# ip addr add 172.17.1.2/24 dev vxlan0
# ip link set vxlan0 up
# ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.19.216.111  netmask 255.255.240.0  broadcast 172.19.223.255
        inet6 fe80::216:3eff:fe29:7a94  prefixlen 64  scopeid 0x20<link>
        ether 00:16:3e:29:7a:94  txqueuelen 1000  (Ethernet)
        RX packets 3146  bytes 780076 (761.7 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 3495  bytes 549248 (536.3 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 2  bytes 140 (140.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 2  bytes 140 (140.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

vxlan0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1450
        inet 172.17.1.2  netmask 255.255.255.0  broadcast 0.0.0.0
        inet6 fe80::241a:4dff:fe9b:a3ed  prefixlen 64  scopeid 0x20<link>
        ether 26:1a:4d:9b:a3:ed  txqueuelen 1000  (Ethernet)
        RX packets 45  bytes 3254 (3.1 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 45  bytes 3258 (3.1 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0


# 执行成功后会发现路由表项多了下面的内容，所有目的地址是172.17.1.0/24网段的包要通过vxlan0转发
# ip route
172.17.1.0/24 dev vxlan0 proto kernel scope link src 172.17.1.2


# vxlan0的FDB表项中标的内容如下：
# 这个表项的意思是，默认的VTEP对端地址为172.19.216.112。换句话说，原始报文经过vxlan0后会被内核添加上VXLAN头部，而外部UDP头的目的IP地址会被带上172.19.216.112
# bridge fdb
00:00:00:00:00:00 dev vxlan0 dst 172.19.216.112 via eth0 self permanent

```

### host2 创建 VXLAN 接口

```bash
# 创建VXLAN接口
# ip link add vxlan0 type vxlan id 42 dstport 4789 remote 172.19.216.111 local 172.19.216.112 dev eth0


# 为刚创建的VXLAN网卡配置IP地址并启用它
# ip addr add 172.17.1.3/24 dev vxlan0
# ip link set vxlan0 up
```



### 测试两个VTEP的连通性

```bash
[root@aliyun ~]# ping 172.17.1.3
PING 172.17.1.3 (172.17.1.3) 56(84) bytes of data.
64 bytes from 172.17.1.3: icmp_seq=1 ttl=64 time=0.720 ms
64 bytes from 172.17.1.3: icmp_seq=2 ttl=64 time=0.346 ms
64 bytes from 172.17.1.3: icmp_seq=3 ttl=64 time=0.343 ms
...
```











# 网络相关设备

## tun / tap设备

- tun 和 tap 设备都是 Linux 内核的一种虚拟网络设备，是用软件模拟的网络设备，提供与硬件网络设备完全相同的功能。主要用于用户空间和内核空间传递报文。
- 从Linux文件系统的角度看，它是用户可以用文件句柄操作的**字符设备**
- 从网络虚拟化角度看，它是虚拟网卡，一端连着网络协议栈，另一端连着用户态程序
- tun/tap设备可以将TCP/IP协议栈处理好的网络包发送给任何一个使用tun/tap驱动的进程，由进程重新处理后发到物理链路中。tun/tap设备就像是埋在用户空间的一个钩子，我们可以很方便地将对网络包的处理程序挂载这个钩子上
- 普通的物理网卡通过网线收发数据包，而tun设备通过一个设备文件（/dev/net/tunX）收发数据包。所有对这个文件的写操作会通过tun设备转换成一个数据包传送给内核网络协议栈。当内核发送一个包给tun设备时，用户态的进程通过读取这个文件可以拿到包的内容。当然，用户态的程序也可以通过写这个文件向tun设备发送数据

### tun 设备概述

- Tun 设备是一个三层设备，从 /dev/net/tun 字符设备上读取的是 IP 数据包，写入的也只能是 IP 数据包，因此不能进行二层操作，如发送 ARP 请求和以太网广播。

### tap 设备概述

- Tap 设备是二层设备，处理的是二层 MAC 层数据帧，从 /dev/net/tun 字符设备上读取的是 MAC 层数据帧，写入的也只能是 MAC 层数据帧。从这点来看， Tap 虚拟设备和真实的物理网卡的能力更接近，可以与物理网卡做 bridge。

### tun/tap 设备与物理网卡的区别

![tun tap 设备与物理网卡](Net_images\tun tap 设备与物理网卡.png)

- 对于硬件网络设备而言，一端连接的是物理网络，一端连接的是网络协议栈。
- 对于 tun/tap 设备而言，一端连接的是应用程序（通过 字符设备文件 /dev/net/tun），一端连接的是网络协议栈。



### tun/tap 设备工作原理

![tun tap 设备工作原理](Net_images\tun tap 设备工作原理.png)

- 从上图可以更直观的看出 tun/tap 设备和物理设备的区别：虽然它们的一端都是连着网络协议栈，但是物理网卡另一端连接的是物理网络，而 tun/tap 设备另一端连接的是一个应用层程序，这样协议栈发送给 tun/tap  的数据包就可以被这个应用程序读取到，此时这个应用程序可以对数据包进行一些自定义的修改(比如封装成 UDP)，然后又通过网络协议栈发送出去——其实这就是目前大多数“代理”的工作原理。
- Tun/tap 设备提供的虚拟网卡驱动，从tcp/ip协议栈的角度而言，它与真实网卡驱动并没有区别。



### tun/tap 设备数据收发流程

- **数据发送**：应用进程 A  open /dev/net/tun 字符设备，通过 ioctl 调用创建虚拟接口 tunx 或者 tapx, ioctl 调用返回表示对应  tunx 或者 tapx 设备的文件描述符 fd ，应用 A 通过这个文件描述符 fd 写入格式化的数据，数据通过虚拟网卡驱动到达协议栈，对于协议栈来说，这个数据就像从真实网卡接收的一样。
- **数据接收**：当网络协议栈发送数据到虚拟接口 tunx 或者 tapx 时，应用进程 A 通过上述创建的设备文件描述符 fd，从中读取接口发送的数据，然后进行处理。



### tun/tap 设备相关管理命令

#### 设备创建

- 除了在应用中通过克隆设备 /dev/net/tun 和 ioctl 系统调用创建虚拟设备，还可以通过 ip tuntap 命令创建。

```bash
# 创建 tun/tap 设备
ip tuntap add dev tap0 mod tap # 创建 tap
ip tuntap add dev tun0 mod tun # 创建 tun

 
# 删除tun/tap设备
ip tuntap del dev tap0 mod tap # 删除 tap
ip tuntap del dev tun0 mod tun # 删除 tun


# 设置 ip 地址，up 设备
ip address add dev tap0 10.0.1.5/24
ip link set dev tap0 up
```

#### tun/tap 驱动

- Tun/tap 驱动程序中包含两个部分，一部分是字符设备驱动，还有一部分是网卡驱动。
  - **网卡驱动**：利用网卡驱动部分接收来自 TCP/IP 协议栈的网络分包并发送或者反过来将接收到的网络分包传给协议栈处理。
  - **字符驱动**：字符驱动部分则将网络分包在内核与用户态之间传送，模拟物理链路的数据接收和发送。用户态程序通过 ioctl read write 系统调用 与字符设备 /dev/net/tun 进行数据交互。

```bash
# 通过 modinfo tun 和 modinfo tap  查看 tun/tap 设备驱动

[root@aliyun ~]# modinfo tun
filename:       /lib/modules/4.18.0-240.22.1.el8_3.x86_64/kernel/drivers/net/tun.ko.xz
alias:          devname:net/tun
alias:          char-major-10-200
license:        GPL
author:         (C) 1999-2004 Max Krasnyansky <maxk@qualcomm.com>
description:    Universal TUN/TAP device driver
rhelversion:    8.3
srcversion:     95AFADAE104D3261E33C449
depends:        
intree:         Y
name:           tun
vermagic:       4.18.0-240.22.1.el8_3.x86_64 SMP mod_unload modversions 
sig_id:         PKCS#7
signer:         CentOS kernel signing key
sig_key:        78:2B:A1:1C:2F:DE:D4:A5:85:15:10:61:C8:2E:D9:98:9C:D7:4D:14
sig_hashalgo:   sha256
signature:      AF:7B:2F:57:94:BB:41:0F:B8:AE:DF:5E:25:99:A4:5B:5E:04:6E:66:
		24:7B:38:A0:9C:61:A1:9F:32:C6:70:79:F0:0F:9B:38:9F:B7:3E:50:
		19:2C:6F:29:76:8A:6D:63:C0:EF:F8:70:68:9B:FC:90:9A:F2:CE:80:



[root@aliyun ~]# modinfo tap
filename:       /lib/modules/4.18.0-240.22.1.el8_3.x86_64/kernel/drivers/net/tap.ko.xz
license:        GPL
author:         Sainath Grandhi <sainath.grandhi@intel.com>
author:         Arnd Bergmann <arnd@arndb.de>
rhelversion:    8.3
srcversion:     68F757C86BE83A0D0D514BD
depends:        
intree:         Y
name:           tap
vermagic:       4.18.0-240.22.1.el8_3.x86_64 SMP mod_unload modversions 
sig_id:         PKCS#7
signer:         CentOS kernel signing key
sig_key:        78:2B:A1:1C:2F:DE:D4:A5:85:15:10:61:C8:2E:D9:98:9C:D7:4D:14
sig_hashalgo:   sha256
signature:      4D:6C:43:C6:A6:48:5A:92:0C:D3:6B:C9:17:E6:07:0F:C4:E2:A4:38:
		7E:0D:5C:6F:A2:33:E6:1F:15:D8:30:55:2D:2B:5B:3B:67:A6:03:67:
		8E:C9:FA:95:59:F1:9F:AC:42:90:43:52:E6:E1:DC:67:80:20:39:D6:
...
```



### 其它说明

- 无论是 tun 还是 tap 设备，都是通过 open /dev/net/tun 这个字符设备文件，通过 ioctl 系统调用在内核创建新的 tun、tap 设备，创建的设备并不会以文件的形式出现在 /dev/ 下，可以在 /sys/class/net/ 下看到对应的网络接口 tunx 或者  tapx。
- 设备 /dev/net/tun 必须以 read 或 write 的方式打开。该设备也被称为克隆设备，它是创建任何 tun/tap 虚拟接口的起点。
- open 系统调用执行的时候，VFS 会为这次 open 分配一个独立的内核态 file 结构，也就是说，每次打开执行时，内核为此次打开分配的 file 结构实例不同，代表不同的字符设备。
  



# TCP/IP

- TCP/IP是一个协议栈，其中主要协议是TCP和IP协议，还包括很多协议，如：TCP、IP、UDP、ICMP、RIP、FTP、ARP等



## TCP/IP的分层结构

- 应用层（对应OSI参考模型中的应用、会话、表示层）
- 传输层
- 网络层
- 数据链路层
- 物理层



## 应用层 Application

- 应用层的主要协议：http、ftp、tftp、telnet、ssh 等...





## 网络层 Internet

- 网络层的主要协议：IP、ICMP、ARP、RARP

### IP

- Internet Protocol 网际互连协议
- IP PDU 包头
  - 最少为20byte


- 主要功能：
  - 1

### ICMP

- Internet Control Message Protocol Internet控制报文协议

- 主要功能：
  - 判断网络状态
- icmp的type类型：
  - 8 请求
  - 0 响应
- ping命令

### ARP

- Address Resolution Protocol 地址解析协议

- 主要功能：

  - 将IP地址解析成mac地址

- 同网段场景：

  - 通过发送ARP广播的方式 来获取IP地址对应的MAC地址，源主机再将对方的IP地址和MAC的对应关系缓存到ARP地址表中 下次需要则直接使用缓存的数据 `arp -n` 可以查看缓存的数据

  - 范例：

  - ```bash
    #主机一
    root@100:~# hostname -I
    10.0.0.100 
    root@100:~# cat /sys/class/net/eth0/address 
    00:0c:29:cd:b5:7f
    root@100:~# arp -n
    Address                  HWtype  HWaddress           Flags Mask            Iface
    10.0.0.1                 ether   00:50:56:c0:00:08   C                     eth0
    10.0.0.2                 ether   00:50:56:ee:3d:15   C                     eth0
    
    #主机二
    root@101:~# hostname -I
    10.0.0.101 
    root@101:~# cat /sys/class/net/eth0/address
    00:0c:29:0d:63:cd
    root@101:~# arp -n
    Address                  HWtype  HWaddress           Flags Mask            Iface
    10.0.0.2                 ether   00:50:56:ee:3d:15   C                     eth0
    10.0.0.1                 ether   00:50:56:c0:00:08   C                     eth0
    
    ------------------------------------------------------------------------------
    
    #主机一开始抓包
    root@100:~# tcpdump -nn arp
    ...
    
    #主机二ping主机一
    root@101:~# ping 10.0.0.100
    ...
    
    #主机一抓包结果
    root@100:~# tcpdump -nn arp
    18:41:49.587409 ARP, Request who-has 10.0.0.100 tell 10.0.0.101, length 46
    18:41:49.587518 ARP, Reply 10.0.0.100 is-at 00:0c:29:cd:b5:7f, length 28
    18:41:54.735039 ARP, Request who-has 10.0.0.101 tell 10.0.0.100, length 28
    18:41:54.735655 ARP, Reply 10.0.0.101 is-at 00:0c:29:0d:63:cd, length 46
    
    #最终结果
    #主机一获取到了主机二的IP和MAC
    root@100:~# arp -n
    Address                  HWtype  HWaddress           Flags Mask            Iface
    10.0.0.1                 ether   00:50:56:c0:00:08   C                     eth0
    10.0.0.2                 ether   00:50:56:ee:3d:15   C                     eth0
    10.0.0.101               ether   00:0c:29:0d:63:cd   C                     eth0
    
    #主机二获取到了主机一的IP和MAC
    root@101:~# arp -n
    Address                  HWtype  HWaddress           Flags Mask            Iface
    10.0.0.100               ether   00:0c:29:cd:b5:7f   C                     eth0
    10.0.0.2                 ether   00:50:56:ee:3d:15   C                     eth0
    10.0.0.1                 ether   00:50:56:c0:00:08   C                     eth0
    ```

    

- 不同网段场景：

  - 将网关指向路由器，再由路由器向对方网段发送ARP广播，进而获取对方主机的MAC地址，最后交给源主机，源主机再将对方的IP地址和MAC的对应关系缓存到ARP地址表中 下次需要则直接使用缓存的数据 `arp -n` 可以查看缓存的数据

- 缺点：

  - 因为ARP广播没有任何效验的过程，所以容易造成ARP欺骗的产生
    - APR欺骗：伪装成路由器网关的MAC地址，这样其他主机在发送ARP广播的时候自然就转发到这台伪装的主机上了，这台伪装的主机就可以通过抓包等方式截取到对方主机发送的数据包等信息，伪装的主机还可以通过代理转发等手段完美的充当成一个路由器
  - 不过这一般也不是问题，因为交换机中记录了IP地址和MAC地址的对应关系，只需找到欺骗方的MAC地址 就可以轻松的找到对方的IP地址

### RARP

- Reverse Address Resolution Protocol 反向地址转换协议
- 主要功能：
  - 将mac转换成ip

- 使用场景：
  - 使用场景较少，一般用于网吧这种无盘环境


### 免费ARP

- Gratuitous ARP 又称无故ARP

- 主要功能：

  - 防止网卡启动时IP与其他主机冲突

- 范例：

  - ```bash
    #开始抓包
    root@100:~# tcpdump -nn arp
    
    #10.0.0.8主机启动
    
    #抓包结果（自问自答，防止IP地址冲突）
    root@100:~# tcpdump -nn arp
    ...
    19:09:55.603326 ARP, Request who-has 10.0.0.8 tell 10.0.0.8, length 46
    19:09:55.699541 ARP, Request who-has 10.0.0.2 tell 10.0.0.201, length 46
    19:09:55.699542 ARP, Reply 10.0.0.2 is-at 00:50:56:ee:3d:15, length 46
    19:09:57.604524 ARP, Request who-has 10.0.0.8 tell 10.0.0.8, length 46
    19:09:58.068295 ARP, Request who-has 10.0.0.2 tell 10.0.0.8, length 46
    19:09:58.068296 ARP, Reply 10.0.0.2 is-at 00:50:56:ee:3d:15, length 46
    19:09:59.604915 ARP, Request who-has 10.0.0.8 tell 10.0.0.8, length 46
    ```

- 使用场景：

  - 网卡启动时都会发送免费ARP的数据报文







## Socket

- Socket套接字是进程间通信IPC的一种实现，以允许不同主机或同一主机上不同进程间进行通信和数据交换
- 在建立通信连接的每一端，进程间的传输要有两个标志：IP地址和端口号，合称为套接字地址

- Socket套接字(地址) **=** IP地址(用来标识网络中的主机）**+** 端口号(用来标识网络中的应用程序）
- **Socket位于传输层和应用层之间**

### 套接字相关的系统调用

- **socket()** 创建一个套接字
- **bind()** 绑定IP和端口
- **listen()** 监听
- **accept()** 接受请求
- **connect()** 请求连接建立
- **write()** 发送
- **read()** 接受
- **close()** 关闭连接

### socket相关帮助

```bash
# yum -y install man-pages

# man 2 socket
# man 2 bind
# man 2 listen
# man 2 ...
```



## Port

### 端口号范围

- 2^16-1（0-65535）

### 端口号划分

- 0-1023：系统端口或特权端口（仅管理员可用）

  - ```bash
    [azheng@aliyun ~]$ nc -l 66
    Ncat: bind to :::66: Permission denied. QUITTING.
    
    --------------------------------------------------------------------------
    
    [root@aliyun ~]# nc -l 66
    
    [root@aliyun ~]# ss -ntl|grep 66
    LISTEN    0         10                 0.0.0.0:66               0.0.0.0:*       
    LISTEN    0         10                    [::]:66                  [::]:* 
    ```

- 1024-49151：用户端口或注册端口，但要求不严格，分配给程序注册为某应用使用

- 49152-65535：动态或私有端口，客户端随机使用端口

  - 范围定义：/proc/sys/net/ipv4/ip_local_port_range

### 常见服务端应用端口号参考文件

- /etc/services







# MTU

- Maximum Transmission Unit，缩写MTU，中文名是：最大传输单元。
- MTU是**数据链路层**的概念。MTU限制的是数据链路层的payload，也就是**上层协议**的大小，例如IP，ICMP等

## MTU有什么用？

举一个最简单的场景，你在家用自己的笔记本上网，用的是路由器，路由器连接电信网络，然后访问了`www.baidu.com`，从你的笔记本出发的一个以太网数据帧总共经过了以下路径：

```
笔记本 -> 路由器 -> 电信机房 -> 服务器
```

其中，每个节点都有一个MTU值，如下：

```
1500     1500                 1500
笔记本 -> 路由器 -> 电信机房  -> 服务器
```

假设现在我把笔记本的MTU最大值设置成了1700，然后发送了一个超大的ip数据包（2000），这时候在以外网传输的时候会被拆成2个包，一个1700，一个300，然后加上头信息进行传输。

```
1700     1500                1500
笔记本 -> 路由器 -> 电信机房 -> 服务器
```

路由器接收到了一个1700的帧，发现大于自己设置的最大值：1500，如果IP包DF标志位为1，也就是不允许分包，那么路由器直接就把这个包丢弃了，根本就不会到达电信机房，也就到不了服务器了，所以，到这里我们就会发现，**MTU其实就是在每一个节点的管控值，只要是大于这个值的数据帧，要么选择分片，要么直接丢弃。**

## 为什么是1500？

- 其实一个标准的以太网数据帧大小是：`1518`，头信息有14字节，尾部校验和FCS占了4字节，所以真正留给上层协议传输数据的大小就是：1518 - 14 - 4 = 1500

- 1518这个值是考虑到传输效率以及传输时间而折中选择的一个值，并且由于目前网络链路中的节点太多，其中某个节点的MTU值如果和别的节点不一样，就很容易带来拆包重组的问题，甚至会导致无法发送





# 数据传输单位

- 8 bit  = 1Byte
- 1024Byte  = 1Kb
- 1024Kb = 1MB
- 1024MB = 1GB

**补充：**

- 与传输速度有关的b一般指的是bit
- 与容量有关的b一般指的是byte
- 一般的宽带速率为Mbps(bit)，而非MB/s，所以与下载速度的比例为8:1，所以100Mbps的实际下载速率为100/8=12.5MB/s





# VMware Workstation Pro

## vmnet0、vmnet1和vmnet8的区别 

### vmnet0

- 实际上**就是一个虚拟的网桥 即桥接模式**，这个网桥有很若干个端口，一个端口用于连接你的Host，一个端口用于连接你的虚拟机，他们的位置是对等的，谁也不是谁的网关。所以在Bridged模式下，你可以让虚拟机成为一台和你的Host相同地位的机器。**桥接使用的是你机器的真实网卡进行上网**

### vmnet1

- 这**是一个Host-Only网络模式**，这是用于建立一个与世隔绝的网络环境所用到的，其中vmnet1也是一个虚拟的交换机，交换机的一个 端口连接到你的Host上，另外一个端口连接到虚拟的DHCP服务器上（实际上是vmware的一个组件），另外剩下的端口就是连虚拟机了。虚拟网卡 “VMWare Virtual Ethernet Adapter for VMnet1”作为虚拟机的网关接口，为虚拟机提供服务。在虚拟机启动之后，如果你用ipconfig命令，你会很清楚的看到，你的默认网关就是指向 “VMWare Virtual Ethernet Adapter for VMnet1”网卡的地址的。（实际上它并不能提供路由，这是VMware设计使然，它是干了除了提供路由之外的一些事情——实际上是我也不知道它干了什 么事情），这里没有提供路由主要表现在没有提供NAT服务，使得虚拟机不可以访问Host-Only模式所指定的网段之外的地址。

### vmnet8

- **相当于hub将此网络的主机连接起来**，这**是一个NAT方式**，最简单的组网方式了，从主机的“VMWare Virtual Ethernet Adapter for VMnet8”虚拟网卡出来，连接到vmnet8虚拟交换机，虚拟交换机的另外的口连接到虚拟的NAT服务器（这也是一个Vmware组件），还有一个口 连接到虚拟DHCP服务器，其他的口连虚拟机，虚拟机的网关即是“VMWare Virtual Ethernet Adapter for VMnet8”网卡所在的机器，废话，这肯定就是你的Host机器啦。同样，用ipconfig也可以看出来，你的虚拟机的默认网关也指向了你的 “VMWare Virtual Ethernet Adapter for VMnet8”虚拟网卡地址。相比之下，可以看出来，NAT组网方式和Host-Only方式，区别就在于是否多了一个NAT服务。







