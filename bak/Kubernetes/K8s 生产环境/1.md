**K8s 集群优化**

- K8s 集群优化已完成（对接外部存储 + worker 节点缩容）



---



**ippool 调研**

1. ippool 的文档中，没有明确说明对 ippool 的创建数量有限制要求；

2. 但是创建新的 ippool 后，集群运行一段时间，Pod 就会出现网络问题，表现为有些 Pod 无法与外界通信，但删除新创建的 ippool 后就能恢复。经过排查后，发现需要添加 `vxlanMode: Never` 选项后便可恢复正常。

   - ```yaml
     apiVersion: crd.projectcalico.org/v1
     kind: IPPool
     metadata:
       name: ${IPPOOL_NAME}
     spec:
       cidr: ${CIDR}
       ipipMode: Always
       vxlanMode: Never # vxlanMode
       natOutgoing: true
       nodeSelector: all()
       allowedUses:
       - Workload
       - Tunnel
     ```

   - https://docs.tigera.io/archive/v3.23/reference/resources/ippool#spec

   - 此选项此前未加是因为官方文档中显示默认值即为 `Never`，但目前来看不加还不行，或许是程序自身存在bug，进而导致默认值未生效。

3. 能否为Pod分配指定的IP地址，取决于使用的网络插件，例如目前集群所使用的网络插件是calico，calico可以通过ippool的方式指定，其它的网络插件可能不支持为Pod分配指定的IP地址，或者需要使用其它的配置方法。；

   - https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/#networking-and-network-policy

4. 最后要注意不要与集群内外所使用的IP地址产生冲突，但如果分配的是公网IP，那么基本上没有冲突的可能性，因为集群内外使用的是局域网IP。



---



**Pod 间通信调研**

如果只关注Pod产生的流量，如何进行区分？而不关注系统层面产生流量杂音?



- 使用 tcpdump 实现流量取反：

```sh
tcpdump -s 0 -Q inout not host 114.114.114.114 and not host 169.254.25.10 and not port mysql and not port 9200 and not port 30196 and not arp -w pcap_path
```



- 使用 Python Scapy 实现流量取反：

```python
from scapy.all import sniff, wrpcap, Ether, ARP, IP, TCP

pcap_path = "capture.pcap"

def packet_callback(packet):
    if Ether in packet and IP in packet and TCP in packet and ARP not in packet:
        src_ip = packet[IP].src
        dst_ip = packet[IP].dst
        src_port = packet[TCP].sport
        dst_port = packet[TCP].dport

        if src_ip != "114.114.114.114" and src_ip != "169.254.25.10" and \
                dst_port not in [3306, 9200, 30196]:
            # 处理满足条件的数据包
            wrpcap(pcap_path, packet, append=True)  # 将数据包写入pcap文件

# 捕获满足条件的数据包并写入pcap文件
sniff(filter="not arp", prn=packet_callback, store=0)

print("数据包捕获完成，保存在", pcap_path)
```





在容器中抓包时，如果只想留下 HTTP 的报文，但 HTTP 的目标端口又是不固定的（非 80，有可能是 81、82、8080 等），可以使用 Wireshark 这样的网络抓包工具结合过滤规则来实现。

以下是一种可能的过滤规则示例，用于只捕获目标端口为 80、81、82 或 8080 的 HTTP 报文：

```
tcp.port == 80 or tcp.port == 81 or tcp.port == 82 or tcp.port == 8080 and http
```

这个过滤规则使用了逻辑运算符 `or` 来组合多个 TCP 端口条件，并且使用 `http` 过滤器来限制只捕获 HTTP 协议的报文。

在 Wireshark 中，你可以在捕获过程中应用这个过滤规则，或者在已经捕获的数据中应用该过滤规则来筛选出符合条件的报文。



如果目标端口是随机的，没有固定的范围或模式，那么在捕获数据包时可能无法直接使用端口号来过滤。

在这种情况下，你可以考虑使用更为宽松的过滤规则来捕获尽可能多的数据包，然后在捕获后的数据中进一步筛选出 HTTP 报文。

以下是一个示例过滤规则，用于捕获所有的 TCP 流量，然后筛选出包含 HTTP 报文的数据包：

```
tcp and http
```

这个过滤规则只捕获 TCP 协议的数据包，并通过 `http` 过滤器来筛选出包含 HTTP 报文的数据包。

在捕获完数据包后，你可以使用 Wireshark 或其他类似的工具来进一步检查捕获的数据包，按照 HTTP 协议的特征来判断哪些是 HTTP 报文，然后进行进一步的分析或处理。
