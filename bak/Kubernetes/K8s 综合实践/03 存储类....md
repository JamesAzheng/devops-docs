**未完。。。。。**

# PV / PVC

**参考文档：**

- https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/

- https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#portworxvolume
- https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#persistentvolumeclaim

## PV 概述

- **PV 可以理解为是对底层网络存储的一种高级封装，从而实现对存储的容量划分、读写访问权限控制等功能**

- PersistentVolume 持久卷，是集群中的一块存储，可以由管理员事先供应，或者使用[存储类（Storage Class）](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/)来动态供应



## PVC 概述

- **PVC 可以申请 PV 中的存储空间，最终交给 Pod 来使用，PVC 同样也可以实现访问控制，如控制单个或多个节点的读写或只读方式挂载，Pod 是通过 PVC 将数据保存至 PV，PV 再保存至存储**

- persistentVolumeClaim 持久卷申领，表达的是用户对存储的请求。概念上与 Pod 类似。 Pod 会耗用节点资源，而 PVC 申领会耗用 PV 资源。Pod 可以请求特定数量的资源（CPU 和内存）；同样 PVC 申领也可以请求特定的大小和访问模式（访问模式见下文）



## PV / PVC 访问模式

- **通常是在 PVC 中定义访问模式**

**accessModes：**

- **ReadWriteOnce**

  - 卷可以被一个节点以读写方式挂载。
  - ReadWriteOnce 访问模式也允许运行在同一节点上的多个 Pod 访问卷。

- **ReadOnlyMany**

  - 卷可以被多个节点以只读方式挂载。

- **ReadWriteMany**

  - 卷可以被多个节点以读写方式挂载。

- **ReadWriteOncePod**

  - 卷可以被单个 Pod 以读写方式挂载。
  - 如果你想确保整个集群中只有一个 Pod 可以读取或写入该 PVC， 请使用ReadWriteOncePod 访问模式。这只支持 CSI 卷以及需要 Kubernetes 1.22 以上版本。

- **PS：在命令行接口（CLI）中，访问模式也使用以下缩写形式：**

  - RWO - ReadWriteOnce
  - ROX - ReadOnlyMany
  - RWX - ReadWriteMany
  - RWOP - ReadWriteOncePod

   

## PV 删除机制

- 删除机制即删除存储卷的时候，已经创建好的存储卷的删除机制

**persistentVolumeReclaimPolicy：**

- **Delete**
  - 自动删除存储卷
- **Recycle**
  - 空间回收，即删除存储卷上的所有数据(包括目录和隐藏文件)，目前仅支持 NFS 和 hostPath
- **Retain**
  - 删除 PV 后保持原装，最后需要管理员手动删除





## StorageClass 概述

- https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#nfs



## 工作流程概述

- 容器中的数据 **-->** PVC **-->** PV **-->** 实际的存储(如：NFS、NAS、ceph等)



## PV / PVC 实现

- 下面实现了为 nginx 实现 PV / PVC 存储的方式，更多细节参阅：Kubernetes 实战 --> 2.0  zookeeper 集群实现.md

- https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-persistent-volume-storage/

### 创建 NFS 存储类 StorageClass

- 创建存储类为 PV 提供存储空间

- https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#nfs

#### 配置 nfs 存储

- nfs 安装过程省略

```bash
# 共享的文件
# ls /nfs_data/nginx
about.html  contact.html  css  fonts  images  index.html  js  sass  services.html


# 配置共享
# vim /etc/exports
/nfs_data/nginx/ *(rw,no_root_squash)


# 重新加载配置文件
exportfs -r


# 查看挂载信息
# showmount -e 10.0.0.103
Export list for 10.0.0.103:
/nfs_data/nginx *


# 测试挂载
...
```

#### 定义 yaml 文件

```yaml
# vim /data/yaml/storageclasses/nfs-storageclass.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: example-nfs # 名称可自定义
provisioner: nfs # 存储的类型
parameters:
  server: 10.0.0.103 # NFS 服务器的主机名或 IP 地址
  path: /nfs_data/nginx # NFS 服务器设置的共享路径
  readOnly: "false" # 是否将存储挂载为只读的标志（默认为 false，true表示设为只读）
```

#### 查看结果

```bash
# kubectl apply -f /data/yaml/storageclasses/nfs-storageclass.yaml
storageclass.storage.k8s.io/example-nfs created


# kubectl get storageclasses.storage.k8s.io
NAME          PROVISIONER   RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE
example-nfs   nfs           Delete          Immediate           false                  5s
```

### 创建 PV

- 基于事先创建的存储类来创建 PV

#### 定义 yaml 文件

```yaml
# vim /data/yaml/project-1/pv/project-1-pv.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: project-1-pv
  labels:
    type: project-1-pv
  namespace: project-1 # 存放在哪个 namespace，不指定则默认为 default
spec:
  storageClassName: example-nfs # 引用存储类的名字
  capacity:
    storage: 10Gi # 定义存储的容量
  accessModes:
    - ReadWriteOnce # 访问模式，参阅上文
  persistentVolumeReclaimPolicy:
    - Retain # PV删除机制，参阅上文
  nfs:
    path: "/nfs_data/nginx" # nfs 共享的路径
    server: 10.0.0.103 # nfs 的域名或IP
```

#### 查看结果

```bash
# kubectl apply -f /data/yaml/project-1/pv/project-1-pv.yaml
persistentvolume/project-1-pv-volume created


# kubectl get pv
NAME           CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE
project-1-pv   10Gi       RWO            Retain           Available           example-nfs             4s
```



### 创建 PVC

- 基于 PV 来创建 PVC，pod 最终会通过 PVC 来请求物理存储

#### 定义 yaml 文件

```yaml
# vim /data/yaml/project-1/pv/project-1-pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: project-1-pvc
  namespace: project-1 # 存放在哪个 namespace，不指定则默认为 default
spec:
  volumeName: project-1-pv # 引用PV的名字，常用，也可以使用标签选择器来指定PV
  #selector: 
  #  matchLabels:
  #    type: project-1-pv # 使用标签选择器来指定PV
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 3Gi
```

#### 查看结果

```bash
# kubectl apply -f project-1-pvc.yaml 
persistentvolumeclaim/project-1-pv-claim created


# kubectl get pvc -A
NAMESPACE   NAME                 STATUS   VOLUME                CAPACITY   ACCESS MODES   STORAGECLASS   AGE
project-1   project-1-pv-claim   Bound    project-1-pv-volume   10Gi       RWO            example-nfs    2m18s


# 再次查看PV状态，可以看到之前创建的PV已经被PVC申领（CLAIM），并且已处于 Bound 状态
# 创建 PersistentVolumeClaim 之后，Kubernetes 控制平面将查找满足申领要求的 PersistentVolume。 如果控制平面找到具有相同 StorageClass 的适当的 PersistentVolume， 则将 PersistentVolumeClaim 绑定到该 PersistentVolume 上
# kubectl get pv -A
NAME                  CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                          STORAGECLASS   REASON   AGE
project-1-pv-volume   10Gi       RWO            Retain           Bound    project-1/project-1-pv-claim   example-nfs             58s
```



### 创建 Pod

- pod 使用 PVC 来请求物理存储

#### 定义 yaml 文件

```yaml
# vim /data/yaml/project-1/project-1-nginx.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: project-1-nginx-deployment
  labels:
    app: project-1-nginx-deployment-label
  namespace: project-1
spec:
  replicas: 1
  selector:
    matchLabels:
      app: project-1-nginx-deployment-label
  template:
    metadata:
      labels:
        app: project-1-nginx-deployment-label
    spec:
      restartPolicy: Always
      containers:
      - name: project-1-nginx-container
        #image: harbor.xiangzheng.vip/project-1/project-1-nginx-1.18.0-ubuntu:1.0
        image: nginx
        imagePullPolicy: Always
        ports:
        - containerPort: 80
          name: http
          protocol: TCP
        - containerPort: 443
          name: https
          protocol: TCP
        resources:
          requests:   
            cpu: 20m
            memory: 32Mi   
          limits:   
            cpu: 100m   
            memory: 64Mi
        volumeMounts:
        - mountPath: "/usr/share/nginx/html"
          name: project-1-pvc
      volumes:
      - name: project-1-pvc
        persistentVolumeClaim:
          claimName: project-1-pv-claim

---

kind: Service
apiVersion: v1
metadata:
  labels:
    app: nginx-service
  name: nginx-service
  namespace: project-1
spec:
  type: NodePort
  ports:
  - name: http
    port: 80
    protocol: TCP
    targetPort: 80
    nodePort: 30003
  - name: https
    port: 443
    protocol: TCP
    targetPort: 443
    nodePort: 30004
  selector:
    app: project-1-nginx-deployment-label
```

#### 查看结果

```bash
# kubectl apply -f /data/yaml/project-1/project-1-nginx.yaml
deployment.apps/project-1-nginx-deployment created
service/nginx-service created


# 浏览器访问
...
```



