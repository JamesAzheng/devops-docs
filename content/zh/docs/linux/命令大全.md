---
title: "命令大全"
---


# 文件与目录管理

## mkdir

- 创建复杂目录

```bash
# mkdir -p /data/test/{a,b}/{x,y}
# tree
.
└── test
    ├── a
    │   ├── x
    │   └── y
    └── b
        ├── x

        └── y

---

# mkdir -p /data/test/{a,b/{x,y}}
# tree
.
└── test
    ├── a
    └── b
        ├── x

        └── y

---

# mkdir -p /data/test/dir{3,4,5/dir{6,7}}
# tree
.
└── test
    ├── dir3
    ├── dir4
    └── dir5
        ├── dir6
        └── dir7
```







## cp

- 简写备份

```sh
cp file{,.bak}
```



## 远程拷贝前言

- scp 和 rsync 命令都可以实现将本地文件复制到远程，或者将远程文件复制到本地
- 但 scp 和 rsync 在实现前都需要与对端主机建立 ssh 免密登录，并且使用 rsync 命令时还需要在客户端安装rsync的工具包才能使用
- **注意：无论是是使用 scp 还是 rsync，都应该在数据拷贝前先将目标文件进行备份，以避免误操作导致目标文件被覆盖或者被删除**
- 需要补充的是，对于scp命令，虽然建立ssh免密登录是推荐的做法，但也可以使用scp命令的-P选项指定端口号，并使用scp命令的-i选项指定身份验证文件来进行身份验证，以避免使用密码登录。
- 对于rsync命令，它是在大多数Linux发行版中默认安装的，因此通常情况下无需安装rsync工具包。此外，rsync命令还可以通过SSH协议进行安全传输，并且可以利用rsync的特殊算法来减少传输的数据量和时间，因此在大规模数据传输和备份方面，rsync通常比scp更受欢迎。

## scp

### scp option

- 这些选项可以组合使用，以满足不同的需求。例如，`scp -rvC file.txt user@remotehost:/path/to/dir`将启用递归模式、压缩传输并显示详细输出信息，将文件拷贝到远程主机。

```sh
# 传输选项
-P <port> # 指定SSH端口，默认为22。指定SSH端口号，一般用于远程主机开启了非默认端口号的情况，例如`scp -P 2222 file.txt user@remotehost:/path/to/dir`。

-C # 启用压缩传输，可提高传输速度。开启压缩传输，可加快传输速度，适用于较慢的网络环境。


# 操作选项
-r # 递归复制整个目录。递归复制整个目录，即将目录下的所有文件和子目录都复制到目标主机。例如，`scp -r /path/to/source/dir user@remotehost:/path/to/target/dir`。

-p # 保留文件的权限和时间戳等属性。保留文件的属性，包括文件权限、时间戳和所有者等。例如，`scp -rp file.txt user@remotehost:/path/to/dir`。

-q # 不显示传输进度。不显示传输进度，适用于在脚本中使用。


# 其他选项
-v # 显示详细输出信息，可以用于调试。

-B # 使用批处理模式（batch mode）。使用批处理模式，即只进行一次加密会话，适用于在脚本中使用，例如`scp -B file.txt user@remotehost:/path/to/dir`。

-S <program> # 指定加密程序，默认使用ssh。指定加密程序，例如`scp -S /usr/bin/ssh2 file.txt user@remotehost:/path/to/dir`。

-i <identity_file> # 指定使用的私钥文件，例如`scp -i /path/to/private_key file.txt user@remotehost:/path/to/dir`。
```





### scp example

以下是scp在生产环境中常见的用法范例：

- **将本地文件拷贝到远程主机**

将本地文件file.txt拷贝到远程主机的/path/to/dir目录下：

```
scp file.txt user@remotehost:/path/to/dir
```

- **将远程主机文件拷贝到本地**

将远程主机上的file.txt文件拷贝到本地的/path/to/local/dir目录下：

```
scp user@remotehost:/path/to/file.txt /path/to/local/dir/
```

- **将本地目录递归拷贝到远程主机**

将本地目录/path/to/local/dir递归拷贝到远程主机的/path/to/remote/dir目录下：

```
scp -r /path/to/local/dir user@remotehost:/path/to/remote/dir
```

- **将远程主机目录递归拷贝到本地**

将远程主机的/path/to/remote/dir目录递归拷贝到本地的/path/to/local/dir目录下：

```
scp -r user@remotehost:/path/to/remote/dir /path/to/local/dir
```

- **使用指定的私钥文件进行拷贝**

使用指定的私钥文件（例如，/path/to/private_key）将本地文件file.txt拷贝到远程主机的/path/to/dir目录下：

```
scp -i /path/to/private_key file.txt user@remotehost:/path/to/dir
```

- **使用指定的SSH端口号进行拷贝**

使用SSH端口号2222将本地文件file.txt拷贝到远程主机的/path/to/dir目录下：

```
scp -P 2222 file.txt user@remotehost:/path/to/dir
```

- **保留文件属性进行拷贝**

使用递归模式和-p选项将本地目录/path/to/local/dir递归拷贝到远程主机的/path/to/remote/dir目录下，并保留文件属性：

```
scp -rp /path/to/local/dir user@remotehost:/path/to/remote/dir
```

- **启用压缩传输进行拷贝**

使用压缩传输和-v选项将本地文件file.txt拷贝到远程主机的/path/to/dir目录下，并显示详细输出信息：

```
scp -vC file.txt user@remotehost:/path/to/dir
```

这些例子只是scp的部分用法范例，根据实际需求可进行组合使用。





## rsync

- rsync 可以在本地主机上操作，也可以在远程主机之间同步文件或目录

### rsync syntax

```sh
rsync [OPTION]... SRC DEST
rsync [OPTION]... SRC [USER@]host:DEST
rsync [OPTION]... [USER@]HOST:SRC DEST
rsync [OPTION]... [USER@]HOST::SRC DEST
rsync [OPTION]... SRC [USER@]HOST::DEST
rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]
```

对应于以上六种命令格式，rsync有六种不同的工作模式：

- 拷贝本地文件。当SRC和DES路径信息都不包含有单个冒号":"分隔符时就启动这种工作模式。如：rsync -a /data /backup
- 使用一个远程shell程序(如rsh、ssh)来实现将本地机器的内容拷贝到远程机器。当DST路径地址包含单个冒号":"分隔符时启动该模式。如：rsync -avz *.c foo:src
- 使用一个远程shell程序(如rsh、ssh)来实现将远程机器的内容拷贝到本地机器。当SRC地址路径包含单个冒号":"分隔符时启动该模式。如：rsync -avz foo:src/bar /data
- 从远程rsync服务器中拷贝文件到本地机。当SRC路径信息包含"::"分隔符时启动该模式。如：rsync -av root@192.168.78.192::www /databack
- 从本地机器拷贝文件到远程rsync服务器中。当DST路径信息包含"::"分隔符时启动该模式。如：rsync -av /databack root@192.168.78.192::www
- 列远程机的文件列表。这类似于rsync传输，不过只要在命令中省略掉本地机信息即可。如：rsync -v rsync://192.168.78.192/www

### rsync option

```sh
-v, --verbose                 # 增加输出信息的详细程度
-z, --compress                # 在传输过程中压缩压缩文件数据
-q, --quiet                   # 不显示非错误信息
-c, --checksum                # 比较文件时使用文件的校验和而非修改时间和文件大小
-a, --archive                 # 归档模式，相当于 -rlptgoD（不包括 -H,-A,-X 选项）

-r, --recursive               # 递归复制目录及其内容
-l, --links                   # 保留符号链接
-p, --perms                   # 保留文件权限
-t, --times                   # 保留文件修改时间
-g, --group                   # 保留文件所属组信息
-o, --owner                   # 保留文件所属用户信息
-D                            # 相当于 --devices --specials
--devices                     # 保留设备文件信息
--specials                    # 保留特殊文件信息

-R, --relative                # 使用相对路径名
-b, --backup                  # 创建备份文件（使用 --suffix 和 --backup-dir 选项来指定备份文件名及存放目录）
--backup-dir=DIR              # 指定备份文件的存放目录
--suffix=SUFFIX               # 指定备份文件的后缀名（默认是 ~，除非使用了 --backup-dir 选项）
-u, --update                  # 仅复制源目录中较新的文件
--inplace                     # 原地修改目标文件，不备份原文件（详见手册）
--append                      # 附加数据到目标文件的末尾
--append-verify               # 附加数据到目标文件的末尾，并验证文件校验和
-d, --dirs                    # 复制目录但不递归复制其内容
-L, --copy-links              # 复制符号链接本身
-K, --keep-dirlinks           # 保留符号链接目录
-k, --copy-dirlinks           # 复制符号链接目录本身而非其中的内容
-H, --hard-links              # 保留硬链接
--stats                       # 显示文件传输过程的统计信息
--progress                    # 显示文件传输进度
--human-readable              # 以易读的方式显示输出信息
--log-file=FILE               # 将输出信息保存到指定文件中
--partial                     # 在传输中途停止，下次继续传输（详见手册）
--partial-dir=DIR             # 传输中途文件的临时存放目录
--timeout=SECONDS             # 设置连接超时时间
--password-file=FILE          # 从指定文件中读取密码
--delete                      # 删除目标目录中源目录中不存在的文件，删除目标目录中不存在的文件
--delete-before               # 在传输之前删除目标目录中源目录中不存在的文件
--delete-after                # 在传输之后删除目标目录中源目录中不存在的文件
--delete-excluded             # 在传输时删除排除的文件
--exclude=PATTERN             # 排除符合指定模式的文件
--include=PATTERN             # 仅传输符合指定模式的文件
```

- **--delete**

  - 需要注意的是，在使用 --delete 选项时应该非常小心，因为如果误操作会导致目标目录中的文件被删除，从而造成数据丢失。因此，建议在使用 rsync 命令时，首先做好数据备份，并在执行命令前使用 --dry-run 选项查看同步前后的差异

  - --delete 选项的具体功能如下：

    - 如果源目录中有新的文件或文件夹，同步后目标目录也会有新的文件或文件夹。
    - 如果源目录中的文件或文件夹被删除，同步后目标目录中也会将对应的文件或文件夹删除。
    - 如果源目录中的文件或文件夹被修改，同步后目标目录中对应的文件或文件夹也会被更新。
    - 如果目标目录中有多余的文件或文件夹，使用 --delete 选项可以将这些文件或文件夹删除。

  - 范例：

    - ```sh
      # 下面的命令表示将 /path/to/source/ 中的文件同步到 /path/to/destination/ 中，并删除 /path/to/destination/ 中不存在于 /path/to/source/ 中的文件。
      
      rsync -av --delete /path/to/source/ /path/to/destination/
      ```

  - 假设目标目录中存在一个 test.txt 的文件，但源目录中没有这个 test.txt 的文件，那么在添加此选项时目标目录中的 test.txt 文件将被删除

    - 您总结的是正确的。当使用 rsync 命令中的 --delete 选项时，如果源目录中不存在某个文件或文件夹，而目标目录中却存在该文件或文件夹，则目标目录中的该文件或文件夹将被删除。因此，在您的例子中，假设目标目录中存在一个 test.txt 的文件，但源目录中没有这个 test.txt 的文件，那么在添加此选项时目标目录中的 test.txt 文件将被删除。

  - 换句话讲，使用 rsync 命令添加 --delete 选项后，目标将以源为基准，目标与源不符的文件或目录都将被删除



### rsync  注意事项

**确保源和目标路径正确无误**

- rsync 的第一个参数是源路径，第二个参数是目标路径。在使用 rsync 时，务必要注意源和目标路径不要整错。否则，您可能会将文件复制到错误的位置或覆盖您不希望覆盖的文件。
- rsync 的基本功能是**将源文件或目录同步到目标文件或目录中**
  - 在同步过程中，rsync 会根据源和目标文件的时间戳、文件大小、文件权限等信息进行比较，仅传输源和目标不同的部分，从而实现快速高效的文件同步。
  - 当源和目标文件完全一致时，rsync 会忽略它们，以减少同步时间和网络带宽的消耗。
  - 总之，rsync 可以实现源与目标的双向同步，以保持它们之间的内容一致。

**确认是否需要同步子目录**

- rsync 默认会递归同步源目录下的所有文件和子目录，如果您只需要同步目录下的文件而不需要子目录，可以使用 rsync 的参数“--no-recursion”禁止递归。

**使用正确的选项**

- rsync 有很多选项可以控制同步行为，例如“--archive”选项可以保留文件权限和时间戳，“--delete”选项可以删除目标目录中不存在的文件。在使用 rsync 时，务必要仔细研究这些选项，选择适合您的同步需求的选项。

**确认网络连接是否可靠**

- rsync 可以在本地同步文件，也可以在远程服务器之间同步文件。如果您在远程服务器之间同步文件，务必要确认网络连接稳定可靠，以避免同步过程中出现错误或中断。

**使用日志功能**

- rsync 提供了日志功能，可以记录同步过程中的详细信息，包括哪些文件被同步、哪些文件被忽略等。使用日志功能可以帮助您更好地了解同步过程，并快速解决任何问题。



### rsync example

- **从本地复制文件到远程服务器：**

```sh
rsync -avz /path/to/local/file username@remote:/path/to/remote/directory/
```

- **从远程服务器复制文件到本地：**

```sh
rsync -avz username@remote:/path/to/remote/file /path/to/local/directory/
```

- **在本地同步两个目录：**

```sh
rsync -avz /path/to/source/directory /path/to/destination/directory
```

- **在远程服务器上同步两个目录：**

```sh
rsync -avz username@remote:/path/to/source/directory username@remote:/path/to/destination/directory
```

- **在远程服务器上使用ssh隧道同步两个目录：**

```sh
rsync -avz -e 'ssh -p 22' username@remote:/path/to/source/directory username@remote:/path/to/destination/directory
```

- **在本地同步两个目录，并删除目标目录中源目录不存在的文件或目录：**

```sh
rsync -avz --delete /path/to/source/directory /path/to/destination/directory
```

- **在本地同步两个目录，但不同步某些文件或目录：**

```sh
rsync -avz --exclude 'file1.txt' --exclude 'dir1/' /path/to/source/directory /path/to/destination/directory
```

- **将本地目录备份到远程服务器，并保留备份文件：**

```sh
rsync -avz --backup --suffix=.bak /path/to/local/directory username@remote:/path/to/remote/directory
```





### rsync 配置文件

rsync可以通过配置文件进行参数设置和定制化，常用的配置文件是`/etc/rsyncd.conf`和`/etc/rsyncd.secrets`。

#### /etc/rsyncd.conf

该配置文件用于设置rsync服务器的全局参数和模块参数，其中模块是rsync的一种工作模式，它定义了可以同步的本地或远程文件目录。

以下是一个简单的`/etc/rsyncd.conf`配置文件示例：

```sh
uid = nobody # rsync进程使用的用户ID
gid = nobody # rsync进程使用的组ID
use chroot = yes # 是否使用chroot环境
max connections = 4 # 同时处理的最大客户端连接数
timeout = 300 # 超时时间
read only = yes # 是否只读
log file = /var/log/rsync.log # 日志文件路径
# hosts allow 和 hosts deny 可以定义允许或拒绝访问的主机列表。
[backup]
path = /path/to/local/backup
comment = Backup directory
```



#### /etc/rsyncd.secrets

- 该配置文件用于设置rsync服务器的身份验证信息。默认情况下，rsync服务器是不需要身份验证的，但是可以通过该配置文件启用用户名和密码身份验证。

以下是一个简单的`/etc/rsyncd.secrets`配置文件示例：

```sh
username:password
```

要使用该配置文件，需要在`/etc/rsyncd.conf`配置文件中添加以下选项：

```sh
secrets file = /etc/rsyncd.secrets
```

注意：为了安全起见，应该限制该文件的权限，只允许root用户读取。

以上是rsync的两个常见配置文件，rsync还有其他一些配置选项，可以通过`man rsyncd.conf`和`man rsyncd.secrets`命令来查看详细信息。



### rsync 配置文件优化

rsync的配置文件可以根据不同的场景进行优化，以提高其性能和效率。以下是一些rsync配置文件的优化建议：

- **启用rsync守护进程模式**

如果您需要在rsync服务器上提供文件同步服务，可以启用rsync守护进程模式。在守护进程模式下，rsync服务器始终保持运行状态，可以提供快速响应的文件同步服务。

在`/etc/rsyncd.conf`配置文件中添加以下选项：

```
pid file = /var/run/rsyncd.pid
lock file = /var/run/rsyncd.lock
```

- **启用TCP/IP加速模式**

rsync支持TCP/IP加速模式，可以通过该模式提高文件同步的速度。在该模式下，rsync使用TCP/IP协议进行数据传输，可以提高传输速度和效率。

在`/etc/rsyncd.conf`配置文件中添加以下选项：

```
socket options = SO_KEEPALIVE TCP_NODELAY
```

- **启用压缩模式**

如果您需要同步大量的数据文件，可以启用rsync的压缩模式。在该模式下，rsync会对传输的数据进行压缩，可以大幅度减少传输时间和带宽占用。

在命令行中添加`-z`参数启用压缩模式，或在`/etc/rsyncd.conf`配置文件中添加以下选项：

```
compress = yes
```

- **启用日志记录功能**

rsync支持日志记录功能，可以记录文件同步过程中的详细信息。启用日志记录功能可以帮助您分析和诊断文件同步问题，提高同步效率和可靠性。

在`/etc/rsyncd.conf`配置文件中添加以下选项：

```
log file = /var/log/rsyncd.log
log format = %h %o %f %l %b
```

- **启用限速模式**

如果您需要在文件同步过程中限制带宽使用率，可以启用rsync的限速模式。在该模式下，rsync会控制传输速度，避免对网络带宽造成影响。

在命令行中添加`--bwlimit`参数启用限速模式，或在`/etc/rsyncd.conf`配置文件中添加以下选项：

```
bwlimit = 1000 # 限制传输速度为1000KB/s
```

注意：以上配置文件选项只是一些优化建议，实际使用时应根据具体情况进行调整。



### rsync 同步数据慢的解决方法

如果rsync同步数据的速度较慢，可以尝试以下方法进行解决：

- **调整IO调度算法**

IO调度算法会影响到数据读写速度，如果IO调度算法不合适，会导致rsync同步数据的速度变慢。建议使用NOOP或Deadline调度算法，可以提高数据读写速度。

在Linux系统中，可以通过以下命令查看当前IO调度算法：

```
cat /sys/block/sda/queue/scheduler
```

可以通过修改`/etc/default/grub`文件中的GRUB_CMDLINE_LINUX_DEFAULT选项，添加elevator=deadline或elevator=noop来修改IO调度算法，例如：

```
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash elevator=deadline"
```

修改后，执行以下命令使修改生效：

```
sudo update-grub
```

- **调整文件系统类型**

文件系统类型也会影响数据读写速度，建议使用ext4等性能较好的文件系统类型，可以提高rsync同步数据的速度。

可以通过以下命令查看当前使用的文件系统类型：

```
df -T
```

如果当前使用的文件系统类型性能较差，可以考虑更换为性能更好的文件系统类型。

- **启用硬件加速**

一些硬件设备支持加速数据读写操作，可以提高rsync同步数据的速度。例如，可以启用RAID卡的缓存机制，提高数据读写速度。

- **启用压缩模式**

启用rsync的压缩模式可以减少数据传输量，提高同步速度。在命令行中添加`-z`参数或在配置文件中添加`compress = yes`选项即可启用压缩模式。

- **启用并行传输**

启用rsync的并行传输模式可以同时传输多个文件，提高同步速度。在命令行中添加`--parallel`参数或在配置文件中添加`max connections = 4`等选项即可启用并行传输模式。

注意：以上方法仅是一些常见的解决方法，实际使用时应根据具体情况进行调整。



## ln

创建软硬链接

```sh
# -nfs 覆盖当前软链接，直接创建新的软链接
# ll /etc/localtime 
lrwxrwxrwx 1 root root 30 Jul 30 15:07 /etc/localtime -> /usr/share/zoneinfo/Asia/Tokyo
# ln -nfs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
# ll /etc/localtime 
lrwxrwxrwx 1 root root 33 Jul 30 14:07 /etc/localtime -> /usr/share/zoneinfo/Asia/Shanghai

```





# IO 重定向

## tee

- tee 命令 可以读取标准输入的数据，将其内容输出成文件，并在屏幕上打印一份

```bash
date |& tee 123


# 不在屏幕上打印
date |& tee 123 &> /dev/null
# 或直接
date &> 123
```







# 性能指标

## CPU

- 查看IO：top、iostat、vmstat

- 查看负载：top、w、uptime



## 内存

- free -h、top



## 磁盘

- 查看IO：iostat、vmstat
- 查看读写量：iotop
- 磁盘容量：df -h

## 网络

- nethogs、iftop -n、nload、glances（可以远程监控）、sar -n DEV 2 3、iptraf-ng（华丽界面）



### nload

- 查看网络流量



## vmstat

- **显示虚拟内存信息**

### 常用选项

```bash
-s  #显示内存的统计数据
1   #每一秒执行一次
1 3 #每一秒执行一次，执行三次后退出
```

### 范例

```bash
[root@centos ~]# vmstat 
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 3  0      0 162080      0 1399348    0    0     1     5   13    5  1  1 98  0  0
```

### 显示项说明

```bash
#procs:
 r 可运行（正运行或等待运行）进程的个数，和核心数有关
 b 处于不可中断睡眠态的进程个数(被阻塞的队列的长度)

#memory：
 swpd 交换内存的使用总量
 free 空闲物理内存总量
 buffer 用于buffer的内存总量
 cache 用于cache的内存总量

#swap:
 si 从磁盘交换进内存的数据速率(kb/s)
 so 从内存交换至磁盘的数据速率(kb/s)

#io：
 bi 从块设备读入数据到系统的速率(kb/s)
 bo 保存数据至块设备的速率(kb/s)

#system：
 in interrupts 中断速率，包括时钟
 cs context switch 进程切换速率

#cpu：
 us Time spent running non-kernel code
 sy Time spent running kernel code
 id Time spent idle. Linux 2.5.41前,包括IO-wait time.
 wa Time spent waiting for IO. 2.5.41前，包括in idle.
 st Time stolen from a virtual machine. 2.6.11前, unknown.
```





## iostat

- **统计CPU和设备IO信息**
- 此工具由 sysstat 包提供

### 范例

```bash
[root@centos ~]# iostat
Linux 4.18.0-240.22.1.el8_3.x86_64 (centos) 	12/20/2021 	_x86_64_	(1 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.62    0.01    1.27    0.00    0.00   98.09

Device             tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda               0.43         1.19         4.92    3373248   13930785
```

### 数值说明

```bash
# iostat
%user #CPU处在用户模式下的时间百分比。

%nice #CPU处在带NICE值的用户模式下的时间百分比

%system #CPU处在系统模式下的时间百分比

%iowait #CPU等待输入输出完成时间的百分比。值过高时，表示硬盘存在I/O瓶颈

%steal #管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。

%idle #CPU空闲时间百分比。值高表示CPU较空闲。值高但系统响应慢时，可能是CPU等待分配内存，应加内存值持续低于10，表明CPU处理能力相对较低，系统中最需要解决的资源是CPU

#iftop -n
TX #发送（上传）
RX #接受（下载）
cum #总合
peak #最高点
rates #速度
tps #该设备每秒的传输次数
kB_read/s #每秒从设备（drive expressed）读取的数据量；
kB_wrtn/s #每秒向设备（drive expressed）写入的数据量；
kB_read #读取的总数据量；
kB_wrtn #写入的总数量数据量；
```





## dstat

- **系统资源统计**
- dstat由pcp-system-tools包提供，用于代替 vmstat,iostat功能

### 常用选项

```bash
-c #显示cpu相关信息
-C #,#,...,total
-d #显示disk相关信息
-D #total,sda,sdb,...
-g #显示page相关统计数据
-m #显示memory相关统计数据
-n #显示network相关统计数据
-p #显示process相关统计数据
-r #显示io请求相关的统计数据
-s #显示swapped相关的统计数据
--tcp
--udp
--unix
--raw
--socket 
--ipc
--top-cpu #显示最占用CPU的进程
--top-io  #显示最占用io的进程
--top-mem #显示最占用内存的进程
--top-latency #显示延迟最大的进程
```

### 范例

```bash
[root@centos ~]# dstat 1 3
You did not select any stats, using -cdngy by default.
----total-usage---- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai stl| read  writ| recv  send|  in   out | int   csw 
  1   1  98   0   0|   0     0 | 474B 7331B|   0     0 |1616  3345 
  1   1  98   0   0|   0     0 | 318B 3064B|   0     0 |1518  3227 
  1   0  98   0   0|   0     0 | 240B 4615B|   0     0 |1424  3129 
```



## iotop

- **查看磁盘实时吞吐量**



## nethogs

- **查看网络实时吞吐量**





## pmrep

在 Linux 环境中，"pmrep" 是 Performance Co-Pilot (PCP) 工具套件中的一个命令行工具。PCP 是一个用于监控和性能分析的开源工具集，它可以帮助系统管理员和开发人员监测系统的性能指标、收集性能数据并进行分析。

"pmrep" 命令用于报告和显示 Performance Co-Pilot 的性能数据，它能够以不同的格式输出系统性能数据，方便用户进行分析和诊断。

下面是 "pmrep" 命令的一般用法和一些常用选项：

用法：

```
pmrep [options] [metric1] [metric2] ...
```

常用选项：

- `-s <start_time>`: 指定开始时间，格式为 "YYYYMMDD-HH:MM:SS"。
- `-e <end_time>`: 指定结束时间，格式为 "YYYYMMDD-HH:MM:SS"。
- `-z`: 显示数据时，使用 UTC 时间。
- `-H`: 不要显示标题行。
- `-c`: 连续输出数据，类似于类似于"top"命令。
- `-x`: 以逗号分隔的格式输出数据，便于后续处理。

例如，要显示 CPU 利用率和内存使用情况的数据，可以使用以下命令：

```
pmrep -c cpu.utilization.memory.used
```

这将连续输出 CPU 利用率和内存使用情况的数据，类似于类似于"top"命令的输出。

需要注意的是，Performance Co-Pilot 工具套件是一个非常强大和灵活的工具，"pmrep" 命令支持许多选项和参数。更多关于 "pmrep" 命令以及 Performance Co-Pilot 工具套件的详细信息，请参阅官方文档和手册页。你可以在 Linux 终端中输入以下命令来查看 "pmrep" 命令的手册页：

```
man pmrep
```



# 防止终端关闭导致进程结束

screen tmux nohup 这些命令都是用来在 Linux 系统中运行长时间运行的进程或命令，且可以让用户在断开与服务器的连接后，进程或命令仍能够继续运行。

- `screen` 是一个终端多路复用器，它允许用户在一个终端窗口中运行多个进程，并且可以在窗口之间切换。用户可以在其中运行需要长时间运行的进程，如后台进程、守护进程等，甚至可以在不同的终端中重新连接到同一个 `screen` 会话，从而方便用户管理多个进程。
- `tmux` 与 `screen` 类似，也是一个终端多路复用器，它也可以让用户在一个终端窗口中运行多个进程，且可以在窗口之间切换。`tmux` 的一些特点是支持更多的定制化选项、有更好的鼠标支持、可以在一个终端窗口中拆分出多个面板等等。
- `nohup` 命令用于运行一个命令，使得在用户退出登录后该命令仍能够继续运行。它通常用于在后台运行需要长时间运行的命令，如长时间备份、长时间压缩等任务。

## screen

可以利用screen命令进行后台运行（yum -y install screen）
在命令行执行screen 回车，进入一个随机的screen后台，可以输入命令，然后按ctrl +a+d保存退出即可，这时程序已经在后台运行。
screen ls可以查看当前运行screen后台列表,执行screen r 加PID可以进入相应的后台，再次退出还需要按ctrl+a+d
如何想要删除screen，需要执行kill -9 3215（screen ls查看到的脚本后台进程号），然后执行screen -wipe 即可删除。

以下是一些 `screen` 常见的用法：

1. 启动 `screen` 会话：

   ```
   screen
   ```

   这个命令会启动一个新的 `screen` 会话。

2. 从 `screen` 会话中退出：

   ```
   ctrl+a d
   ```

   这个命令会从当前的 `screen` 会话中退出，并把会话放到后台运行。

3. 列出所有 `screen` 会话：

   ```
   screen -ls
   ```

   这个命令会列出所有正在运行的 `screen` 会话。

4. 重新连接到某个 `screen` 会话：

   ```
   screen -r session_id
   ```

   这个命令会重新连接到指定的 `screen` 会话。`session_id` 可以是 `screen -ls` 命令中显示的会话 ID，也可以是会话名称。

5. 分割窗口：

   ```
   ctrl+a S
   ```

   这个命令会将当前窗口垂直分割为两个窗口。

6. 切换窗口：

   ```
   ctrl+a tab
   ```

   这个命令会切换到下一个窗口。

7. 向上滚动：

   ```
   ctrl+a [
   ```

   这个命令会允许用户向上滚动查看之前的输出内容。

8. 停止 `screen` 会话中的进程：

   ```
   ctrl+a k
   ```

   这个命令会停止当前 `screen` 会话中的进程，类似于在普通终端中使用 `ctrl+c` 命令停止进程。

以上只是 `screen` 的一些常见用法，还有很多其他的用法可以根据需要进行了解和学习。





## tmux

增强版的screen

- tmux窗口中的快捷键都是需要先按ctrl+b 在按指定的快捷键指令才可运行
- 获取帮助：ctrl+b ？
- 分离会话：ctrl+b d 或在终端输入tmux detach（分离会话后 就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行）

```bash
#新建窗口并给会话命名，默认开启的窗口名称为0,1,...
tmux new -s <session-name>

#查看当前所有的 Tmux 会话
tmux ls
或
tmux list-session

#重新接入存活的会话
tmux attach -t 0 #0表示会话的编号
或使用会话名称：
tmux attach -t <session-name>
tmux attach-session -t <session-name>
```

### tmux最简操作流程：

1. 新建会话`tmux new -s my_session`。
2. 在 Tmux 窗口运行所需的程序。
3. 按下快捷键`Ctrl+b d`将会话分离。
4. 下次使用时，重新连接到会话`tmux attach-session -t my_session`。



`tmux` 是一个终端复用器，可以在单个终端窗口中同时运行多个终端会话，每个会话可以有多个窗口，每个窗口可以有多个分隔区域。以下是 `tmux` 的一些常见用法：

1. 启动 `tmux`：

   ```
   tmux
   ```

   这个命令会启动 `tmux`，并进入一个默认会话。

2. 新建一个会话：

   ```
   tmux new -s session_name
   ```

   这个命令会创建一个名为 `session_name` 的新会话。

3. 列出所有会话：

   ```
   tmux ls
   ```

   这个命令会列出所有的 `tmux` 会话。

4. 进入一个会话：

   ```
   tmux attach -t session_name
   ```

   这个命令会进入名为 `session_name` 的会话。

5. 分离当前会话：

   ```
   Ctrl-b d
   ```

   这个命令会将当前会话分离，返回到终端窗口。

6. 新建一个窗口：

   ```
   Ctrl-b c
   ```

   这个命令会在当前会话中新建一个窗口。

7. 切换窗口：

   ```
   Ctrl-b n
   ```

   这个命令会切换到下一个窗口。

8. 分割当前窗口：

   ```
   Ctrl-b %
   ```

   这个命令会将当前窗口分成左右两个分隔区域。

9. 在分割区域中切换：

   ```
   Ctrl-b 方向键
   ```

   这个命令会在分割区域中切换焦点。

10. 退出当前会话：

    ```
    exit
    ```

    这个命令会退出当前会话。

以上只是 `tmux` 的一些常见用法，还有很多其他的用法可以根据需要进行了解和学习。



## nohup

可以利用nohup命令进行后台运行：
即程序已经在后台运行，可以在当前目录查看tail -fn 10 nohup.out可以看到程序执行的相关信息，如果需要结束就直接kill 进程就OK。
-f 持续读取
-n<行数> 显示文件的尾部 n 行内容
nohup command &

`nohup` 命令用于在后台运行命令，不受终端的影响。以下是一些 `nohup` 常见的用法：

1. 启动后台任务：

   ```
   nohup command &
   ```

   这个命令会在后台运行 `command` 命令，并将输出写入 `nohup.out` 文件。

2. 指定输出文件：

   ```
   nohup command > output_file 2>&1 &
   ```

   这个命令会将命令的输出写入 `output_file` 文件中，同时将标准错误输出也写入该文件中。

3. 重新连接到 `nohup` 任务：

   ```
   ps -ef | grep nohup
   ```

   这个命令会列出所有正在运行的 `nohup` 任务的进程 ID。然后使用以下命令重新连接到该任务：

   ```
   nohup command & disown process_id
   ```

   其中 `command` 是该任务所运行的命令，`process_id` 是 `ps -ef` 命令输出的进程 ID。

4. 杀死 `nohup` 任务：

   ```
   kill process_id
   ```

   这个命令会杀死指定进程 ID 的 `nohup` 任务。

以上只是 `nohup` 的一些常见用法，还有很多其他的用法可以根据需要进行了解和学习。



## jobs

可以利用ctrl+z将命令或脚本放到后台暂停，在使用bg 加编号进行后台运行

窗口关闭，命令or脚本的进程也会结束

```bash
cmd & #后台运行

#ctrl+z
#ctrl+z暂停运行，注意这是让当前运行的脚本到后台，然后"暂停"运行。
[azheng@azheng opt]$ bash test.sh 
1
2
3
^Z

#获取后台暂停运行的编号
[azheng@azheng opt]$ jobs 
[1]+  Stopped                 bash test.sh


#bg命令让暂停的程序继续在后台运行，如果有标准输出会干扰前台的命令执行
[azheng@azheng opt]$ bg 1
[azheng@azheng opt]$ 38
39
40
^C
[azheng@azheng opt]$ 41
42
43
44
45
46

#fg命令让后台程序恢复前台运行
[azheng@azheng opt]$ fg 1
```







# 主机名管理

- 

```bash
# centos6
/etc/sysconfig/network

# centos7、8

```



# 文件查找

## locate

- 来自mlocate.x86_64包

- 基于locate数据库进行搜索：/var/lib/mlocate/mlocate.db
- 当机器刚开始运行时，不会立刻生成数据库文件，需要执行updatedb命令来生成（**建议找系统空闲时间执行updatedb命令**）
- **优点：查询速度快**
- **缺点：因为是依赖数据库，所以一般只能查询到相对固定的数据**

```bash
#常用选项
-i #不区分大小写
-n N #只列出前N个匹配的项目
-r #使用基本正则表达式
--regex #使用扩展的正则表达式
```

### 范例

```bash
#搜索包含conf的文件
locate conf

#搜索conf结尾的文件
locate -r '\.conf$'
locate --regex '.conf$'
```



## find

- 来自findutils-4.6.0-20.el8.x86_64包
- 实时查找工具，通过遍历指定路径完成文件查找
- 查找条件丰富
- **优点：查询数据精准全面**
- **缺点：因为是基于扫描磁盘，所以速度较慢**

###  格式：

```bash
find [OPTION]... [查找路径] [查找条件] [处理动作]
```

### 指定深度查询

```bash
find /etc/ -maxdepth #   #最大搜索目录深度,指定目录下的文件为第1级
find /etc/ -mindepth #   #最小搜索目录深度
```

### 对每个目录先处理目录内的文件，再处理目录本身

```bash
find /etc/ -d 
find /etc/ -depth 
#-d和-depth等价
```

### 根据文件名查找

```bash
find /etc/ -name "filename"   #默认精确查找
find /etc/ -name "*filename*" #模糊查找，支持通配符
find /etc/ -iname "*FilEnAMe*" #忽略大小写模糊查找
```

### 根据路径查找

- -path 是排除路径

```bash
find /tmp/private1/data/authority/ ! -path '/tmp/private1/data/authority/' ! -name 'torrc' ! -name 'fingerprint' ! -name 'keys'
```



### 根据节点编号(inode)查找

```bash
find / -inum 12345 #在根下查找节点编号为12345的文件
find / -samefile /etc/passwd #在根下查找和/etc/passwd节点编号相同的文件
find / -links n   #在根下查找链接数为n的文件
```

### 显示找到文件的详细信息

```bash
-ls

find / -inum 12345 -ls #注意此处的ls为find命令自带的ls，而非系统中的ls命令
```

### 使用正则表达式来查找

```bash
#在etc目录下查找conf结尾的文件：
find /etc/ -regex ".*\.conf$"

#以PATTERN匹配整个文件路径，而非文件名称
```

###  根据属主、属组查找

```bash
-user USERNAME #查找属主为指定用户(UID)的文件
-group GRPNAME #查找属组为指定组(GID)的文件
-uid UserID #查找属主为指定的UID号的文件
-gid GroupID #查找属组为指定的GID号的文件
-nouser #查找没有属主的文件
-nogroup #查找没有属组的文件
```

### 根据文件类型查找

```bash
-type TYPE

#TYPE可以是以下形式：
f #普通文件
d #目录文件
l #符号链接文件
s #套接字文件
b #块设备文件
c #字符设备文件
p #管道文件
```

范例：

```bash
#查看/home/下的目录
find /home/ -type d -ls
```

### 查找空文件或目录

```bash
-empty

find /app/ -type d -empty #查找app目录下的空目录
find /etc/ -type f -empty #查找etc目录下的空文件
```

### 组合条件(与或非)

```bash
与：-a # 默认值，并且的意思，默认两个条件组合查询就相当于省略了-a
或：-o # 或者的关系，两个或多个条件达到了都显示
非：-not，-!，！ #除了
```

细节：

```bash
[root@centos8 ~]$find /etc/ -type d -o -type f -ls | wc -l
416
[root@centos8 ~]$find /etc/ -type d -o -type f | wc -l
624
#两次结果不一样是因为-type f -ls形成了并且的关系，所以显示的都是文件

#解决方案：加上括号
[root@centos8 ~]$find /etc/ \( -type d -o -type f \) -ls | wc -l
624

#找出/tmp目录下，属主不是root，且文件名不以f开头的文件
find /tmp ( -not -user root -a -not -name 'f*' ) -ls
find /tmp -not ( -user root -o -name 'f*' ) –ls

```

### 排除目录

```bash
#查找/etc/下，除/etc/sane.d目录的其它所有.conf后缀的文件
find /etc -path '/etc/sane.d' -a -prune -o -name "*.conf"

#查找/etc/下，除/etc/sane.d和/etc/fonts两个目录的所有.conf后缀的文件
find /etc \( -path "/etc/sane.d" -o -path "/etc/fonts" \) -a -prune -o -name
"*.conf"

#排除/proc和/sys目录
find / \( -path "/sys" -o -path "/proc" \) -a -prune -o -type f -a -mmin -1
```

### 根据文件大小搜索

```bash
-size [+|-]#UNIT
 常用单位：k, M, G，c（byte）,注意大小写敏感
#UNIT: (#-1, #]
 如：6k 表示(5k-6k]
-#UNIT：[0,#-1]
 如：-6k 表示[0-5k]
+#UNIT：(#,∞)
 如：+6k 表示(6k-∞)
```

### 根据时间戳

```bash
#以“天”为单位
-atime [+|-]# 

#: [#,#+1)   #10表示10天到11天之间的内容
+#: [#+1,∞]  #+10表示11天以前的内容
-#: [0,#)    #-10表示10天以内的内容

-atime #文件读时间
-mtime #文件修改时间
-ctime #文件属性修改时间	
```

```bash
#以“分钟”为单位
-atime [+|-]# 

-amin
-mmin
-cmin
```

### 根据权限查找

```bash
-perm [/|-]MODE

MODE #精确权限匹配
/MODE #任何一类(u,g,o)对象的权限中只要能一位匹配即可，或关系，+ 从CentOS 7开始淘汰
-MODE #每一类对象都必须同时拥有指定权限，与关系
0 #表示不关注
```

说明：

fifind -perm 755 会匹配权限模式恰好是755的文件

只要当任意人有写权限时，find -perm /222就会匹配

只有当每个人都有写权限时，find -perm -222才会匹配

只有当其它人（other）有写权限时，find -perm -002才会匹配（find -perm -002 和 find -perm /002 等价）

### 处理动作

```bash
-print #默认的处理动作，显示至屏幕
-ls #类似于对查找到的文件执行“ls -l”命令
-fls file #查找到的所有文件的长格式信息保存至指定文件中，相当于 -ls > file
-delete #删除查找到的文件，慎用！,五交互式的直接删除
-ok COMMAND {} \; #对查找到的每个文件执行由COMMAND指定的命令，对于每个文件执行命令之前，都会交互式要求用户确认
-exec COMMAND {} \; #对查找到的每个文件执行由COMMAND指定的命令，非交互方式，操作时需小心！
{} #用于引用查找到的文件名称自身
```

范例：

```bash
#备份配置文件，添加.orig这个扩展名
find  -name  ".conf"  -exec  cp {} {}.orig \;

#提示删除存在时间超过３天以上所有者为joe的临时文件
find /tmp -ctime +3 -user joe -ok rm {} \;

#在家目录中寻找可被其它用户写入的文件，找到后去除other的写权限
find ~ -perm -002  -exec chmod o-w {} \;

#查找/data下的权限为644，后缀为sh的普通文件，然后增加执行权限
find /data –type f -perm 644  -name "*.sh" –exec chmod 755 {} \;
```

## 参数替换xargs

由于很多命令不支持管道|来传递参数，xargs用于	产生某个命令的参数，xargs 可以读入 stdin 的数据，并且以空格符或回车符将 stdin 的数据分隔成为参数，另外，许多命令不能接受过多参数，命令执行可能会失败，xargs 可以解决

**本质上就是把标准输出转化成命令的参数**



**注意：文件名或者是其他意义的名词内含有空格符的情况可能会出现问题**

**解决方法：**

```bash
#以字符nul分隔
find -type f -name "*.txt” -print0 | xargs -0 rm
                          #-print0 以空作为分隔符
                                          #-0 以空作为文件名 
```

**fifind 和 xargs 的组合：**

```bash
find | xargs COMMAND
```

**范例：**

```bash
#显示10个数字
seq 10 | xargs   #sargs后面什么也不加相当于隐藏了echo
1 2 3 4 5 6 7 8 9 10

#删除当前目录下的大量文件
ls | xargs   rm 

#
find  -name "*.sh" | xargs ls -Sl

#echo {1..10} |xargs 
1 2 3 4 5 6 7 8 9 10

#echo {1..10} |xargs -n1
1
2
3
4
5
6
7
8
9
10

#echo {1..10} |xargs -n2
1 2
3 4
5 6
7 8
9 10

#批量创建和删除用户
echo user{1..10} |xargs -n1 useradd 
echo user{1..100} | xargs -n1 userdel -r

#这个命令是错误的
find /sbin/ -perm /700 | ls -l       

#查找有特殊权限的文件，并排序
find /bin/ -perm /7000 | xargs ls -Sl  

#此命令和上面有何区别？答：此命令表示文件必须全部都有超级权限，而上面命令表示有一个地方有超级权限就成立
find /bin/ -perm -7000 | xargs ls -Sl 
 
#并发执行多个进程
seq 100 |xargs -i -P10 wget -P /data   http://10.0.0.8/{}.html

#并行下载视频
seq 199 | xargs -i -P3 you-get https://www.bilibili.com/video/BV1Et411E7dx?p={}
```

## 练习

1、查找/var目录下属主为root，且属组为mail的所有文件

```bash
find /var/ -user "root" -group "mail"
```

2、查找/var目录下属主不属于root、lp的所有文件

```bash
find /var/ -! \( -user "root" -o -user "lp" \)
#或者
find /var/ -! -user "root" [-a] -! -user "lp"
```

3、查找/var目录下最近一周内其内容修改过，同时属主不为root，也不是postfix的文件

```bash
find /var/ -mtime -7 ! \( -user "root" -o -user "postfix" \)
#或者
find /var  -mtime -7 -not -user "root" [-a] -not -user "postfix"
```

4、查找当前系统上没有属主或属组，且最近一个周内曾被访问过的文件

```bash
find / -atime -7 -nouser -o -nogroup
```

5、查找/etc目录下大于1M且类型为普通文件的所有文件

```bash
find /etc/ -size +1M -type f
```

6、查找/etc目录下所有用户都没有写权限的文件

```bash
find /etc/ -! -perm -222
```

7、查找/etc目录下至少有一类用户没有执行权限的文件

```bash
find /etc/ -! -perm /111
```

8、查找/etc/init.d目录下，所有用户都有执行权限，且其它用户有写权限的文件

```bash
find /etc/init.d/ -perm -111 -perm -002
#或者
find /etc/init.d/ -perm -113
```



# 打包&压缩

## 压缩文件

### gzip和gunzip

**file.gz**

```bash
#常见选项
-k #keep, 保留原文件,CentOS 8 新特性
-d #解压缩，相当于gunzip
-c #结果输出至标准输出，保留原文件不改变
-# #指定压缩比，#取值为1-9，值越大压缩比越大
```

```bash
#范例
gzip file #压缩
gzip -k file #保留源文件并压缩（CentOS 8 新特性）
gzip -c file > file.gz #保留源文件并压缩

gzip -d file.gz #解压缩
gunzip file.gz  #解压缩

zcat file.gz #不显式解压缩的前提下查看文本文件内容

cat file1 | gzip > file2.gz #把前一个命令的标准数据压缩（在数据库备份中常用）
```

### bzip2和bunzip2

**file.bz2**

```bash
#常用选项
-k keep, 保留原文件
-d 解压缩
-c 结果输出至标准输出，保留原文件不改变
-# 1-9，压缩比，默认为9
```

```bash
#范例
bzip2 file #压缩
bzip2 -k file #保留源文件并压缩


bzip2 -d file.bz2 #解压缩
bunzip2 file.bz2  #解压缩

bzcat file.bz2 #不显式解压缩的前提下查看文本文件内容

cat file1 | bzip2 > file2.bz2 #把前一个命令的标准数据压缩（在数据库备份中常用）
```

### xz和unxz

**file.xz**

```bash
#常用选项
-k #keep, 保留原文件
-d #解压缩
-c #结果输出至标准输出，保留原文件不改变
-# #压缩比，取值1-9，默认为6
```

```bash
#范例
xz file #压缩
xz -k file #保留源文件并压缩


xz -d file.bz2 #解压缩
unxz file.bz2  #解压缩

xzcat file.bz2 #不显式解压缩的前提下查看文本文件内容

cat file1 | xz > file2.xz #把前一个命令的标准数据压缩（在数据库备份中常用）
```



## 压缩比例排行榜

```ABAP
xz > bz2 > gz > zip
```

------

## tar打包和解包

- tar 即 Tape ARchive 磁带归档，可以对目录和多个文件打包一个文件，并且可以压缩，**保留文件属性不丢失(但ACL权限会丢失)**，常用于备份功能，推荐使用

### tar 选项说明

- 常用选项，- 可不写 

```bash
-f # 指定文件（要放在选项的最后面）
-v # 显示详细信息
-c # 打包 -f #指定打包过后的文件放在哪里
-t # 预览 -f #指定预览哪个文件
-x # 解包 -f #对哪个文件解包
-C # 指定解包的位置

-h # 关注符号链接；归档并转储它们指向的文件。

-z # 压缩成gz格式
-j # 压缩成bz2格式
-J # 压缩成xz格式

-P # 表示允许使用绝对路径发，否则有可能报错：tar: Removing leading `/' from member names
```

### tar 范例

```bash
#打包
tar -cvf /bak/home.tar /home #将home目录打包到/bak/下并命名成home.tar

#打包并压缩
tar -{z|j|J}cvf home.tar.{gz|bz2|xz} /home #将home目录打包并压缩到当前目录
tar -{z|j|J}cvf /data/home.tar.{gz|bz2|xz} /home #将home目录打包并压缩到指定的/data/目录下

#打包压缩时不包括目录本身
cd /home/
tar -{z|j|J}cvf home.tar.{gz|bz2|xz} *

#解包
tar -xvf home.tar #默认解包到当前所在位置
tar -xvf home.tar -C /data/ #指定解包路径/data/
#解包和压缩时，tar命令会自动识别文件的压缩格式并自动解包，但是压缩和解压缩还是需要依赖系统本身安装的压缩解压缩工具

#利用 tar 进行文件复制
tar c /data/ | tar x -C /backup
```



### --exclude 排除文件

```bash
tar zcvf /root/a.tgz --exclude=/app/host1 --exclude=/app/host2 /app

#tar打包/etc 整个目录（打包及压缩，但需要排除/etc/services 文件）
打包及压缩：tar zcvf etc.tar.gz /etc --exclude=/etc/services
```

-T 选项指定输入文件 -X 选项指定包含要排除的文件列表

```
tar zcvf mybackup.tgz -T /root/includefilelist -X /root/excludefilelist
```



## zip打包并压缩

### zip和unzip

**zip 可以实现打包目录和多个文件成一个文件并压缩，但可能会丢失文件属性信息**，如：所有者和组信

息，一般**建议使用 tar 代替**

来自于zip 和 unzip 包

**file.zip**

```bash
#范例

#打包并压缩
zip –r /backup/sysconfig.zip /etc/sysconfig/

#不包括目录本身，只打包压缩目录内的文件和子目录
cd /etc/sysconfig; zip -r /root/sysconfig.zip * 

#默认解压缩至当前目录
unzip /backup/sysconfig.zip  

#解压缩至指定目录,如果指定目录不存在，会在其父目录（必须事先存在）下自动生成
unzip /backup/sysconfig.zip  -d /tmp/config  
cat /var/log/messages | zip messages  - #-表示接接受前面的标准输入

#-p 表示管道
unzip -p message.zip   > message
```













# 用户 & 组管理

## 查看用户登录相关信息

```bash
w #显示谁远程登录了系统并且在干什么
who #显示目前谁远程登录了
last #显示最近远程登录的用户，也可以查看已经登录的用户
lastb #查看登录失败的信息

#找到失败登录的IP
awk '/Failed password/{print $(NF-3)}' /var/log/secure

#找出失败登录次数最多的前10个IP
lastb -f btmp-test1 | awk '{print $3}'|sort | uniq -c|sort -nr|head
```





## 添加 & 删除 附加组

**问题：为什么普通用户加入到root组当中还是无法获得root权限？**

- 添加

```sh
# 将jenkins用户加入到docker组，以确保其有权限运行docker命令创建容器
usermod -a -G docker jenkins
```

- 删除

```sh
# 清空 testuser1 的所有附加组
usermod -G "" testuser1
```





# 进程相关管理工具

## pstree

- 显示进程的父子关系，并以树形结构显示

### 常用选项

```bash
-p #显示PID
-T #不显示线程thread,默认显示线程
-u #显示用户切换
-H #pid 高度指定进程及其前辈进程
```

### 范例

```bash
#{}中表示线程，没有{}的即是单线程
[root@centos ~]# pstree -p
systemd(1)─┬─AliSecGuard(1216)─┬─{AliSecGuard}(1217)
           │                   ├─{AliSecGuard}(1218)
           │                   ├─{AliSecGuard}(1220)
           │                   ├─{AliSecGuard}(1222)
           │                   ├─{AliSecGuard}(1224)
           │                   └─{AliSecGuard}(189196)
           ├─sshd(1058)───sshd(252747)───sshd(252760)───bash(252761)───pstree(252852)
```



## ps

- 显示进程的各种详细信息，process state的缩写

### 常用选项

```bash
a #选项包括所有终端中的进程
x #选项包括不链接终端的进程
u #选项显示进程所有者的信息
f #选项显示进程树,相当于 --forest
k|--sort 属性 #对属性排序,属性前加 - 表示倒序
o 属性… 选项 #显示定制的信息 pid、cmd、%cpu、%mem，范例：ps axo pid,cmd,psr,ni,pri,rtprio
L #显示支持的属性列表
-C cmdlist #指定命令，多个命令用，分隔
-L #显示线程
-e #显示所有进程，相当于-A
-f #显示完整格式程序信息（进程父子关系）
-F #显示更完整格式的进程信息
-H #以进程层级格式显示进程相关信息
-u #userlist 指定有效的用户ID或名称
-U #userlist 指定真正的用户ID或名称
-g #gid或groupname 指定有效的gid或组名称
-G #gid或groupname 指定真正的gid或组名称
-p #pid 显示指pid的进程
--ppid #pid 显示属于pid的子进程
-t ttylist #指定tty,相当于 t
-M #显示SELinux信息，相当于Z
```

#### o

“ps”命令的“-o”选项可以用于根据用户需求来格式化输出。可以使用以下选项之一或多个来定义输出字段。

可以通过使用“ps L”命令来获得完整的列表，例如，“ps L o pid,ppid,%cpu,%mem,comm”。

- pid - 进程的进程ID。

- cmd - 完整的命令行。

- %cpu - 进程在所有CPU中所占用的CPU时间的百分比。

- %mem - 进程在物理内存和交换空间中所占用的百分比。

- comm - 进程的命令行名称。

- euid - 进程的有效用户ID。

- group - 进程的组ID。

- ppid - 父进程的进程ID。

- start - 进程启动时间。

- tty - 所连接的终端设备。

- uid - 进程的实际用户ID。

- args - 所有的命令行参数。

- pcpu - 进程所占用的CPU时间的百分比。

- pmem - 进程使用的物理内存和交换空间的百分比。

- rss - 进程使用的物理内存大小（单位：千字节）。

- user - 进程的有效用户名。

- psr - 处理器标识符

  - "psr"通常是指处理器标识符，是指Linux进程所绑定的物理处理器的编号。在单个物理系统中，每个物理处理器都有一个唯一的处理器号。

  - 当一个进程运行在多个逻辑处理器上时，它可能会周期性地在逻辑处理器之间迁移，以平衡负载或优化性能。但是，某些应用程序需要绑定到单个物理处理器上以获得最佳性能。这时，我们可以使用任务集程序（taskset）来指定进程应该运行的处理器编号。

  - 在Linux中，/proc/[pid]/status文件包含有关进程的信息，包括进程的当前处理器标识符（psr）。通过运行如下命令来查看一个进程的处理器标识符：

    - ```sh
      cat /proc/[pid]/status | grep "^Cpus_allowed_list:"
      ```

  - 如果该命令返回“Cpus_allowed_list: 0-3”，则表示该进程当前绑定到了处理器0、1、2和3上。



### 输出信息说明

```bash
C   #ps -ef 显示列 C 表示cpu利用率

VSZ #Virtual memory SiZe，虚拟内存集，线性内存（申请的内存）
RSS #ReSident Size, 常驻内存集（目前真正使用的内存）

STAT #进程状态
 R #running， 严格来说，应是“可运行”，即在运行队列中，处于正在执行或即将运行状态
 S #interruptable sleeping，可中断睡眠，通常是在等待某个事件的发生，如一个信号或有输入可用
 D #uninterruptable sleeping，不可中断睡眠，通常是在等待输入或输出完成
 T #stopped，通常是被shell作业控制所停止，或者进程正处于调试器的控制之下
 Z #zombie僵尸进程，通常是该进程已经死亡，但父进程没有调用wait类函数来释放该进程的资源
 + #前台进程（没有+即表示后台运行的进程）
 l #多线程进程
 L #内存分页并带锁
 N #低优先级进程，(nice)
 < #高优先级进程
 s #进程是会话期首进程，session leader，会话（子进程）发起者
 I #Idle kernel thread，CentOS 8 新特性

ni     #nice值
pri    #priority 优先级
rtprio #实时优先级
psr    #processor CPU编号 
```

### 范例

```bash
ps aux

ps -ef

#查看某一进程使用的是哪颗cpu，加上ni或nice可以查看进程的优先级
ps axo pid,cmd,psr[,ni|nice]|grep nginx

#查看进程的父子关系
ps auxf

#查看进程的特定属性
ps axo pid,cmd,%mem,%cpu

#按CPU利用率倒序排序
ps axo pid,cmd,%cpu,%mem k -%cpu

#按内存倒序排序
ps axo pid,cmd,%cpu,%mem --sort -%mem

#有效用户和实际用户
[wang@centos8 ~]#passwd
Changing password for user wang.
Current password: 
[root@centos8 ~]#ps axo pid,cmd,%cpu,%mem,user,euser,ruser | grep passwd
  1965 passwd                       0.0  1.0 root     root     wang
  1970 grep --color=auto passwd     0.0  0.1 root     root     root
  
#查询你拥有的所有进程
ps -x

#显示指定用户名(RUID)或用户ID的进程
ps -fU apache
ps -fU 48

#显示指定用户名(EUID)或用户ID的进程
ps -fu wang
ps -fu 1000

#查看以root用户权限（实际和有效ID）运行的每个进程
ps -U root -u root

#列出某个组拥有的所有进程（实际组ID：RGID或名称）
ps -fG nginx

#列出有效组名称（或会话）所拥有的所有进程
ps -fg mysql
ps -fg 27

#显示指定的进程ID对应的进程
ps -fp 1234

#以父进程ID来显示其下所有的进程，如显示父进程为1234的所有进程
ps -f --ppid 1234

#显示指定PID的多个进程
ps -fp 1204,1239,1263

#要按tty显示所属进程
ps -ft pts/0

#以进程树显示系统中的进程如何相互链接
ps -e --forest

#以进程树显示指定的进程
ps -f --forest -C sshd
ps -ef --forest | grep -v grep | grep sshd

#要显示一个进程的所有线程,将显示LWP（轻量级进程）以及NLWP（轻量级进程数）列
ps -fL -C nginx

#要列出所有格式说明符
ps L

#查看进程的PID，PPID，用户名和命令
ps -eo pid,ppid,user,cmd

#自定义格式显示文件系统组,ni值开始时间和进程的时间

ps -p 1234 -o pid,ppid,fgroup,ni,lstart,etime

#使用其PID查找进程名称：
ps -p 1244 -o comm= #要以其名称选择特定进程，显示其所有子进程
ps -C sshd,bash

#查找指定进程名所有的所属PID，在编写需要从std输出或文件读取PID的脚本时这个参数很有用
ps -C httpd,sshd -o pid= #检查一个进程的执行时间
ps -eo comm,etime,user | grep nginx

#排序，查找占用最多内存和CPU的进程
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem | head
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%cpu | head

#显示安全信息
ps -eM
ps --context

#使用以下命令以用户定义的格式显示安全信息
ps -eo euser,ruser,suser,fuser,f,comm,label

#使用watch实用程序执行重复的输出以实现对就程进行实时的监视，如下面的命令显示每秒钟的监视
watch -n 1 'ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem | head'

#查看优先级和CPU绑定关系
[root@centos8 ~]#ps axo pid,cmd,ni,pri,psr,rtprio |grep migration
   11 [migration/0]                 - 139   0     99
   16 [migration/1]                 - 139   1     99
 2246 grep --color=auto migration   0 19   0     -
[root@centos8 ~]#ps axo pid,cmd,ni,pri,psr |grep dd
     2 [kthreadd]                   0 19   1
   138 [ipv6_addrconf]             -20 39   0
 2153 dd if=/dev/zero of=/dev/nul 19   0   0
 2228 grep --color=auto dd         0 19   1

#实现进程和CPU的绑定
[root@centos8 ~]#taskset --help
Usage: taskset [options] [mask | cpu-list] [pid|cmd [args...]]
```





## prtstat

- **显示单个进程的详细信息**
- 来自于psmisc包

### 范例

```bash
prtstat PID

prtstat -r PID #整齐显示
```



## nice | renice

- **设置和调整进程优先级**

- 静态优先级：100-139（nice值对应 -20~19）
- 进程默认启动时的nice值为0，对应静态优先级为120
- 只有根用户才能降低nice值（提高优先性）
- **nice值越低表示进程优先级越高**

### nice

- **以指定的优先级来启动进程**

### renice

- **可以调整正在执行中的进程的优先级**

### 范例

```bash
#以指定的优先级来启动进程
[root@centos8 ~]#nice -n -10 ping 127.0.0.1
[root@centos8 ~]#ps axo pid,cmd,nice |grep ping
  2118 ping 127.0.0.1              -10
  2120 grep --color=auto ping        0

#调整正在执行中的进程的优先级
[root@centos8 ~]#renice -n -20 2118
2106 (process ID) old priority -10, new priority -20
[root@centos8 ~]#ps axo pid,cmd,nice |grep ping
  2118 ping 127.0.0.1              -20
  2200 grep --color=auto ping        0
```



## pgrep

- **按条件搜索进程**
- 也可以使用 ps  | grep 'pattern'  代替

### 常用选项

```bash
-u uid        #effective user，生效者
-U uid        #real user，真正发起运行命令者
-t terminal   #与指定终端相关的进程
-l            #显示进程名
-a            #显示完整格式的进程名
-P pid        #显示指定进程的子进程
```

### 范例

```bash
[root@centos8 ~]#pgrep -u wang
2303
2330

[root@centos8 ~]#pgrep -lu wang
2303 bash
2330 dd

#错误写法
[root@centos8 ~]#pgrep -ul wang
pgrep: invalid user name: l

[root@centos8 ~]#pgrep -au wang
2303 -bash
2330 dd if=/dev/zero of=/dev/null

[root@centos8 ~]#pgrep -aP 2303
2330 dd if=/dev/zero of=/dev/null

[root@centos8 ~]#pgrep -at pts/2
1482 -bash
2302 su - wang
2303 -bash
2330 dd if=/dev/zero of=/dev/null
```



## pidof

- **按照进程名称 来查看进程所使用的PID**

### 范例

```bash
[root@centos ~]# pidof openvpn
1063

[root@centos8 ~]#pidof bash
19035 18813 18789 1251

#-x 按脚本名称查找pid
[root@centos8 ~]#pidof ping.sh
[root@centos8 ~]#pidof -x ping.sh
19035
```



## uptime | w

- **负载查询，uptime 和 w 命令都可以查询**
- 信息来自 /proc/uptime

**/proc/uptime 包括两个值，单位 s**

- 系统启动时长

- 空闲进程的总时长（按总的CPU核数计算）

**uptime 和 w 显示以下内容**

- 当前时间

- 系统已启动的时间

- 当前上线人数

- 系统平均负载（1、5、15分钟的平均负载，一般不会超过1，超过5时建议警报）

**系统平均负载:**

- 指在特定时间间隔内运行队列中的平均进程数,通常每个CPU内核的当前活动进程数不大于3，那么系统的性能良好。如果每个CPU内核的任务数大于5，那么此主机的性能有严重问题
- 如：linux主机是1个双核CPU，当Load Average 为6的时候说明机器已经被充分使用

### 范例

```bash
[root@8 ~]# uptime 
 14:32:37 up  2:32,  6 users,  load average: 0.00, 0.00, 0.03
[root@8 ~]# w
 14:32:38 up  2:32,  6 users,  load average: 0.00, 0.00, 0.03
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/1    10.0.0.1         06Jul21 166days  0.05s  0.05s -bash
root     pts/2    10.0.0.1         30Aug21 112days  0.06s  0.06s -bash
root     pts/3    10.0.0.1         08Sep21 103days  0.04s  0.04s -bash
root     pts/4    10.0.0.1         10Sep21 101days  0.03s  0.03s -bash
root     pts/5    10.0.0.1         12:33    3.00s  0.18s  0.00s w
root     pts/6    10.0.0.1         12:33   13:42   0.05s  0.05s -bash
```



## mpstat

- **显示CPU相关统计**
- 来自于sysstat包

### 范例

```bash
[root@centos8 ~]#yum install -y sysstat
[root@centos8 ~]#mpstat
Linux 4.18.0-80.el8.x86_64 (centos8.localdomain) 01/09/2020 _x86_64_ (4 
CPU)
10:16:43 AM CPU   %usr   %nice   %sys %iowait   %irq   %soft %steal %guest 
%gnice   %idle
10:16:43 AM all    0.01    0.00    0.03    0.00    0.01    0.01    0.00    0.00 
   0.00   99.93
[root@centos8 ~]#mpstat 1 3
Linux 4.18.0-80.el8.x86_64 (centos8.localdomain) 01/09/2020 _x86_64_ (4 
CPU)
10:16:48 AM CPU   %usr   %nice   %sys %iowait   %irq   %soft %steal %guest 
%gnice   %idle
10:16:49 AM all    0.00    0.00    0.25    0.00    0.00    0.00    0.00    0.00 
   0.00   99.75
10:16:50 AM all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00 
   0.00  100.00
10:16:51 AM all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00 
   0.00  100.00
Average:     all    0.00    0.00    0.08    0.00    0.00    0.00    0.00    0.00 
   0.00   99.92
```



## top

- **查看进程的实时状态**

### 常用选项

```sh
-d #指定刷新时间间隔，默认为3秒
-b #全部显示所有进程
-n #刷新多少次后退出
-H #线程模式
-p #指定PID

#范例
top -H -p `pidof mysqld`
```

### 常用子命令

```bash
h | ?   #帮助
q | esc #退出
s #修改刷新时间间隔
k #终止指定进程
W #保存文件
b #打开关闭加亮
y #横向加量
x #纵向加亮，shift+>|< 可以实现切换加量的列
f #选择显示的类目，d或者空格实现是否选择

#排序：
P #以占据的CPU百分比,%CPU
M #占据内存百分比,%MEM，根据驻留内存大小进行排序
T #累积占据CPU时长,TIME+

#首部信息显示：
l #uptime信息
t #tasks及cpu信息
1 #cpu分别显示，监控每个逻辑CPU的状况
m #memory信息
```

### 输出说明

```bash
#第1行：top - 17:29:09 up 53days, 1 users, load average: 0.00, 0.01, 0.05 
#系统简要信息
top - 17:29:09  当前系统时间
up 53days       系统运行时间
1 users         在线用户数量
load average: 0.00, 0.01, 0.05   #CPU负载情况，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值
# load average 表示的是CPU的负载,包含的信息不是CPU的使用率状况,而是在一段时间内CPU正在处理以及等待CPU处理的进程数之和的统计信息,也就是CPU使用队列的长度的统计信息


#第2行：Tasks: 69 total, 2 running, 67 sleeping, 0 stopped, 0 zombie
#进程相关信息
69 total     进程总数
2 running    正在运行的进程数
158 sleeping 睡眠的进程数
0 stopped    停止的进程数
0 zombie     僵尸进程数


#第3行：%Cpu(s): 0.0 us, 0.0 sy, 0.0 ni, 100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st 
#CPU使用信息，当有多个CPU时，这些内容可能会超过两行，其参数如下：

0.0 us    用户空间占用CPU百分比
0.0 sy    内核空间占用CPU百分比
0.0 ni    用户进程空间内改变过优先级的进程占用CPU百分比（调整nice时间）
100.0 id  空闲CPU百分比
0.0 wa    等待输入输出的CPU时间百分比
0.0 hi    硬中断（Hardware IRQ）占用CPU的百分比
0.0 si    软中断（Software Interrupts）占用CPU的百分比
0.0 st    用于有虚拟cpu的情况，用来指示被虚拟机偷掉的cpu时间。


#第4行：KiB Mem: 1016168 total, 68820used, 567720 free, 379628 buffers
#物理内存的使用情况
1016168 total 物理内存总量
68820  used 使用的物理内存总量
567720 free 空闲内存总量
379628 buffers 用作内核缓存的内存量


#第5行：KiB Swap: 0 total, 0 free ,0 used, 293196 avail Mem 
#swap交换内存的使用情况
0 total 交换区总量
0 used  使用的交换区总量
0 free  空闲交换区总量
0 cached Mem 缓冲的交换区总量
293196 avail Mem  代表可用于进程下一次分配的物理内存数量


#5行以下
PID   #进程ID
PPID  #父进程ID
RUSER #Real user name
UID   #进程所有者的用户id
USER  #进程所有者的用户名
GROUP #进程所有者的组名
TTY   #启动进程的终端名。不是从终端启动的进程则显示为...
PR    #优先级
NI    #nice值。负值表示高优先级，正值表示低优先级
%CPU  #上次更新到现在的CPU时间占用百分比
TIME  #进程使用的CPU时间总计，单位秒
TIME+ #进程使用的CPU时间总计，单位1/100秒
%MEM  #进程使用的物理内存百分比
VIRT  #进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
SWAP  #进程使用的虚拟内存中，被换出的大小，单位kb 
RES   #进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
CODE  #可执行代码占用的物理内存大小，单位kb
DATA  #可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb
SHR   #共享内存大小，单位kb
nFLT  #页面错误次数
nDRT  #最后一次写入到现在，被修改过的页面数
S     #进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程
COMMAND #命令名/命令行
WCHAN #若该进程在睡眠，则显示睡眠中的系统函数名
Flags #任务标志
```



## htop

- 增强版的TOP命令，来自EPEL源，比top功能更强

### 常用选项

```bash
-d          #指定延迟时间；
-u UserName #仅显示指定用户的进程
-s COLUME   #以指定字段进行排序
```

### 常用子命令

```bash
s #跟踪选定进程的系统调用
l #显示选定进程打开的文件列表
a #将选定的进程绑定至某指定CPU核心
t #显示进程树
q #退出
```



## free

- **以显示内存空间使用状态**

### 常用选项

```bash
-b   #以字节为单位
-m   #以MB为单位
-g   #以GB为单位
-h   #易读格式
-o   #不显示-/+buffers/cache行
-t   #显示RAM + swap的总和
-s n #刷新间隔为n秒
-c n #刷新n次后即退出
```

### 范例

```bash
[root@centos8 ~]#free -h
             total       used       free     shared buff/cache   available
Mem:          1.8Gi       355Mi       724Mi       9.0Mi       726Mi       1.2Gi
Swap:         2.0Gi         0B       2.0Gi

#清除buff/cache，生产中不要使用，因为buff/cache是可以提高效率的，并且改成3后将改不回默认值0了 除非重启
[root@centos8 ~]#echo 3 > /proc/sys/vm/drop_caches
[root@centos8 ~]#free -h
             total       used       free     shared buff/cache   available
Mem:          1.8Gi       320Mi       1.3Gi       9.0Mi       152Mi       1.3Gi
Swap:         2.0Gi         0B       2.0Gi
```



## pmap

- **显示进程对应的内存映射**

### 格式

```bash
pmap [options] pid [...]
```

### 常用选项

```
-x #显示详细格式的信息
```

### 范例

```bash
[root@centos ~]# pmap -x 1063
1063:   /usr/sbin/openvpn --status /run/openvpn-server/status-multi-user.log --status-version 2 --suppress-timestamps --cipher AES-256-GCM --ncp-ciphers AES-256-GCM:AES-128-GCM:AES-256-CBC:AES-128-CBC:BF-CBC --config server.conf
Address           Kbytes     RSS   Dirty Mode  Mapping
0000558776fe3000     760     692       0 r-x-- openvpn
00005587772a1000       8       8       8 r---- openvpn
00005587772a3000       4       4       4 rw--- openvpn
00005587772a4000      32       8       8 rw---   [ anon ]
0000558778414000     912     812     812 rw---   [ anon ]
...

#实际上就是查看/proc目录下的信息：
[root@centos ~]# cat /proc/1063/maps
558776fe3000-5587770a1000 r-xp 00000000 fd:01 51250240                   /usr/sbin/openvpn
5587772a1000-5587772a3000 r--p 000be000 fd:01 51250240                   /usr/sbin/openvpn
5587772a3000-5587772a4000 rw-p 000c0000 fd:01 51250240                   /usr/sbin/openvpn
5587772a4000-5587772ac000 rw-p 00000000 00:00 0 
558778414000-5587784f8000 rw-p 00000000 00:00 0                          [heap]
7efe5902e000-7efe59902000 r--s 00000000 fd:01 17414516                   /var/lib/sss/mc/passwd (deleted)
7efe59902000-7efe59fa1000 r--s 00000000 fd:01 17414350                   /var/lib/sss/mc/group (deleted)
7efe59fa1000-7efe59fab000 r-xp 00000000 fd:01 50990966                   /usr/lib64/libnss_sss.so.2
...
```







## lsof

- **查看进程打开的文件**

### 常用选项

```bash
-a        #列出打开文件存在的进程
-c<进程名> #列出指定进程所打开的文件
-g        #列出GID号进程详情
-d<文件号> #列出占用该文件号的进程
+d<目录>   #列出目录下被打开的文件
+D<目录>   #递归列出目录下被打开的文件
-n<目录>   #列出使用NFS的文件
-i<条件>   #列出符合条件的进程(4、6、协议、:端口、 @ip )
-p<进程号> #列出指定进程号所打开的文件
-u        #列出UID号进程详情
-h        #显示帮助信息
-v        #显示版本信息。
-n        #不反向解析网络名字
```

### 范例

```bash
#查看由登陆用户启动而非系统启动的进程
lsof /dev/pts/1

#指定进程号，可以查看该进程打开的文件
lsof -p 1063

#命令调命令
lsof -p `pidof bc`

#查看指定程序打开的文件
lsof -c httpd

#查看指定用户打开的文件
lsof -u root | more 

#查看指定目录下被打开的文件，参数+D为递归列出目录下被打开的文件，参数+d为列出目录下被打开的文件
lsof +D /var/log/ 
lsof +d /var/log/ 
 
#查看所有网络连接，通过参数-i查看网络连接的情况，包括连接的ip、端口等以及一些服务的连接情况，例如：sshd等。也可以通过指定ip查看该ip的网络连接情况
lsof -i –n      
lsof -i@127.0.0.1 
 
#查看端口连接情况，通过参数-i:端口可以查看端口的占用情况，-i参数还有查看协议，ip的连接情况等
lsof -i :80 -n
 
#查看指定进程打开的网络连接，参数-i、-a、-p等，-i查看网络连接情况，-a查看存在的进程，-p指定进
程
lsof -i –n -a -p 9527
 
#查看指定状态的网络连接，-n:no host names, -P:no port names,-i TCP指定协议，-s指定协议
状态通过多个参数可以清晰的查看网络连接情况、协议连接情况等
lsof -n -P -i TCP -s TCP:ESTABLISHED
```

### 利用 lsof 恢复正在使用中的误删除的文件

```bash
lsof |grep /var/log/messages
rm -f /var/log/messages
lsof |grep /var/log/messages
cat /proc/653/fd/6
cat /proc/653/fd/6 > /var/log/messages
```



```bash
lsof -i :portnumber   # 显示正在使用的端口以及对应的进程

lsof | grep file # 查找某一文件被哪个进程打开
```





## trap

- **捕获信号，显示当前系统可用信号**

```bash
# 显示当前系统可用信号
trap -l
```



## kill

- **给进程发送信号，显示当前系统可用信号**

### 范例

```bash
# 给某个进程发送9信号
kill -9 PID

# 显示当前系统可用信号
kill -l
```



## killall

- **按程序名称给进程发送信号**

### 范例

```sh
# 把所有的登录后的shell给杀掉
killall -9 bash
```





# 系统调用

## strace

- **查看系统调用**
- 来自 strace 包

### 范例

```bash
[root@centos ~]# strace ls
execve("/usr/bin/ls", ["ls"], 0x7fff4367ab40 /* 23 vars */) = 0
brk(NULL)                               = 0x55e4a4015000
arch_prctl(0x3001 /* ARCH_??? */, 0x7ffef1d16dc0) = -1 EINVAL (Invalid argument)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=31487, ...}) = 0
mmap(NULL, 31487, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f41287c5000
...
```



## ltrace

- **查看库调用**
- 来自 ltrace 包

### 范例

```bash
[root@centos ~]# ltrace ls
strrchr("ls", '/')                                                      = nil
setlocale(LC_ALL, "")                                                   = "en_US.UTF-8"
bindtextdomain("coreutils", "/usr/share/locale")                        = "/usr/share/locale"
textdomain("coreutils")                                                 = "coreutils"
__cxa_atexit(0x5598345ee650, 0, 0x559834800f80, 0)                      = 0
...
```



## modprobe

- 加载或卸载网卡驱动

```bash
modprobe -r 驱动名 # 卸载网卡驱动，网卡驱动可以通过ethtool -i 网卡名 来查看，driver 表示驱动名
modprobe 驱动名 # 加载网卡驱动
```

`modprobe`是一个用于加载Linux内核模块的命令行工具。在Linux系统中，内核模块是一种可加载的、独立编译的二进制文件，它们可以动态地添加到内核中或从内核中移除，以扩展或改变内核的功能。

以下是`modprobe`命令的详解：

**语法：**

```
modprobe [options] module_name
```

**参数：**

- `options`：可选参数，用于指定各种选项。
- `module_name`：要加载或移除的内核模块的名称。

**常用选项：**

- `-r` 或 `--remove`：从内核中移除指定的模块。
- `-l` 或 `--list`：列出当前已加载的所有模块。
- `-a` 或 `--all`：加载指定模块的所有依赖模块。
- `-v` 或 `--verbose`：显示详细的加载信息。
- `-c` 或 `--showconfig`：显示模块的配置文件路径。
- `-d` 或 `--dirname`：指定模块所在的目录。
- `-n` 或 `--ignore-install`：在配置文件中禁用"install"命令。
- `-D` 或 `--nodepmod`：不使用depmod命令更新依赖关系数据库。

**使用示例：**

1. 加载一个模块：

   ```
   modprobe module_name
   ```

2. 加载一个模块并显示详细信息：

   ```
   modprobe -v module_name
   ```

3. 从内核中移除一个模块：

   ```
   modprobe -r module_name
   ```

4. 列出当前已加载的所有模块：

   ```
   modprobe -l
   ```

5. 加载指定模块的所有依赖模块：

   ```
   modprobe -a module_name
   ```

6. 显示模块的配置文件路径：

   ```
   modprobe -c module_name
   ```

**注意事项：**

- 使用`modprobe`加载或移除模块通常需要管理员权限，因为这涉及到对内核的修改。
- 加载的模块会留在内核中，直到系统重启或手动卸载。
- 模块的配置文件通常存储在`/etc/modprobe.d/`目录下，文件名以`.conf`结尾。这些文件可以包含一些选项，以便在加载模块时自动设置参数。
- 有些模块可能需要其他模块的支持，因此在加载某个模块时，可能会自动加载它所依赖的模块。这些依赖关系通常由`depmod`命令管理。

请注意，`modprobe`命令在不同的Linux发行版中可能略有不同，因此建议查阅相关发行版的文档以获取更准确的信息和用法。



# 共享库管理

## ldd

`ldd` 是一个用于 Linux 的命令，用于显示一个可执行文件或共享库所依赖的共享库。`ldd` 是 "List Dynamic Dependencies"（列出动态依赖项）的缩写。当你运行 `ldd` 命令，后跟可执行文件或共享库的名称，它会显示该二进制文件所依赖的共享库列表。

`ldd` 命令的一般语法如下：

```
ldd <可执行文件或共享库>
```

以下是输出的解释：

1. **linux-vdso.so.xx**：这是一个虚拟的动态共享对象，由内核提供。它允许应用程序直接进行某些系统调用，而无需切换到内核模式。这里的 `xx` 表示版本号。
2. **libc.so.xx**：这是程序使用的 C 库（libc），包含了 C 编程语言的基本函数和系统调用。
3. **libxxx.so.xx**：这一行表示该二进制文件依赖的其他共享库，其中 `libxxx` 是库的名称，`xx` 是版本号。
4. **not found**：如果系统中缺少该二进制文件所需的共享库，`ldd` 将在缺失的库旁边显示此消息。

`ldd` 命令有助于诊断由于缺少或不兼容的库导致可执行文件或共享库无法正确运行的问题。

请注意，如果该二进制文件是静态链接的（即所有所需的库都包含在可执行文件中），则 `ldd` 不会显示任何输出，因为在这种情况下没有动态依赖项。



## ldconfig

`ldconfig` 是 Linux 系统中的一个命令，用于更新共享库的缓存信息。在 Linux 上，共享库是可重用的代码片段，被多个程序共享使用。`ldconfig` 命令会扫描共享库的目录，并创建或更新一个索引缓存文件，以加快共享库的加载和链接过程。

通常情况下，当你安装新的共享库或更新已有的共享库时，你需要运行 `ldconfig` 命令，以使系统能够识别并正确链接这些库。

`ldconfig` 命令一般需要以超级用户（root）身份执行，因为它需要访问系统的共享库目录和更新缓存文件。执行的方式如下：

```
sudo ldconfig
```

运行 `ldconfig` 命令后，它会搜索以下默认的共享库目录：

1. `/lib`
2. `/usr/lib`
3. `/usr/local/lib`

然后，它将根据目录中的共享库文件创建一个索引，并将其写入缓存文件 `/etc/ld.so.cache`。这样，当你运行程序时，系统会优先从缓存文件中查找共享库，加快链接过程。

总结起来，`ldconfig` 命令的作用是更新共享库的缓存信息，使新安装或更新的共享库能够被系统正确加载和链接。



# 压测

ab命令是Linux系统中的一个工具，它可以用于对Apache HTTP服务器进行基准测试。它可以模拟多个并发用户访问同一个页面，并以此来测试服务器的性能、稳定性和负载能力。

ab命令的常用语法如下：

```
ab [options] [http[s]://]hostname[:port]/path
```

其中，可用的选项包括：

- -n requests：指定总的请求数。例如，“-n 1000”表示用1000个请求进行测试。
- -c concurrency：指定并发请求数。例如，“-c 10”表示10个并发请求。
- -t timelimit：指定测试的最大时间。例如，“-t 60”表示60秒后停止测试。
- -p POST-file：指定用于POST请求的文件。
- -T content-type：指定POST请求的内容类型头。

除此之外，还有其他选项可用。

下面是一个使用ab命令测试网站性能的例子：

```
ab -n 1000 -c 10 https://www.example.com/
```

这个例子将发送1000个请求，并使用10个并发请求来访问www.example.com。ab命令将输出包括各种性能指标在内的详细结果。

ab命令是一种非常实用的基准测试工具，它可以测试Web服务器的负载性能和处理能力。但请注意，基准测试是一种破坏性活动，因此在生产环境中请谨慎使用，以免对服务产生负面影响。



## stress

- stress是Linux系统下的系统压力测试工具，可以测试Linux系统的CPU、内存、磁盘I/O等的负载。
  - 当stress测试CPU时，会不断调用进程，计算随机数的平方根；
  - 当测试内存时，会不断调用内存调用malloc和内存释放free函数；
  - 当测试磁盘I/O时，会不断调用sync()中断，以测试磁盘I/O。

**安装**

```sh
# Centos，来自epel源
# yum -y install stress
```

**选项说明**

- `stress [OPTION [ARG]] ...`
- 注：数字的后缀可以是s、m、h、d、y（时间）或B、K、M、G（大小）。

```sh
 -?, --help         show this help statement
     --version      show version statement
 -v, --verbose      # 运行时显示详细的信息
 -q, --quiet        # 运行时不显示运行信息
 -n, --dry-run      # 显示以完成的指令情况
 -t, --timeout N    # 指定程序运行结束的时间，单位为秒，不指定结束时间则会一直运行
     --backoff N    # 指定程序开始运行的时间，单位为微妙
 -c, --cpu N        # 后面跟一个整数，表示测试CPU的进程数，每个进程都反复不停的计算随机数的平方根
 -i, --io N         # 后面跟一个整数，表示测试磁盘I/O的进程数，每个进程反复调用 sync() 将内存上的内容写到硬盘上
 -m, --vm N         # 后面跟一个整数，表示测试内存的进程数，每个进程不断分配和释放内存
     --vm-bytes B   # 指定在内存测试时malloc的字节数，默认256M
     --vm-stride B  # 指定每B个字节移动一个字节
     --vm-hang N    # 指定free栈的秒数
     --vm-keep      # 向内存空间内不断写入，而不是释放和重新分配
 -d, --hdd N        # 产生执行write和unlink函数的进程数
     --hdd-bytes B  # 指定写的字节数
```

**范例**

[(337条消息) Linux系统压力测试工具stress_rayylee的博客-CSDN博客_linux压力测试工具](https://blog.csdn.net/hbuxiaofei/article/details/125731795?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-125731795-blog-103495148.pc_relevant_3mothn_strategy_recovery&spm=1001.2101.3001.4242.2&utm_relevant_index=3)

- 测试CPU

```sh
# 生成2个进程来测试CPU，持续100秒
# stress -c 2 -t 100s


# top
top - 09:46:25 up  4:31,  8 users,  load average: 2.03, 0.77, 0.32
Tasks: 138 total,   5 running, 133 sleeping,   0 stopped,   0 zombie
%Cpu0  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu1  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
...
```



## speedtest-cli

speedtest-cli 是一个命令行工具，基于 Speedtest.net 提供的服务。它可以测量网络的上传和下载速度。你可以通过在终端中运行命令来安装并使用它：

[Speedtest CLI: Internet speed test for the command line](https://www.speedtest.net/apps/cli)

以下是 speedtest-cli 的使用详解：

1. 安装 speedtest-cli：在终端中执行以下命令来安装 speedtest-cli：

   ```
   pip install speedtest-cli
   ```

   如果你的系统没有安装 pip，你需要先安装 pip。根据你的 Linux 发行版，使用适当的包管理工具进行安装。

2. 运行速度测试：在终端中执行以下命令来运行速度测试：

   ```
   speedtest-cli
   ```

   speedtest-cli 将连接到最近的 Speedtest.net 服务器，并进行上传和下载速度测试。测试完成后，将显示测试结果，包括上传速度、下载速度、延迟（ping）等信息。

   如果你希望测试特定类型的连接（如仅测试上传或仅测试下载），可以使用以下选项：

   - 仅测试上传速度：`speedtest-cli --no-download`
   - 仅测试下载速度：`speedtest-cli --no-upload`

   这些选项可以根据需要进行组合使用。

3. 指定服务器进行测试：如果你希望连接到特定的 Speedtest.net 服务器进行测试，可以使用 `-s` 或 `--server` 选项，并指定服务器的 ID。可以通过 `speedtest-cli --list` 命令列出可用服务器的列表及其对应的 ID，然后使用服务器的 ID 进行测试。例如：

   ```
   speedtest-cli --server 1234
   ```

   将 `1234` 替换为你要使用的服务器的 ID。

请注意，运行速度测试可能会占用一定的带宽和资源。在进行测试时，确保你的网络连接稳定，避免其他网络活动干扰测试结果。



**41.41 Mbit/s 实际是多少**

41.41 Mbit/s 表示每秒传输的数据量为 41.41 兆比特（Megabits）。如果你想将其转换为其他常用的数据单位，可以使用以下转换：

1. 转换为兆字节（Megabytes）：将 Megabits 除以 8，并再除以 1024，得到结果以兆字节为单位。

   ```
   41.41 Mbit/s = (41.41 / 8) / 1024 = 5.17625 MB/s
   ```

   四舍五入到合适的小数位数，结果为约 5.18 兆字节每秒（Megabytes per second）。

2. 转换为千兆字节（Gigabytes）：将 Megabits 除以 8，并再除以 1024 的平方，得到结果以千兆字节为单位。

   ```
   41.41 Mbit/s = (41.41 / 8) / (1024 * 1024) = 0.0049375 GB/s
   ```

   四舍五入到合适的小数位数，结果为约 0.00494 千兆字节每秒（Gigabytes per second）。

请根据你的需求和上下文，选择适当的数据单位进行转换和使用。



## iperf

iperf 是一个广泛使用的网络性能测试工具，可用于测量网络带宽和性能。它可以在客户端和服务器之间进行测试，并提供详细的报告和统计信息。

iperf 是一个网络性能测试工具，用于测量网络带宽和吞吐量。它可以用于评估网络连接的性能，并进行网络故障排除。

以下是使用 iperf 进行网络性能测试的详细步骤：

1. 安装 iperf：在终端中执行适合你的系统的命令来安装 iperf。例如，对于 Ubuntu 系统，可以执行以下命令来安装 iperf：

   ```
   sudo apt-get install iperf
   ```

2. 启动 iperf 服务器端：在一个计算机上作为服务器，执行以下命令来启动 iperf 服务器端：

   ```
   iperf -s
   ```

   服务器将监听默认的端口 5001，并等待客户端连接。

3. 运行 iperf 客户端进行测试：在另一台计算机上作为客户端，执行以下命令来运行 iperf 客户端并发起测试连接到服务器：

   ```
   iperf -c <server-ip>
   ```

   将 `<server-ip>` 替换为 iperf 服务器的 IP 地址或主机名。

   iperf 将与服务器建立连接并进行性能测试。测试完成后，将显示相关的测试结果，包括带宽、延迟、丢包等信息。

iperf 还提供了许多选项和参数，以便更精确地配置和控制测试。你可以使用 `iperf --help` 命令查看完整的帮助文档，了解可用的选项和参数。

请注意，在进行网络性能测试时，确保网络连接稳定，并避免其他网络活动干扰测试结果。另外，如果你在公共网络环境中进行测试，请遵守相关的网络使用政策和规定。

# systemd

## journalctl

`journalctl`是一个用于访问系统日志的命令行工具，它可以用于检查和分析系统日志信息。

`journalctl`是`systemd`日志管理工具之一，用于访问和查询`systemd`生成的系统日志。

- `systemd`是一种现代的系统和服务管理器，广泛用于许多Linux发行版中。它负责启动和停止系统中的各种服务和进程，并提供了对系统状态、单元（units）管理和日志记录的强大支持。
- 在`systemd`中，所有日志消息都由`systemd-journald`守护进程收集和存储。`systemd-journald`将日志消息存储在二进制格式的日志文件中，而不是传统的文本日志文件。这种二进制格式的日志称为"Journal"，并且可以被`journalctl`工具用来查看、分析和查询。
- 因此，`journalctl`命令是与`systemd-journald`一起提供的工具，用于访问、检索和分析`systemd`生成的日志。通过`journalctl`命令，可以按时间范围、服务名称、优先级等过滤日志，并以各种格式进行显示和输出。
- 总结来说，`journalctl`是`systemd`中用于访问和操作`systemd-journald`生成的系统日志的命令行工具。



### 常用选项

```sh
-u, --unit=UNIT # 按服务名称过滤日志，只显示指定服务的日志

-f, --follow # 实时跟踪日志，持续输出新的日志条目。

-x # 显示更多的错误信息

-e # 显示日志的末尾，即从最新的日志条目开始显示。（否则默认从头打印）
```

### 其他选项

```sh


-p, --priority=PRIORITY # 按优先级过滤日志，只显示指定优先级的日志。可选的优先级包括：emerg(紧急)、alert(警报)、crit(严重)、err(错误)、warning(警告)、notice(注意)、info(信息)、debug(调试)。

-k, --dmesg # 显示内核环缓冲区（dmesg）的日志。

--since=DATE # 仅显示指定日期（含）之后的日志。日期的格式可以是"YYYY-MM-DD"或"YYYY-MM-DD HH:MM:SS"。

--until=DATE # 仅显示指定日期（含）之前的日志。日期的格式可以是"YYYY-MM-DD"或"YYYY-MM-DD HH:MM:SS"。

-n, --lines=NUM # 仅显示指定行数的日志。


-o, --output=FORMAT # 指定输出的格式。常用的格式包括"short"（简短格式）、"short-iso"（简短ISO格式）、"short-precise"（精确简短格式）、"verbose"（详细格式）、"json"（JSON格式）等。

-r, --reverse # 反向显示日志，从最新的日志开始向前显示。

--no-pager # 禁用分页显示，直接将日志输出到终端。

-o, --output-fields=FIELDS # 指定要显示的字段。可以使用逗号分隔的字段列表，例如"_SYSTEMD_UNIT,_PID,_COMM,_MESSAGE"。

-a, --all # 显示所有日志条目，包括被裁剪的日志。
```



### 范例

下面是`journalctl`命令的一些常见用法和选项的详解：

1. 查看所有日志：使用`journalctl`命令可以列出所有可用的系统日志信息。默认情况下，它会显示最新的日志条目，并在不断滚动显示新日志。你可以按下"Ctrl + C"来停止滚动。
2. 按页查看日志：可以通过`journalctl | less`命令按页查看日志。这样可以方便地浏览日志并使用"Page Up"和"Page Down"键来滚动。
3. 按时间范围过滤：使用`-u`选项加上服务名称，可以仅显示特定服务的日志。例如，`journalctl -u sshd`将只显示与SSH服务相关的日志。
4. 按优先级过滤：可以使用`-p`选项加上优先级代码来过滤日志。例如，`journalctl -p err`将只显示错误级别（Error）的日志。
5. 按用户过滤：可以使用`-u`选项加上用户名来过滤显示与该用户相关的日志。例如，`journalctl -u username`将只显示该用户的日志。
6. 查看引导日志：使用`-b`选项可以查看引导（boot）时的日志。例如，`journalctl -b`将显示当前引导周期的日志。
7. 实时日志监视：使用`-f`选项可以实时监视新的日志条目的产生。它会持续输出新的日志，直到你按下"Ctrl + C"停止。
8. 格式化输出：使用`-o`选项可以指定输出的格式。一些常用的格式包括`short`（简短格式）、`verbose`（详细格式）、`json`（JSON格式）等。
9. 查看特定时间范围的日志：可以使用`--since`和`--until`选项来指定时间范围。例如，`journalctl --since "2023-06-01" --until "2023-06-10"`将只显示6月1日到6月10日之间的日志。

这些只是`journalctl`命令的一些常见用法和选项。你可以通过运行`man journalctl`命令来查看完整的命令帮助手册，其中包含了更详细的信息和更多的选项。

**journalctl 如何查看指定某 systemctl 管理的进程的日志？**

要查看特定由`systemctl`管理的进程的日志，可以使用`journalctl`命令的`-u`选项，后跟要查看的服务名称。以下是具体的步骤：

1. 首先，确定你要查看日志的服务名称。你可以使用`systemctl`命令来列出正在运行的服务和其状态。例如，使用以下命令列出所有正在运行的服务：

   ```
   systemctl list-units --type=service --state=running
   ```

   在输出中找到你感兴趣的服务的名称。

2. 使用`journalctl`命令来查看特定服务的日志。使用`-u`选项，后跟服务名称。例如，要查看`sshd`服务的日志，使用以下命令：

   ```
   journalctl -u sshd
   ```

   这将显示与`sshd`服务相关的所有日志条目。

你还可以结合其他`journalctl`选项来进一步过滤和限制日志的显示，例如按时间范围、按优先级、按用户等进行过滤。请参考前面提到的`journalctl`命令详解，以获取更多用法和选项的信息。







# 文本处理

## jq

- 将json输出转为yaml格式

```bash
kubectl get --raw /api/v1/namespace/xxx | jq .

kubectl get --raw /api/v1/namespace/xxx | jq .kind
```



## seq

```bash
seq -s '=' 3 7
3=4=5=6=7
```







## grep

`grep` 用于查找文件中符合某种模式的文本行，并将这些行打印出来。

### grep option

```sh
-i # 忽略大小写
-v # 取反，输出不匹配的行
-c # 输出匹配的行数
-n # 输出匹配的行号
-r # 递归搜索子目录
-w # 只匹配整个单词，而不是部分字符串
-E # 使用扩展正则表达式
-F # 使用固定字符串而不是正则表达式
-m # 仅输出前几个匹配行
-A number #输出匹配行的下文，number为上下文行的数量
-B number #输出匹配行的上文，number为上下文行的数量
-C number #输出匹配行的上下文，number为上下文行的数量
```



### grep example



- 查询文件中空行的所在行号

```sh
grep -n "^$" filename

grep -n "^$" filename | awk -F: '{print $1}'

awk '{if($0~/^$/)print NR}' filename 

grep -n "^$" filename | awk 'BEGIN{FS=":"}{print $1}'
```





- **查找指定内容在哪个文件中**

```bash
# 方法一
grep -r "查询内容" 文件目录     # 这样查询出来的包括文件名+内容，等价于grep "查询内容"  2>/dev/null
grep -r -l "查询内容" 文件目录  # 这样只显示包含内容的文件名

# 方法二
find -type f |xargs grep "查询内容" 
```



- **在文件中查找匹配的字符串：**

```sh
grep "search string" file.txt
```

该命令将在 `file.txt` 中查找所有包含 `search string` 的行。



- **在多个文件中查找匹配的字符串：**

```sh
grep "search string" file1.txt file2.txt file3.txt
```

该命令将在 `file1.txt`、`file2.txt` 和 `file3.txt` 中查找所有包含 `search string` 的行。



- **查找包含匹配字符串的文件名：**

```sh
grep -l "search string" *
```

该命令将在当前目录中的所有文件中查找所有包含 `search string` 的文件，并输出这些文件的文件名。



- **查找不包含匹配字符串的行：**

```sh
grep -v "search string" file.txt
```

该命令将在 `file.txt` 中查找所有不包含 `search string` 的行。



- **查找匹配字符串的行数：**

```sh
grep -c "search string" file.txt
```

该命令将在 `file.txt` 中查找所有包含 `search string` 的行，并输出行数。



- **使用正则表达式查找匹配字符串：**

```sh
grep -E "regex pattern" file.txt
```

该命令将在 `file.txt` 中使用正则表达式 `regex pattern` 查找匹配的行。



- **在多个目录中递归查找匹配的字符串：**

```sh
grep -r "search string" /path/to/dir
```

该命令将递归地在 `/path/to/dir` 目录中查找所有包含 `search string` 的文件和行。



- **查看文本中的tab键**

```sh
# grep $'\t' install_httpd.yml 
		- name: Install configure file
		- name: ensure apache is running
		- name: restart httpd
```



## sed

`sed` 用于对文本进行编辑和替换，可以使用正则表达式进行匹配。

- sed是行编辑器

**注意事项**

- 搜索替代时要使用 -ri 或 -i -r 或 -r -i（先使用扩展的正则再编辑），使用 -ir 会报错

### sed option

- `Usage: sed [OPTION]... {script-only-if-no-other-script} [input-file]...`

```sh
-n, --quiet, --silent # 不自动打印模式空间内容
-e script, --expression script # 将指定的脚本添加到命令列表中
-f script-file, --file script-file # 从指定的文件中读取 sed 脚本
-i[SUFFIX], --in-place[=SUFFIX] # 直接修改输入文件，而不是打印到标准输出
-r, --regexp-extended # 使用扩展正则表达式语法
-s, --separate  # 处理多个文件时，将它们视为独立的序列
--sandbox       # 禁止访问文件系统和环境变量，以保证安全性
--follow-symlinks # 跟随符号链接文件
--posix         # 使用 POSIX 模式，只支持 POSIX 兼容的正则表达式
--version       # 显示版本信息并退出
--help          # 显示帮助信息并退出



-n #关闭自动打印，即关闭输出模式空间的内容到屏幕(注意：搜索替代时加n会导致文件被清空)

-e #多点编辑

-r 或 -E #使用扩展的的正则表达式

-i.bak #编辑后给原文件做一个.bak后缀的备份(不加.bak则只编辑，不备份)

-f /PATH/SCRIPT_FILE #从指定文件中读取编辑脚本
```

### address

- **不给地址**

  - 对全文进行处理

- **单地址**

  - ```bash
    # #指定的行
    
    $ #最后一行
    
    /pattern/ #被此处模式所能够匹配到的每一行
    ```

- **地址范围**

  - ```bash
    N,N    # 从N行到第N行，比如：3,6 表示从第3行到第6行
    
    N,+N   # 从N行到+N行，比如：3,+4 表示从3行到第7行
    
    /pat1/,/pat2/ # pat1到pat2匹配的行
    
    N,/pat/ # 从N到pat1的行
    ```

- **步进**

  - ```bash
    1~2 # 奇数行（从1行开始，每次增加2行，1、3、5、7、9...）
    
    2~2 # 偶数行（从2行开始，每次增加2行，2、4、6、8、10...）
    
    N~N # 从N行开始，每次增加N行
    ```

  - 范例:

    - ```bash
      # cat test.txt 
      1
      2
      3
      4
      5
      6
      7
      8
      9
      10
      
      
      # sed -n '2~2p' test.txt 
      2
      4
      6
      8
      10
      
      # sed -n '1~2p' test.txt 
      1
      3
      5
      7
      9
      ```




### cmd

```bash
p # 打印当前模式空间内容，追加到默认输出之后

Ip # 忽略大小写输出

d # 删除模式空间匹配的行，并立即启用下一轮循环

a [\\]text # 在指定行后面追加文本，支持使用\n实现多行追加

i [\\]text # 在行前面插入文本

c [\\]text # 替换行为单行或多行文本

w /path/file # 保存模式匹配的行至指定文件

r /path/file # 读取指定文件的文本至模式空间中匹配到的行后

= # 为模式空间中的行打印行号

! # 模式空间中匹配行取反处理

---

s/要查找的内容/替换为的内容/修饰符 # 查找替换,支持使用其它分隔符，可以是其它形式：s@@@，s###
# 要查找的内容：可使用基本正则表达式模式
# 替换为的内容：不能使用模式，但可以使用\1, \2, ...等后向引用符号；还可以使用“&”引用前面查找时查找到的整个内容


# 修饰符：
g   # 全局替换，默认情况下，每一行只替换第一次出现
gc  #全局替换，每次替换前询问
p   # 显示替换成功的行
w /PATH/FILE # 将替换成功的行保存至文件中
I,i # 忽略大小写
```





### sed example

```sh
# 替换文本中的字符串，这个命令将会在文件file.txt中查找所有出现的字符串"old_string"并将其替换为"new_string"。
sed 's/old_string/new_string/g' file.txt


# 删除文件中的空行，这个命令将会在文件file.txt中删除所有的空行。
sed '/^$/d' file.txt


# 修改文件中某一行的内容，这个命令将会在文件file.txt的第5行中查找所有出现的字符串"old_string"并将其替换为"new_string"。
sed '5s/old_string/new_string/' file.txt


# 在行首添加字符，这个命令将会在文件file.txt的每一行前面添加字符串"prefix"。
sed 's/^/prefix/' file.txt


# 在行尾添加字符，这个命令将会在文件file.txt的每一行末尾添加字符串"suffix"。
sed 's/$/suffix/' file.txt

# 将多个空格替换为一个空格，这个命令将会在文件file.txt中将多个连续的空格替换为一个空格。
sed 's/ */ /g' file.txt


# 将文本中的所有小写字母转换为大写字母，这个命令将会在文件file.txt中将所有小写字母转换为大写字母。
sed 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/' file.txt
```



- **查找并替换**

```bash
#在匹配行前后加内容
在包含www.baidu.com的行前面或后面添加多一行内容www.qq.com
#匹配行前加
sed -i '/www.baidu.com/i www.qq.com' domain.file
#匹配行后加
sed -i '/www.baidu.com/a www.qq.com' domain.file

#选择包含的文本内容，并在后面追加空行（i表示忽略大小写，g表示全文替换）
root@logstash:/opt# sed -r 's/(.*JAMes.*)/\1\n/ig' passwd
root:x:0:0:rootJAMES:/root:/bin/bash 

daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/JAMESusr/sbin/nologin 

sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin

#过滤url
[root@centos ~]# cat 1.txt
http://www.baidu.com/more/
http://www.baidu.com/guding/more.html
http://www.baidu.com/events/20060105/photomore.html
http://hi.baidu.com/browse/
http://www.sina.com.cn/head/www20021123am.shtml
http://www.sina.com.cn/head/www20041223am.shtml
[root@centos ~]# sed -e 's/http:\/\///' -e 's/\/.*//' 1.txt
www.baidu.com
www.baidu.com
www.baidu.com
hi.baidu.com
www.sina.com.cn
www.sina.com.cn
```

- **字符(&)的用法**

```bash
"s/^AA.*/&XX" : 把所有以AA开头的行，在行尾假设XX，其中的字符(&)表示所有以AA开头的字符串。

满足匹配的字符串文本内容
$ echo "AABB" | sed "s/AA/AAXX/g" 
AAXXBB
$ echo "AABB" | sed "s/AA/&XX/g"
AAXXBB

例子3. 给所有的连续字符A加后缀XX
这个怎么写呢，如果不用字符(&)好像不方便，因为不确定有多少个A字符。
$ echo "AAABB" | sed "s/A\+/XX/g"
XXBB  这样是不正确的

使用字符(&)
$ echo "AAABB" | sed "s/A\+/&XX/g"  
AAAXXBB
```

- **取磁盘空间最大百分比**

```bash
#df | sed -n '/^\/dev\/sd*/p'
/dev/sda2       31441920 1741192  29700728   6% /
/dev/sda1        1038336  172152    866184  17% /boot
/dev/sda3       52403200  398416  52004784   1% /data

df | sed -nE '/^\/dev\/sd/s#.* ([0-9]+)%.*$#\1#p'

df | sed -nE '/^\/dev\/sd/s#.* ([0-9]+)%.*$#\1#p'\| sort -n | tail -1
```

- **显示非#开头的行**

```bash
sed -n '/^[^#]/p' FILE
```

- **在一个日志中，找出2020年四月27日20点到2020年四月27日23点30分这一段内容**

```bash
sed -n '/27\/Apr\/2020:20/,/27\/Apr\/2020:23:30/p' nginx.access.log-20200428
```

```
sed -Ei.bak '/^\(pool|server\).*iburst/d' /etc/chrony.conf ？？？
```

- **关闭selinux**

```bash
sed -ri.bak 's/^(SELINUX=).*/\1disabled/' /etc/selinux/config
```

- **删除最后一行并作备份**

```bash
sed -i.bak '$d' /etc/resolv.conf
```







## awk

`awk`用于对文本进行处理和分析，支持数据的过滤、格式化和统计等操作。

- **#只要是字符串，就要用""号引起来**

### awk option

```sh
-F # 指定字段分隔符。例如，-F:表示使用冒号作为字段分隔符。
-f # 指定awk程序文件的路径。
-v # 定义awk变量并赋值。例如，-v var=value表示定义变量var，并将其赋值为value。
-W # 指定awk程序使用的传统行为。例如，-W compat表示启用awk传统行为。
-w # 打开warning模式。例如，-w all表示打开所有警告模式。
-S # 启用缓存优化模式，提高awk程序的性能。
-M # 设置最大记录大小，以MB为单位。例如，-M 100表示设置最大记录大小为100MB。
-i # 在原始文件上直接修改。例如，-i inplace表示在原始文件上直接进行修改。
-F # 指定输入文件的编码方式。例如，-F UTF-8表示使用UTF-8编码方式。
-r # 启用动态加载功能，可加载动态链接库。
-L # 设置递归深度。例如，-L 20表示设置递归深度为20层。
-n # 禁用自动打印模式。默认情况下，awk会自动打印匹配到的行。使用-n选项可以禁用自动打印模式。
-N # 禁用null分隔符模式。默认情况下，awk使用null分隔符作为输入记录分隔符。使用-N选项可以禁用null分隔符模式。
-F # 指定输出字段分隔符。例如，-F,表示使用逗号作为字段分隔符。
-W # 启用gawk扩展功能。例如，-W gnu表示启用gawk扩展功能。
```



### awk example

- **统计文件中某个字段的数量**

假设有一个文件包含多行数据，每行数据由多个字段组成，字段之间使用逗号分隔。我们想要统计第二个字段中每个值出现的次数，可以使用以下命令：

```sh
awk -F',' '{count[$2]++} END {for (word in count) print word, count[word]}' file.txt
```

这条命令使用逗号作为字段分隔符，将第二个字段的值存储在一个名为`count`的数组中，并逐个累加每个值出现的次数。最后，输出每个值以及它出现的次数。

- **从文件中提取关键词**

假设有一个文本文件包含多行数据，每行数据包含一个句子。我们想要从文件中提取包含某个关键词的句子，可以使用以下命令：

```sh
awk '/keyword/ {print}' file.txt
```

这条命令使用`/keyword/`模式匹配包含关键词的行，并使用`print`命令输出匹配到的行。

- **格式化文本数据**

假设有一个文本文件包含多行数据，每行数据由多个字段组成，字段之间使用空格分隔。我们想要格式化数据，使每个字段之间使用逗号分隔，并且每行数据占用固定的宽度，可以使用以下命令：

```sh
awk '{printf("%-10s, %-10s, %-10s\n", $1, $2, $3)}' file.txt
```

这条命令使用`printf`命令格式化输出，将每个字段之间用逗号分隔，使用`%-10s`指定每个字段占用的宽度为10个字符，并且左对齐输出。最后，使用`\n`换行符输出每行数据。

- **处理文件中的空行和注释**

假设有一个文本文件包含多行数据，其中包含空行和注释行。我们想要从文件中删除空行和注释行，可以使用以下命令：

```sh
awk '!/^ *$/ && !/^#/ {print}' file.txt
```

这条命令使用`!/^ *$/`模式匹配非空行，并使用`!/^#/`模式匹配不以`#`开头的行。最后，使用`print`命令输出匹配到的行。



### 范例

```sh
# grep password /data/mysql/mysql.log
2024-02-28T08:37:19.122875Z 1 [Note] A temporary password is generated for root@localhost: Z%fxftwZ6cDa

# awk '/temporary password/{print $NF}' /data/mysql/mysql.log
Z%fxftwZ6cDa
```

在这个命令中，`awk` 是一个用于文本处理的命令行工具。它可以对输入的文本进行逐行处理，并根据给定的规则进行匹配、提取和处理。

具体来说，命令的含义如下：

- `/temporary password/`：这是一个模式匹配，用来筛选包含 "temporary password" 这个字符串的行。在这里，它是一个正则表达式，匹配包含 "temporary password" 的行。
- `{print $NF}`：这是 `awk` 的动作部分。在满足前面模式匹配的条件下，对匹配到的每一行执行动作。`print $NF` 表示打印该行的最后一个字段（以空格或制表符分隔的部分）。`$NF` 是 `awk` 内置变量，表示最后一个字段。

综合起来，命令的作用是从 `/data/mysql/mysql.log` 文件中查找包含 "temporary password" 字符串的行，并打印这些行中的最后一个字段，也就是该行的最后一个单词或字段。通常情况下，这应该是该行的密码。

## vim

### vim 配置文件

```bash
vim ~/.vimrc

set list #显示文本中的空格，等价于 cat -A 
set et #一个tab键等于八个空格(默认值，配合set ts=number可以实现自定义空格个数)
set ts=4 #一个tab键等于四个空格
set cul #设置光标所在行的标识线
set ai #启用自动缩进
set noai #禁用自动缩进
set ic #忽略大小写

#命令模式下执行 set paste 保留文件原有格式


----
set nu #查看文件的行
```

检查文本中是否有空格：

```bash
#扩展命令模式下执行
set list
```



### vim 快捷键

```bash
ctrl-f	#上翻一页
ctrl-b	#下翻一页
ctrl-u	#上翻半页
ctrl-d	#下翻半页
```



以下是VIM常用快捷键列表：

- 移动光标：
  - h：左移光标
  - j：下移光标
  - k：上移光标
  - l：右移光标
  - gg：移动到文档开头
  - G：移动到文档结尾
  - :行号：跳转到指定行号
- 插入、删除和编辑文本：
  - i：在光标前插入文本
  - I：在行首插入文本
  - a：在光标后插入文本
  - A：在行末插入文本
  - o：在光标下方新建一行并插入文本
  - O：在光标上方新建一行并插入文本
  - x：删除光标所在位置的字符
  - dd：删除光标所在行
  - yy：复制光标所在行
  - p：粘贴文本
  - u：撤销上一次操作
  - Ctrl+r：重做上一次操作
- 查找和替换：
  - /：查找关键字
  - n：跳转到下一个匹配项
  - N：跳转到上一个匹配项
  - :s/old/new：将光标所在行的第一个old替换为new
  - :s/old/new/g：将光标所在行的所有old替换为new
  - :%s/old/new/g：将全文中的所有old替换为new
- 保存和退出：
  - :w：保存文件
  - :q：退出VIM
  - :wq：保存文件并退出VIM
  - :q!：不保存文件并强制退出VIM

以上是常用的VIM快捷键列表，可以根据需要灵活使用。



### 使VIM打开的文件带颜色

```bash
echo 'export EDITOR=vim' >> /etc/profile.d/env.sh

#EDITOR就是系统自带的变量，他影响大部分配置文件的文字颜色
```



### 将命令的输出信息打印到文本中

```bash
#在扩展命令模式下执行（:进入扩展命令模式）
r! command
```

### 全文搜索替代

```
格式：%s/source/dist/g 或者 :1,$ s/source/dist/g

　　:s/vivian/sky/ 替换当前行第一个 vivian 为 sky

　　:s/vivian/sky/g 替换当前行所有 vivian 为 sky

　　:n,$s/vivian/sky/ 替换第 n 行开始到最后一行中每一行的第一个 vivian 为 sky

　　:n,$s/vivian/sky/g 替换第 n 行开始到最后一行中每一行所有 vivian 为 sky

　　n 为数字，若 n 为 .，表示从当前行开始到最后一行

　　:%s/vivian/sky/(等同于 :g/vivian/s//sky/) 替换每一行的第一个 vivian 为 sky

　　:%s/vivian/sky/g(等同于 :g/vivian/s//sky/g) 替换每一行中所有 vivian 为 sky

　　可以使用 # 作为分隔符，此时中间出现的 / 不会作为分隔符

　　:s#vivian/#sky/# 替换当前行第一个 vivian/ 为 sky/

　　:%s+/oradata/apras/+/user01/apras1+ (使用+ 来 替换 / )： /oradata/apras/替换成/user01/apras1/
```

### 把类似vimsudo的程序默认文本编辑器设置为vim，从而使编辑文本时让文本带颜色

```bash
echo 'export EDITOR=vim' >> /etc/profile.d/env.sh
```





### vim 相关问题

**解决 swap file "*.swp" already exists！问题**

- 在 Linux 下的 vim 编辑过程中，由于某种原因异常退出正在编辑的文件，再次编辑该文件时，会出现如下提示：
  - swap file "*.swp" already exists！
- 使用vim编辑文件实际是先 copy 一份临时文件并映射到内存给你编辑， 编辑的是临时文件， 当执行：w 后才保存临时文件到原文件，执行：q 后才删除临时文件。
- 每次启动检索是否有临时文件， 有则询问如何处理，就会出现如上情景。
- 将隐藏的 *.swp 文件删除即可，原先的文件便可再次编辑。



当您使用vim编辑文件时，如果在编辑过程中发生异常退出，vim会自动创建一个交换文件（swap file）以保存您未保存的更改，这个交换文件的后缀名是.swp。当您再次打开同一个文件进行编辑时，vim会检查是否存在.swp文件，如果存在，vim会提示您是否恢复未保存的更改，或者删除该文件并重新开始编辑。

然而，有时候您可能会遇到vim提示“swap file '*.swp' already exists！”的问题，这意味着vim检测到已经存在一个.swp文件，但无法确认是否是由于异常退出引起的，因此需要您手动决定如何处理。

要解决这个问题，您可以按照以下步骤操作：

1. 首先，vim会告诉您.swp文件的路径，例如：“E325: ATTENTION Found a swap file by the name ".file.swp"，这告诉您.swp文件的名称为.file.swp。
2. 您可以使用ls命令查看.swp文件是否存在，例如：ls -a | grep .file.swp。如果文件存在，您可以使用rm命令删除该文件，例如：rm .file.swp。
3. 如果您确信.swp文件是由异常退出引起的，您可以选择恢复未保存的更改。在vim中输入:r .file.swp命令即可打开交换文件，然后选择恢复或者放弃更改。
4. 如果您不确定.swp文件的来源或者不希望恢复未保存的更改，您可以选择忽略该文件，然后重新开始编辑。在vim中输入:e!命令即可打开一个新的空白文件，并忽略交换文件。

以上就是解决VIM中“swap file '*.swp' already exists！”问题的方法。



### vim编辑器中文输入乱码问题

```sh
cat > ~/.vimrc <<EOF
set fileencodings=utf-8,gb2312,gbk,gb18030  
set termencoding=utf-8  
set fileformats=unix  
set encoding=prc
EOF
```



### 去掉文本中的 ^M 字符

- 用vim打开文档


```sh
#执行
:set ff=unix

#保存退出
```





## rev

- rev 可以实现行倒序显示

```sh
# cat test.txt 
abc

# rev test.txt 
cba
```



## tr 

- 文本转换

```bash
#文件内容转大写
tr 'a-z' 'A-Z' < filename > 1

sed -i 's/[a-z]/\u&/g' filename
```



## cut

- 取列

```SH
#cut命令主要是接受三个定位方法：
-b #字节
-c #字符
-f #域，配合-d指定分隔符

#截取test.txt的前10列
cut -c 1-10 test.txt

#截取该文件中的第二，第五和第七列
cut -d: -f 2,5,7 /etc/passwd

#截取前三个字节
[root@aliyun ~]# date
Sun Sep 13 04:50:10 CST 2020
[root@aliyun ~]# date | cut -b 1-3
Sun
```



## column

- 整齐显示column -t

```bash
#原文
ls 2
echo 2
cat 2
rm 1
ll 1
history 1
date 1
cut 1
cd 1

#column -t
ls       2
history  2
echo     2
cat      2
rm       1
ll       1
date     1
cut      1
cd       1
```



##  split

- 分割文件，split 命令可以分割一个文件为多个文件

```sh
#切割
#分割大的 tar 文件为多份小文件
split -b Size –d tar-file-name prefix-name
split -b 1M mybackup.tgz mybackup-parts

#切换成的多个小分文件使用数字后缀
split -b 1M –d mybackup.tgz mybackup-parts

#合并
#将多个切割的小文件合并成一个大文件
cat mybackup-parts* > mybackup.tar.gz
```





## column

- `column  -t` 输出结果整齐显示

```bash
# 实现前 
# kubectl get pod -n nginx -o wide |awk '{print $1,$3,$7}'
NAME STATUS NODE
nginx-deployment-5559575875-2qlds Running k8s-work-2
nginx-deployment-5559575875-4r6dp Running k8s-work-2
nginx-deployment-5559575875-8pv6b Running k8s-work-2
nginx-deployment-5559575875-ff8t5 Running k8s-work-1
nginx-deployment-5559575875-q5d6z Running k8s-work-1


# 实现后
# kubectl get pod -n nginx -o wide |awk '{print $1,$3,$7}'|column  -t
NAME                               STATUS   NODE
nginx-deployment-5559575875-2qlds  Running  k8s-work-2
nginx-deployment-5559575875-4r6dp  Running  k8s-work-2
nginx-deployment-5559575875-8pv6b  Running  k8s-work-2
nginx-deployment-5559575875-ff8t5  Running  k8s-work-1
nginx-deployment-5559575875-q5d6z  Running  k8s-work-1
```











## tail

```bash
# 去除文件的第一行（从第二行开始显示）
tail -n +2


# 只跟踪新增加的文件
tail -f /data/ -n0
```



## head

```bash
head -n -1  #去除文件的最后一行（除最后一行，其余全部显示）
```



## printf 格式化输出

`printf` 可以实现格式化输出

```bash
[root@aliyun ~]# printf "%s\n" {1..6}
1
2
3
4
5
6

[root@aliyun ~]# printf "(%s)" {1..3}
(1)(2)(3)[root@aliyun ~]#

[root@aliyun ~]# printf "(%s)" {1..3};echo
(1)(2)(3)

[root@aliyun ~]# printf "(%s)\n" {1..3}
(1)
(2)
(3)
```



## iconv

`iconv` 是一个用于字符集转换的命令行工具，它可以在不同的字符集之间进行转换。它非常有用，特别是在处理文本文件时，需要在不同的字符集之间进行转换。以下是 `iconv` 命令的详解：

```
iconv [options] -f <from_encoding> -t <to_encoding> <input_file(s)>
```

**选项：**

- `-f <from_encoding>`：指定输入文件的字符集编码。
- `-t <to_encoding>`：指定输出文件的字符集编码。
- `-l`：列出所有支持的字符集编码。
- `-c`：忽略输入文件中的无效字符，而不是终止转换过程。
- `-o <output_file>`：指定输出文件的名称。
- `-s`：禁止输出文件中的字符集转换错误信息。
- `-c`：替换无效字符，并继续转换过程。
- `-t <translit>`：启用字符集转换时的音译模式。

**示例用法：**

1. 将一个文件从 UTF-8 转换为 ASCII 编码并将输出写入新文件：

   ```
   iconv -f UTF-8 -t ASCII input.txt > output.txt
   ```

2. 将一个文件从 ISO-8859-1 转换为 UTF-8 编码：

   ```
   iconv -f ISO-8859-1 -t UTF-8 input.txt > output.txt
   ```

3. 列出所有支持的字符集编码：

   ```
   iconv -l
   ```

4. 将一个文件从 GBK 转换为 UTF-8 编码，并忽略无效字符：

   ```
   iconv -f GBK -t UTF-8 -c input.txt > output.txt
   ```

5. 将一个文件从 UTF-8 转换为 ASCII 编码，并在转换过程中替换无效字符：

   ```
   iconv -f UTF-8 -t ASCII -c input.txt > output.txt
   ```

这些示例涵盖了一些常见的 `iconv` 命令用法，但您可以根据需要使用不同的选项和参数来适应特定的转换需求。运行 `man iconv` 命令可以查看完整的命令文档以获取更多详细信息。



## base64

`base64` 是一个用于进行 Base64 编码和解码的命令行工具。Base64 是一种常见的编码方案，可以将二进制数据转换为可打印的 ASCII 字符串，便于传输和存储。以下是 `base64` 命令的详细解释：

```
base64 [options] [input_file] [output_file]
```

**选项：**

- `-w <num>`：指定输出行的最大宽度，可以设置为 0（零）以禁用换行符。
- `-d`：解码输入文件，将 Base64 编码的数据转换为二进制数据。
- `-i <input_file>`：指定要进行编码或解码的输入文件。
- `-o <output_file>`：指定输出文件的名称。

**示例用法：**

1. 对一个文件进行 Base64 编码并将输出写入新文件：

   ```
   base64 input.txt > output.txt
   ```

2. 对一个文件进行 Base64 解码并将输出写入新文件：

   ```
   base64 -d input.txt > output.txt
   ```

3. 对一个文件进行 Base64 编码，并限制每行输出的最大宽度为 76 个字符：

   ```
   base64 -w 76 input.txt > output.txt
   ```

4. 对一个文件进行 Base64 解码，并将输出写入新文件：

   ```
   base64 -d -i input.txt -o output.txt
   ```

这些示例展示了 `base64` 命令的一些常见用法。您可以根据需要使用不同的选项和参数来进行定制化的编码或解码操作。使用 `man base64` 命令可以查看完整的命令文档以获取更多详细信息。





- 







# 进制转换

## hexdump

- 以十六进制、十进制、八进制或ascii显示文件内容

**选项说明：**

```bash
-b、 --一字节八进制一字节八进制显示

-c、 --一字节字符一字节字符显示

-C、 --标准十六进制+ASCII显示

-d、 --双字节十进制双字节十进制显示

-o、 --双字节八进制双字节八进制显示

-x、 --两字节十六进制两字节十六进制显示

-五十、 --颜色[=<mode>]解释颜色格式说明符默认情况下启用颜色

-e、 --用于显示数据的格式<格式>格式字符串

-f、 --格式化文件<文件>包含格式字符串的文件

-n、 --长度<长度>仅解释输入的长度字节

-s、 --跳过<offset>从头开始跳过偏移字节

-v、 --没有压缩输出相同的行


-h、 --帮助显示此帮助

-V、 --版本显示版本
```



```bash
#查看硬盘的第一个扇区内容，以十六进制显示
[root@58 ~]# hexdump -C -n 512 /dev/sda
```



## xdd

在Linux中，`xdd`是一个用于十六进制和ASCII数据转换的命令行工具。它允许用户以十六进制格式查看文件内容，也可以将十六进制数据转换为ASCII字符，或将ASCII字符转换为十六进制表示。

下面是`xdd`工具的使用方法和一些示例：

### 命令格式：

```
xdd [OPTION]... [FILE]...
```

### 选项（Options）：

- `-h` 或 `--help`：显示帮助信息。
- `-r` 或 `--revert`：执行反转操作，将十六进制转换为二进制形式。
- `-p` 或 `--psize`：指定每行显示的字节数，默认值为 16。

### 示例：

- 查看文件的十六进制和ASCII内容：

```
xdd filename.txt
```

- 将十六进制转换为ASCII字符：

```
xdd -r filename.txt
```

- 自定义每行显示的字节数：

```
xdd -p 8 filename.txt
```

请注意，`xdd`工具在某些Linux发行版中可能没有预先安装，您可能需要根据您的发行版安装相应的软件包。

使用`xdd`工具可以帮助您在Linux终端中查看和分析二进制文件的内容，以及进行二进制数据和ASCII字符之间的转换。



# 时间管理

## date

`date` 命令用于显示和设置系统的日期和时间。它可以用于查看当前系统时间、修改系统时间、以及格式化输出时间等。

```sh
# 显示当前时间
# date +%F
2021-11-25

# 显示3天前时间
# date +%F -d -3day
2021-11-22

# 显示3天后时间
date +%F -d 3day
2021-11-28

# 显示5年前时间
date +%F -d -5year
2016-11-25

-----------

#方法二
# date +%F
2021-11-26
# date +%F -d "2 day hour"
2021-11-28
# date +%F -d "1 day ago"
2021-11-25
```



- 显示当前日期和时间：

  ```sh
  date
  ```

- 显示当前日期：

  ```sh
  date +%Y-%m-%d
  ```

- 显示当前时间：

  ```sh
  date +%H:%M:%S
  ```

- 显示当前日期和时间，包括时区信息：

  ```sh
  date +"%Y-%m-%d %H:%M:%S %Z"
  ```

- 设置系统日期和时间：

  ```sh
  date -s "YYYY-MM-DD HH:MM:SS"
  ```

  其中，"YYYY-MM-DD" 是年-月-日，"HH:MM:SS" 是时:分:秒。

- 将日期和时间格式化为自定义格式：

  ```sh
  date +"格式"
  ```

  可以使用不同的格式选项来显示日期和时间的各个部分。例如：

  ```sh
  date +"今天是 %Y 年 %m 月 %d 日，现在是 %H:%M:%S"
  ```

- 进行日期和时间的计算：

  ```sh
  date -d "日期/时间 + 间隔"
  ```

  可以执行日期和时间的加减计算。例如：

  ```sh
  date -d "2023-05-26 + 1 day"
  date -d "now + 1 hour"
  ```

- 指定输出的时区：

  ```sh
  date -u    # 显示 UTC 时间
  date -R    # 使用 RFC 2822 格式显示时间，带有时区信息
  date -I    # 使用 ISO 8601 格式显示时间，带有时区信息
  ```



### 修改时间

要使用 `date` 命令修改系统时间，你需要具有适当的权限。通常情况下，只有超级用户（root）可以修改系统时间。以下是在 Linux 系统中使用 `date` 命令修改系统时间的步骤：

1. 以超级用户身份登录或使用 `sudo` 命令获取管理员权限。

2. 执行以下命令来修改系统时间：

   ```
   sudo date --set="<yyyy-mm-dd HH:MM:SS>"
   ```

   其中 `<yyyy-mm-dd HH:MM:SS>` 是你想要设置的日期和时间，以 24 小时制的格式表示。例如：

   ```
   sudo date --set="2023-05-31 10:30:00"
   ```

   如果你只想修改时间而不修改日期，可以使用以下命令：

   ```
   sudo date --set="<HH:MM:SS>"
   ```

   其中 `<HH:MM:SS>` 是你想要设置的时间。例如：

   ```
   sudo date --set="12:30:00"
   ```

3. 执行命令后，系统时间将被修改为指定的日期和时间。

请注意，修改系统时间需要谨慎操作，尤其是在生产环境中。错误的时间设置可能会导致系统出现问题或引起数据不一致性。确保在修改系统时间之前，充分了解潜在的风险，并在必要时备份系统数据。



## timedatectl

`timedatectl` 是一个系统时间和日期管理的命令行工具，用于配置和显示系统的时钟和时区设置。它可以查看和修改系统时钟、时区、NTP 同步状态等信息。

```sh
timedatectl # 查看日期时间、时区及NTP状态

timedatectl list-timezones # 查看时区列表

timedatectl set-timezone Asia/Shanghai # 修改时区

timedatectl set-time "2017-01-23 10:30:00" # 修改日期时间

timedatectl set-ntp true/false # 开启NTP
```



`timedatectl` 命令是一个用于管理系统时间和日期的工具，它在 Linux 系统中广泛使用。通过 `timedatectl` 命令，你可以查看和修改系统的时钟、时区、NTP 设置等。以下是 `timedatectl` 命令的常见用法和选项：

- 查看系统的时间和日期信息：

  ```shell
  timedatectl
  ```

- 查看系统的时区信息：

  ```sh
  timedatectl show --property=Timezone
  ```

- 设置系统的时区：

  ```sh
  timedatectl set-timezone 时区
  ```

  其中，"时区" 是所需的时区标识符，例如 "Asia/Shanghai"。

- 查看系统的当前时间和日期：

  ```sh
  timedatectl show --property=LocalTime
  ```

- 设置系统的当前时间和日期：

  ```sh
  sudo timedatectl set-time "YYYY-MM-DD HH:MM:SS"
  ```

  其中，"YYYY-MM-DD" 是年-月-日，"HH:MM:SS" 是时:分:秒。

- 启用或禁用 NTP（网络时间协议）同步：

  ```sh
  sudo timedatectl set-ntp true   # 启用 NTP 同步
  sudo timedatectl set-ntp false  # 禁用 NTP 同步
  ```

- 查看当前 NTP 同步状态：

  ```sh
  timedatectl show --property=NTPSynchronized
  ```

- 查看所有可用的时区列表：

  ```sh
  timedatectl list-timezones
  ```

- 查看系统时钟的校准状态：

  ```sh
  timedatectl show --property=NTPInSync
  ```

- 检查系统时钟的精确度和稳定性：

  ```sh
  timedatectl timesync-status
  ```





## hwclock

`hwclock` 命令用于管理硬件时钟，也称为 CMOS 时钟或实时时钟（RTC）。它可以读取和设置硬件时钟，并与系统时钟进行同步。

`hwclock` 命令是在 Linux 系统中用于管理硬件时钟（也称为 CMOS 时钟或实时时钟 RTC）的工具。它可以用于读取、设置和调整硬件时钟的时间。以下是 `hwclock` 命令的常见用法和选项：

- 显示当前硬件时钟时间：

  ```sh
  hwclock
  ```

- 显示当前硬件时钟时间并转换为本地时间：

  ```sh
  hwclock --show --localtime
  ```

- 显示当前硬件时钟时间并转换为 UTC 时间：

  ```sh
  hwclock --show --utc
  ```

- 将系统时间写入硬件时钟：

  ```sh
  hwclock --systohc
  ```

  这会将系统时间（由内核维护）同步到硬件时钟中。

- 将硬件时钟时间写入系统时间：

  ```sh
  hwclock --hctosys
  ```

  这会将硬件时钟的时间同步到系统时间中。

- 设置硬件时钟的时间：

  ```sh
  hwclock --set --date="YYYY-MM-DD HH:MM:SS"
  ```

  其中，"YYYY-MM-DD" 是年-月-日，"HH:MM:SS" 是时:分:秒。

- 将硬件时钟的时间与系统时间进行校准：

  ```sh
  hwclock --adjust
  ```

  这会根据系统时间的变化来调整硬件时钟。

- 显示硬件时钟的校准状态：

  ```sh
  hwclock --show --adjust
  ```





## tzselect

`tzselect` 是一个在 Unix/Linux 系统上用于选择时区的交互式命令行工具。它可以帮助用户从全球范围内选择正确的时区，并将所选时区配置应用到系统中。

使用 `tzselect` 命令时，你将被提示回答一系列关于地区和城市的问题。根据你的回答，`tzselect` 将为你提供一个匹配的时区。

以下是使用 `tzselect` 命令的步骤：

1. 打开终端窗口，以 root 或具有管理员权限的用户身份登录。

2. 运行命令 `tzselect`。

3. `tzselect` 会显示一系列问题，首先询问你所在的地区，然后要求你选择与所在城市最接近的城市。

4. 根据提示，使用数字或字母键选择适当的选项。

5. 一旦你完成选择，`tzselect` 会输出所选时区的标识符，例如 `America/New_York`。

6. 可以将输出的时区标识符手动设置为系统时区，方法之一是通过将其链接到 `/etc/localtime` 文件。例如，可以使用以下命令将标识符设置为系统时区：

   ```
   ln -sf /usr/share/zoneinfo/America/New_York /etc/localtime
   ```

   注意：在上述命令中，将 `/usr/share/zoneinfo/America/New_York` 替换为 `tzselect` 输出的实际时区标识符。

请注意，`tzselect` 并不会直接修改系统的时区设置，它只是提供了一个交互式的界面来帮助你选择正确的时区标识符。你仍然需要使用适当的命令将所选时区应用到系统中。



## ntpdate

`ntpdate` 是一个用于手动同步系统时间的命令行工具。它通过与远程 NTP（Network Time Protocol）服务器通信，获取准确的时间信息，并将系统时钟进行相应调整。

以下是 `ntpdate` 命令的一般用法和参数：

```sh
ntpdate [选项] 服务器
```

**常用的选项包括：**

- `-q` 或 `--query`：查询远程服务器的时间，但不进行时间调整。
- `-u` 或 `--udp`：使用 UDP 协议与服务器通信。
- `-b` 或 `--set-ntp`：将系统时钟直接设置为从服务器获取的时间。
- `-p 数字` 或 `--priority=数字`：指定查询优先级，数字越小优先级越高。

**使用示例：**

- 查询远程服务器的时间：

```sh
ntpdate -q pool.ntp.org
```

- 设置系统时钟为从服务器获取的时间：

```sh
ntpdate -b pool.ntp.org
```

- 指定查询优先级为 2：

```sh
ntpdate -p 2 pool.ntp.org
```

请注意，`ntpdate` 工具通常用于临时手动同步系统时间，而不是用于自动定期同步。在大多数情况下，建议使用更现代化的时间同步工具，如 `chronyd` 或 `systemd-timesyncd`，以便系统能够自动保持时间的准确性。



在 CentOS 中，`ntpdate` 命令包含在 `ntp` 软件包中。你可以使用以下命令安装 `ntp` 软件包：

```
sudo yum install ntp
```

在 Ubuntu 中，`ntpdate` 命令包含在 `ntpdate` 软件包中。你可以使用以下命令安装 `ntpdate` 软件包：

```
sudo apt-get install ntpdate
```

请注意，最新版本的 CentOS 和 Ubuntu 可能采用不同的时间同步工具。例如，CentOS 7+ 默认使用 `chrony` 或 `systemd-timesyncd`，而 Ubuntu 20.04+ 默认使用 `systemd-timesyncd`。因此，在安装特定的时间同步工具时，请确保参考相应的官方文档或使用系统的默认工具。





# 网络相关

**网络相关包组：**

- **net-tools** 较老 包含 ifconfig 等命令
- **iproute** 较新 包含 ip 等命令



## ping

**选项**

```sh
-c n # ping n次
-s n # 指定发送的包大小，最大65507
-f   # 尽cpu所能发起ping命令，flood的简写
```

**范例**

```bash
# icmp泛洪攻击
ping -f IP -s 65507
```



## arp

```bash
# 显示和通讯过的IP与mac地址的绑定关系
arp -n 


# ARP静态绑定（可以防止ARP欺骗）
# arp -s 10.0.0.6 00:0c:29:32:80:38
# arp -n
Address                 HWtype HWaddress           Flags Mask           Iface
10.0.0.6                 ether   00:0c:29:32:80:38   CM                   eth0
10.0.0.7                 ether   00:0c:29:32:80:38   C                     eth0
10.0.0.1                 ether   00:50:56:c0:00:08   C                     eth0
```



## arping

- 检测网络中是否有冲突的ip地址，如果有冲突则会显示多个mac地址

```bash
# 语法
arping IP
```



## telnet

- 探测目标IP的端口是否存在 或 是否能与对方端口连通

```bash
telnet 8.140.166.135 1194
```





## DNS 管理

### host

- DNS测试工具，来自 bind-utils 包。

```bash
# 测试是否能将域名解析为IP地址
# host xiangzheng.vip
xiangzheng.vip has address 8.140.166.135
```



### dig

- 显示更详细的 DNS 测试工具，来自 bind-utils 包。

```bash
# 显示dns相关的详细信息
# dig xiangzheng.vip

; <<>> DiG 9.11.26-RedHat-9.11.26-6.el8 <<>> xiangzheng.vip
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: REFUSED, id: 48323
;; flags: qr rd; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1
;; WARNING: recursion requested but not available

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 1232
; COOKIE: e637d014d318e73888c580e561bb0c0c22a2e3e30f462ad0 (good)
;; QUESTION SECTION:
;xiangzheng.vip.			IN	A

;; Query time: 0 msec
;; SERVER: 10.0.0.8#53(10.0.0.8)
;; WHEN: Thu Dec 16 17:51:08 CST 2021
;; MSG SIZE  rcvd: 71


# 测试140.205.41.21这个DNS服务器能否直接将xiangzheng.vip的IP解析出来，flags处显示aa表示可以，aa表示全为DNS服务器
dig xiangzheng.vip @140.205.41.21

# 查看域名或IP对应的邮件服务器地址
dig -t mx 邮件服务器的域名或IP

# 抓所有区域信息，但对已经安全加固的DNS服务器无效，@后面跟DNS服务器
dig -t axfr xiangzheng.org  @10.0.0.8

; <<>> DiG 9.11.26-RedHat-9.11.26-6.el8 <<>> -t axfr xiangzheng.org @10.0.0.18
;; global options: +cmd
xiangzheng.org.		86400	IN	SOA	ns1.xiangzheng.org. rootroot25.163.com. 20211218 3600 600 86400 10800
xiangzheng.org.		86400	IN	NS	ns1.xiangzheng.org.
xiangzheng.org.		86400	IN	NS	ns2.xiangzheng.org.
ns1.xiangzheng.org.	86400	IN	A	10.0.0.8
ns2.xiangzheng.org.	86400	IN	A	10.0.0.18
websrv.xiangzheng.org.	86400	IN	A	10.0.0.38
www.xiangzheng.org.	86400	IN	CNAME	websrv.xiangzheng.org.
xiangzheng.org.		86400	IN	SOA	ns1.xiangzheng.org. rootroot25.163.com. 20211218 3600 600 86400 10800
;; Query time: 2 msec
;; SERVER: 10.0.0.18#53(10.0.0.18)
;; WHEN: Sat Dec 18 05:33:15 CST 2021
;; XFR size: 8 records (messages 1, bytes 270)
```



### nslookup

。。。





## 抓包

### tcpdump

tcpdump 是网络数据包截获分析工具，可以抓取**流经本机**的数据包，支持针对网络层、协议、主机、网络或端口的过滤。并提供and、or、not等逻辑语句帮助去除无用的信息。

- **指定网卡抓包时 只要数据包能到此网卡 无论网卡是否有IP 都可以抓取到数据包**

**语法**

- `tcpdump [option] [not] [proto] [dir] [type]`

  - ```sh
    # proto，指定协议，不指定则所有协议都进行输出
    tcp
    udp
    icmp
    arp
    ip
    ether
    
    
    # dir，不指定则默认为 src or dst、
    src
    dst
    src and dst
    
    
    # type
    host
    net <network> # <network>是一个IP地址和子网掩码的组合，用来指定网络范围。它允许你捕获源IP地址或目标IP地址在指定网络中的数据包。
    port
    ```


**常用选项**

```sh
-D   # 列出可用于抓包的接口

-i <网络接口>  # 指定tcpdump需要监听的接口，未指定则选择编号最小的接口（即-D选项所列出编号最小的）

-c <数据包数目> # 指定要抓取的包数量

-w  # 把数据包数据写入指定的文件。（例如：-w ./target.cap 保存成cap文件，方便用wireshark分析）

-e   # 以太网(数据链路层)，显示mac地址，输出的每行中都将包括数据链路层头部信息，例如源MAC和目标MAC

-nn  # 直接以 IP 及 port number 显示，而非主机名与服务名称

-s <数据包大小> # 设置每个数据包的大小。设置tcpdump的数据包抓取长度，如果不设置默认将会是65535字节。
              # -s0 表示不对数据包进行截断，即捕获完整的数据包。这种情况下，数据包不会被截断，tcpdump 将会尽可能地捕获并显示或保存完整的数据包。这个选项通常用于确保在分析或调试过程中不会丢失任何数据包内容。默认情况下，tcpdump 会在捕获数据包时根据网络接口的 MTU（最大传输单元）来截断数据包，以便能够正确处理和显示数据。但是，如果你需要查看完整的数据包，或者你在分析网络流量时需要保留所有信息，使用 -s0 是很有用的。

-q   # 快速输出，仅列出少数的传输协议信息。

-v   # 详细输出

port # 指定端口

host # 指定主机
```

**非常用选项**

```sh
-a   # 尝试将网络和广播地址转换成名称。

-N   # 不列出域名。

-d   # 把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出。

-dd  # 把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出。

-ddd # 把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出。

-f   # 用数字显示网际网络地址。

-F <表达文件> # 指定内含表达方式的文件。

-l  # 使用标准输出列的缓冲区。

-O  # 不将数据包编码最佳化。

-p  # 不让网络界面进入混杂模式。

-r <数据包文件> # 从指定的文件读取数据包数据。

-S   # 用绝对而非相对数值列出TCP关联数。

-t  # 在每列倾倒资料上不显示时间戳记。

-tt # 在每列倾倒资料上显示未经格式化的时间戳记。

-T <数据包类型> # 强制将表达方式所指定的数据包转译成设置的数据包类型。

-x   # 用十六进制字码列出数据包资料。
```





#### 范例

- host
- 需要注意的是，IP地址226.6.6.6是一个多播地址。多播地址用于将数据同时发送给多个接收者。如果您要捕获多播流量，请确保您的网络接口已正确设置以接收多播数据包。否则，您可能看不到任何使用这些命令捕获的数据包。

```sh
tcpdump host 226.6.6.6
# 捕获所有源自或发送到IP地址为226.6.6.6的主机的数据包。


tcpdump src host 226.6.6.6
# 捕获所有由IP地址为226.6.6.6的主机发送的数据包。


tcpdump dst host 226.6.6.6
# 捕获所有发送到IP地址为226.6.6.6的主机的数据包。


# tcpdump -i ens33 -nn host 8.140.166.135
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes
17:16:02.018751 IP 10.0.0.123 > 8.140.166.135: ICMP echo request, id 7, seq 1, length 64
17:16:02.049286 IP 8.140.166.135 > 10.0.0.123: ICMP echo reply, id 7, seq 1, length 64


# tcpdump -i ens33 -nn dst host 8.140.166.135
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes
17:16:28.206467 IP 10.0.0.123 > 8.140.166.135: ICMP echo request, id 8, seq 1, length 64


# tcpdump -i ens33 -nn src host 8.140.166.135
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes
17:16:46.716668 IP 8.140.166.135 > 10.0.0.123: ICMP echo reply, id 9, seq 1, length 64
```

- net

```sh
tcpdump net 192.168.1.0/24
# 捕获所有源IP地址或目标IP地址在192.168.1.0子网内的数据包。


tcpdump net 10.0.0.0/8
# 捕获所有源IP地址或目标IP地址在10.0.0.0子网内的数据包，因为/8子网掩码表示前8位是网络地址，允许范围为10.x.x.x的IP地址。


tcpdump net 172.16.0.0/16
# 捕获所有源IP地址或目标IP地址在172.16.x.x范围内的数据包，因为/16子网掩码表示前16位是网络地址，允许范围为172.16.x.x到172.16.255.255的IP地址。


tcpdump net not 10 and net not 0
# 捕获所有来自或发往除了网络10.0.0.0/8和0.0.0.0/8之外的其他网络的数据包。也就是说，它将排除来自本地主机和保留地址的数据包，并只捕获与其他网络之间的通信。
# 和 tcpdump net ! 10 and net ! 0 等价
```

- 组合使用

```bash
tcpdump tcp port 22 and host hostname
# 监视指定主机和端口的数据包


tcpdump -c 5 -i eth0 -nn icmp
# 抓取5个流经本机eth0网卡的icmp数据包


tcpdump -nn tcp port 80
# 监视当前系统中tcp 80端口的网络数据信息


tcpdump udp port 123
# 对本机的udp 123端口进行监视(123为ntp的服务端口)


tcpdump -c 10 net 192.168
# 监视指定网络的数据包，如本机与192.168网段通信的数据包，"-c 10"表示只抓取10个包


tcpdump 'gateway snup and (port ftp or ftp-data)'
# 打印所有通过网关snup的ftp数据包(注意,表达式被单引号括起来了,这可以防止shell对其中的括号进行错误解析)


tcpdump -c 10 -nn -i eth0 tcp dst port 22
# 抓取到本机22端口包 


tcpdump -nn src host 10.0.0.18 and dst host 10.0.0.28
# 点对点抓取


tcpdump -c 1000
# 限制抓包的数量，如下，抓到1000个包后，自动退出


tcpdump -n -vvv -c 1000 -w /tmp/tcpdump_save.cap
# 保存到本地，tcpdump默认会将输出写到缓冲区，只有缓冲区内容达到一定的大小，或者tcpdump退出时，才会将输出写到本地磁盘,可以加上-U强制立即写到本地磁盘（一般不建议，性能相对较差）


tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap
# tcp: 抓取的协议类型
# -i eth1 : 只抓经过接口eth1的包
# -t : 不显示时间戳
# -s 0 : 抓取数据包时默认抓取长度为68字节。加上-S 0 后可以抓到完整的数据包
# -c 100 : 只抓取100个数据包
# dst port ! 22 : 不抓取目标端口是22的数据包
# src net 192.168.1.0/24 : 数据包的源网络地址为192.168.1.0/24
# -w ./target.cap : 保存成cap文件，方便用wireshark分析


tcpdump -i any -nn host 192.168.1.1 and tcp port 80
# 使用 tcpdump 监听主机为 192.168.1.1 tcp 端口为 80 的数据
# tcp 可以不加，因为默认就是tcp


tcpdump -i any -n host 192.168.1.1 and udp port 53
# 使用 tcpdump 监听主机为 192.168.1.1 udp 端口为 53 的数据


tcpdump -i any -nn port 80
# 实时抓取并显示当前系统中 tcp 80 端口的网络数据信息


tcpdump -i any -nn udp port 53
# 实时抓取并显示当前系统中 udp 53端口的网络数据信息，请写出完整操作命令


tcpdump -i eth2 -nn host 10.136.9.14 and port 80
# 抓取 eth2 网卡上经过的数据包，已知对方 IP 为 10.136.9.14，TCP 端口为80，对应的命令为


tcpdump -s 0 -Q inout not host 114.114.114.114 and not host 169.254.25.10 and not port mysql and not port 9200 and not port 30196 and not arp -w pcap_path
# -s 0 设置抓取的数据包的最大长度为0，表示抓取完整的数据包。
# -Q inout 指定只捕获进出的数据包，即双向数据包。
# not host 114.114.114.114 排除目标主机为114.114.114.114的数据包。
# and not host 169.254.25.10 排除目标主机为169.254.25.10的数据包。
# and not port mysql 排除目标端口为mysql的数据包。
# and not port 9200 排除目标端口为9200的数据包。
# and not port 30196 排除目标端口为30196的数据包。
# and not arp 排除ARP协议的数据包。
# -w pcap_path 将捕获的数据包写入指定的pcap文件中，`pcap_path`是文件的路径。
# 综上所述，该命令的含义是使用tcpdump工具捕获所有进出的数据包，但排除目标主机为114.114.114.114和169.254.25.10，以及目标端口为mysql、9200和30196的数据包，同时排除ARP协议的数据包，并将捕获的数据包写入指定的pcap文件中。
```



#### 输出说明

##### http

- 下面是客户端使用 curl 命令访问 http 服务时，在 http 服务端的抓包记录

**03:31:32.901880 IP localhost.42744 > localhost.80: Flags [S], seq 3639596300, win 65495, options [mss 65495,sackOK,TS val 2311349850 ecr 0,nop,wscale 7], length 0** 

这是一段抓包数据的输出，采用的是`tcpdump`工具。让我为你解释其中的各个部分：

`03:31:32.901880`：表示抓包的时间戳，以小时:分钟:秒.毫秒的格式显示。

`IP localhost.42744 > localhost.80`：表示源IP地址为`localhost`（本地主机），源端口号为`42744`，目标IP地址也是`localhost`，目标端口号为`80`。这表示本地主机通过源端口`42744`与本地主机上的端口`80`建立连接。

`Flags [S]`：这是TCP协议的连接建立标志，`S`表示这是一个建立连接的请求（SYN包）。

`seq 3639596300`：表示序列号（sequence number），用于对数据包进行排序和重组。

`win 65495`：表示窗口大小（window size），指示接收端还能接收多少字节的数据。

`options [mss 65495,sackOK,TS val 2311349850 ecr 0,nop,wscale 7]`：这是TCP选项（TCP options）部分，提供了一些附加的信息。其中：

- `mss 65495`：表示最大段长度（Maximum Segment Size），指示发送端最大能发送的数据段的大小。
- `sackOK`：表示选择确认（Selective Acknowledgment，SACK）选项被启用，允许接收端选择性地确认已经接收到的数据。
- `TS val 2311349850 ecr 0`：表示时间戳选项（Timestamp Option），用于测量往返时间（RTT）和序列号溢出的问题。
- `nop`：空操作选项，没有实际意义。
- `wscale 7`：表示窗口缩放选项，用于在窗口大小小于65,535时扩大窗口。

`length 0`：表示数据包的长度为0字节，因为这是一个连接建立的请求，不包含实际数据。

总结起来，这段抓包数据表示在本地主机上，通过端口`42744`向本地主机上的端口`80`发送了一个TCP连接建立请求（SYN包），窗口大小为`65495`，并附带了一些TCP选项。



**03:31:32.901904 IP localhost.80 > localhost.42744: Flags [S.], seq 3540594534, ack 3639596301, win 65483, options [mss 65495,sackOK,TS val 2311349850 ecr 2311349850,nop,wscale 7], length 0**

这是一段抓包数据的输出，与之前的输出相对应。让我为你解释其中的各个部分：

`03:31:32.901904`：表示抓包的时间戳，以小时:分钟:秒.毫秒的格式显示。

`IP localhost.80 > localhost.42744`：表示源IP地址为`localhost`（本地主机），源端口号为`80`，目标IP地址也是`localhost`，目标端口号为`42744`。这表示本地主机通过源端口`80`向本地主机上的端口`42744`发送数据。

`Flags [S.]`：这是TCP协议的连接建立标志，`S.`表示这是一个建立连接的响应（SYN-ACK包）。

`seq 3540594534`：表示序列号（sequence number），用于对数据包进行排序和重组。

`ack 3639596301`：表示确认号（acknowledgment number），表示期望接收到的下一个字节的序列号。

`win 65483`：表示窗口大小（window size），指示发送端还能接收多少字节的数据。

`options [mss 65495,sackOK,TS val 2311349850 ecr 2311349850,nop,wscale 7]`：这是TCP选项（TCP options）部分，提供了一些附加的信息。与之前的输出相比，选项内容基本相同，包括最大段长度（mss）、选择确认（sackOK）、时间戳（TS val和ecr）、空操作（nop）和窗口缩放（wscale）。

`length 0`：表示数据包的长度为0字节，因为这是一个连接建立的响应，不包含实际数据。

总结起来，这段抓包数据表示在本地主机上，通过端口`80`向本地主机上的端口`42744`发送了一个TCP连接建立响应（SYN-ACK包），窗口大小为`65483`，并附带了一些TCP选项，确认号为`3639596301`。



**03:31:32.901928 IP localhost.42744 > localhost.80: Flags [.], ack 1, win 512, options [nop,nop,TS val 2311349851 ecr 2311349850], length 0**

这是一段抓包数据的输出，与之前的输出相对应。让我为你解释其中的各个部分：

`03:31:32.901928`：表示抓包的时间戳，以小时:分钟:秒.毫秒的格式显示。

`IP localhost.42744 > localhost.80`：表示源IP地址为`localhost`（本地主机），源端口号为`42744`，目标IP地址也是`localhost`，目标端口号为`80`。这表示本地主机通过源端口`42744`向本地主机上的端口`80`发送数据。

`Flags [.], ack 1`：这是TCP协议的确认标志，`.`表示这是一个确认包。`ack 1`表示确认号为1，表示已成功接收到序列号为1的数据。

`win 512`：表示窗口大小（window size），指示发送端还能接收多少字节的数据。

`options [nop,nop,TS val 2311349851 ecr 2311349850]`：这是TCP选项（TCP options）部分，提供了一些附加的信息。其中：

- `nop`：空操作选项，没有实际意义。
- `TS val 2311349851 ecr 2311349850`：表示时间戳选项（Timestamp Option），用于测量往返时间（RTT）和序列号溢出的问题。

`length 0`：表示数据包的长度为0字节，因为这是一个确认包，不包含实际数据。

总结起来，这段抓包数据表示在本地主机上，通过端口`42744`向本地主机上的端口`80`发送了一个TCP确认包，确认号为1，窗口大小为512，并附带了时间戳选项。



**03:31:32.902043 IP localhost.42744 > localhost.80: Flags [P.], seq 1:77, ack 1, win 512, options [nop,nop,TS val 2311349851 ecr 2311349850], length 76: HTTP: GET / HTTP/1.1**

这是一段抓包数据的输出，与之前的输出相对应。让我为你解释其中的各个部分：

`03:31:32.902043`：表示抓包的时间戳，以小时:分钟:秒.毫秒的格式显示。

`IP localhost.42744 > localhost.80`：表示源IP地址为`localhost`（本地主机），源端口号为`42744`，目标IP地址也是`localhost`，目标端口号为`80`。这表示本地主机通过源端口`42744`向本地主机上的端口`80`发送数据。

`Flags [P.]`：这是TCP协议的数据传输标志，`P.`表示这是一个带有数据的数据包（PUSH包）。

`seq 1:77`：表示序列号（sequence number），表示数据包中的数据序列号范围。这里是1到77，表示发送的数据字节范围。

`ack 1`：表示确认号（acknowledgment number），表示期望接收到的下一个字节的序列号。

`win 512`：表示窗口大小（window size），指示发送端还能接收多少字节的数据。

`options [nop,nop,TS val 2311349851 ecr 2311349850]`：这是TCP选项（TCP options）部分，提供了一些附加的信息。与之前的输出相比，选项内容基本相同，包括空操作（nop）和时间戳（TS val和ecr）。

`length 76: HTTP: GET / HTTP/1.1`：表示数据包的长度为76字节，其中包含了HTTP请求。具体的内容是一个HTTP GET请求，请求的路径是根目录`/`，使用的协议版本是HTTP/1.1。

总结起来，这段抓包数据表示在本地主机上，通过端口`42744`向本地主机上的端口`80`发送了一个带有HTTP GET请求的数据包，数据包长度为76字节，其中的数据是`GET / HTTP/1.1`。



**03:31:32.902055 IP localhost.80 > localhost.42744: Flags [.], ack 77, win 511, options [nop,nop,TS val 2311349851 ecr 2311349851], length 0**

这是一段抓包数据的输出，与之前的输出相对应。让我为你解释其中的各个部分：

`03:31:32.902055`：表示抓包的时间戳，以小时:分钟:秒.毫秒的格式显示。

`IP localhost.80 > localhost.42744`：表示源IP地址为`localhost`（本地主机），源端口号为`80`，目标IP地址也是`localhost`，目标端口号为`42744`。这表示本地主机通过源端口`80`向本地主机上的端口`42744`发送数据。

`Flags [.], ack 77`：这是TCP协议的确认标志，`.`表示这是一个确认包。`ack 77`表示确认号为77，表示已成功接收到序列号为77的数据。

`win 511`：表示窗口大小（window size），指示发送端还能接收多少字节的数据。

`options [nop,nop,TS val 2311349851 ecr 2311349851]`：这是TCP选项（TCP options）部分，提供了一些附加的信息。与之前的输出相比，选项内容基本相同，包括空操作（nop）和时间戳（TS val和ecr）。

`length 0`：表示数据包的长度为0字节，因为这是一个确认包，不包含实际数据。

总结起来，这段抓包数据表示在本地主机上，通过端口`80`向本地主机上的端口`42744`发送了一个TCP确认包，确认号为77，窗口大小为511，并附带了时间戳选项。



**03:31:32.906528 IP localhost.80 > localhost.42744: Flags [P.], seq 1:18, ack 77, win 512, options [nop,nop,TS val 2311349855 ecr 2311349851], length 17: HTTP: HTTP/1.0 200 OK**

这是一段抓包数据的输出，与之前的输出相对应。让我为你解释其中的各个部分：

`03:31:32.906528`：表示抓包的时间戳，以小时:分钟:秒.毫秒的格式显示。

`IP localhost.80 > localhost.42744`：表示源IP地址为`localhost`（本地主机），源端口号为`80`，目标IP地址也是`localhost`，目标端口号为`42744`。这表示本地主机通过源端口`80`向本地主机上的端口`42744`发送数据。

`Flags [P.]`：这是TCP协议的数据传输标志，`P.`表示这是一个带有数据的数据包（PUSH包）。

`seq 1:18`：表示序列号（sequence number），表示数据包中的数据序列号范围。这里是1到18，表示发送的数据字节范围。

`ack 77`：表示确认号（acknowledgment number），表示期望接收到的下一个字节的序列号。

`win 512`：表示窗口大小（window size），指示发送端还能接收多少字节的数据。

`options [nop,nop,TS val 2311349855 ecr 2311349851]`：这是TCP选项（TCP options）部分，提供了一些附加的信息。与之前的输出相比，选项内容基本相同，包括空操作（nop）和时间戳（TS val和ecr）。

`length 17: HTTP: HTTP/1.0 200 OK`：表示数据包的长度为17字节，其中包含了HTTP响应。具体的内容是一个HTTP响应，状态行为`HTTP/1.0 200 OK`，表示请求成功。

总结起来，这段抓包数据表示在本地主机上，通过端口`80`向本地主机上的端口`42744`发送了一个带有HTTP响应的数据包，数据包长度为17字节，其中的数据是`HTTP/1.0 200 OK`。



**03:31:32.906539 IP localhost.42744 > localhost.80: Flags [.], ack 18, win 512, options [nop,nop,TS val 2311349855 ecr 2311349855], length 0**

这是一段抓包数据的输出，与之前的输出相对应。让我为你解释其中的各个部分：

`03:31:32.906539`：表示抓包的时间戳，以小时:分钟:秒.毫秒的格式显示。

`IP localhost.42744 > localhost.80`：表示源IP地址为`localhost`（本地主机），源端口号为`42744`，目标IP地址也是`localhost`，目标端口号为`80`。这表示本地主机通过源端口`42744`向本地主机上的端口`80`发送数据。

`Flags [.], ack 18`：这是TCP协议的确认标志，`.`表示这是一个确认包。`ack 18`表示确认号为18，表示已成功接收到序列号为18的数据。

`win 512`：表示窗口大小（window size），指示发送端还能接收多少字节的数据。

`options [nop,nop,TS val 2311349855 ecr 2311349855]`：这是TCP选项（TCP options）部分，提供了一些附加的信息。与之前的输出相比，选项内容基本相同，包括空操作（nop）和时间戳（TS val和ecr）。

`length 0`：表示数据包的长度为0字节，因为这是一个确认包，不包含实际数据。

总结起来，这段抓包数据表示在本地主机上，通过端口`42744`向本地主机上的端口`80`发送了一个TCP确认包，确认号为18，窗口大小为512，并附带了时间戳选项。



**03:31:32.906891 IP localhost.80 > localhost.42744: Flags [P.], seq 18:154, ack 77, win 512, options [nop,nop,TS val 2311349855 ecr 2311349855], length 136: HTTP**

这是一段抓包数据的输出，与之前的输出相对应。让我为你解释其中的各个部分：

`03:31:32.906891`：表示抓包的时间戳，以小时:分钟:秒.毫秒的格式显示。

`IP localhost.80 > localhost.42744`：表示源IP地址为`localhost`（本地主机），源端口号为`80`，目标IP地址也是`localhost`，目标端口号为`42744`。这表示本地主机通过源端口`80`向本地主机上的端口`42744`发送数据。

`Flags [P.]`：这是TCP协议的数据传输标志，`P.`表示这是一个带有数据的数据包（PUSH包）。

`seq 18:154`：表示序列号（sequence number），表示数据包中的数据序列号范围。这里是18到154，表示发送的数据字节范围。

`ack 77`：表示确认号（acknowledgment number），表示期望接收到的下一个字节的序列号。

`win 512`：表示窗口大小（window size），指示发送端还能接收多少字节的数据。

`options [nop,nop,TS val 2311349855 ecr 2311349855]`：这是TCP选项（TCP options）部分，提供了一些附加的信息。与之前的输出相比，选项内容基本相同，包括空操作（nop）和时间戳（TS val和ecr）。

`length 136: HTTP`：表示数据包的长度为136字节，其中包含了HTTP数据。具体的内容是一个HTTP数据，可能是HTTP报文的一部分。

总结起来，这段抓包数据表示在本地主机上，通过端口`80`向本地主机上的端口`42744`发送了一个带有HTTP数据的数据包，数据包长度为136字节，其中的数据可能是HTTP报文的一部分。



**03:31:32.906898 IP localhost.42744 > localhost.80: Flags [.], ack 154, win 511, options [nop,nop,TS val 2311349855 ecr 2311349855], length 0**

这是一段抓包数据的输出，与之前的输出相对应。让我为你解释其中的各个部分：

`03:31:32.906898`：表示抓包的时间戳，以小时:分钟:秒.毫秒的格式显示。

`IP localhost.42744 > localhost.80`：表示源IP地址为`localhost`（本地主机），源端口号为`42744`，目标IP地址也是`localhost`，目标端口号为`80`。这表示本地主机通过源端口`42744`向本地主机上的端口`80`发送数据。

`Flags [.], ack 154`：这是TCP协议的确认标志，`.`表示这是一个确认包。`ack 154`表示确认号为154，表示已成功接收到序列号为154的数据。

`win 511`：表示窗口大小（window size），指示发送端还能接收多少字节的数据。

`options [nop,nop,TS val 2311349855 ecr 2311349855]`：这是TCP选项（TCP options）部分，提供了一些附加的信息。与之前的输出相比，选项内容基本相同，包括空操作（nop）和时间戳（TS val和ecr）。

`length 0`：表示数据包的长度为0字节，因为这是一个确认包，不包含实际数据。

总结起来，这段抓包数据表示在本地主机上，通过端口`42744`向本地主机上的端口`80`发送了一个TCP确认包，确认号为154，窗口大小为511，并附带了时间戳选项。



**03:31:32.907058 IP localhost.80 > localhost.42744: Flags [P.], seq 154:249, ack 77, win 512, options [nop,nop,TS val 2311349856 ecr 2311349855], length 95: HTTP**

这是一段抓包数据的输出，与之前的输出相对应。让我为你解释其中的各个部分：

`03:31:32.907058`：表示抓包的时间戳，以小时:分钟:秒.毫秒的格式显示。

`IP localhost.80 > localhost.42744`：表示源IP地址为`localhost`（本地主机），源端口号为`80`，目标IP地址也是`localhost`，目标端口号为`42744`。这表示本地主机通过源端口`80`向本地主机上的端口`42744`发送数据。

`Flags [P.]`：这是TCP协议的数据传输标志，`P.`表示这是一个带有数据的数据包（PUSH包）。

`seq 154:249`：表示序列号（sequence number），表示数据包中的数据序列号范围。这里是154到249，表示发送的数据字节范围。

`ack 77`：表示确认号（acknowledgment number），表示期望接收到的下一个字节的序列号。

`win 512`：表示窗口大小（window size），指示发送端还能接收多少字节的数据。

`options [nop,nop,TS val 2311349856 ecr 2311349855]`：这是TCP选项（TCP options）部分，提供了一些附加的信息。与之前的输出相比，选项内容基本相同，包括空操作（nop）和时间戳（TS val和ecr）。

`length 95: HTTP`：表示数据包的长度为95字节，其中包含了HTTP数据。具体的内容是一个HTTP数据。

总结起来，这段抓包数据表示在本地主机上，通过端口`80`向本地主机上的端口`42744`发送了一个带有HTTP数据的数据包，数据包长度为95字节，其中的数据是一个HTTP数据。



**03:31:32.907064 IP localhost.42744 > localhost.80: Flags [.], ack 249, win 511, options [nop,nop,TS val 2311349856 ecr 2311349856], length 0**

这是一段抓包数据的输出，与之前的输出相对应。让我为你解释其中的各个部分：

`03:31:32.907064`：表示抓包的时间戳，以小时:分钟:秒.毫秒的格式显示。

`IP localhost.42744 > localhost.80`：表示源IP地址为`localhost`（本地主机），源端口号为`42744`，目标IP地址也是`localhost`，目标端口号为`80`。这表示本地主机通过源端口`42744`向本地主机上的端口`80`发送数据。

`Flags [.], ack 249`：这是TCP协议的确认标志，`.`表示这是一个确认包。`ack 249`表示确认号为249，表示已成功接收到序列号为249的数据。

`win 511`：表示窗口大小（window size），指示发送端还能接收多少字节的数据。

`options [nop,nop,TS val 2311349856 ecr 2311349856]`：这是TCP选项（TCP options）部分，提供了一些附加的信息。与之前的输出相比，选项内容基本相同，包括空操作（nop）和时间戳（TS val和ecr）。

`length 0`：表示数据包的长度为0字节，因为这是一个确认包，不包含实际数据。

总结起来，这段抓包数据表示在本地主机上，通过端口`42744`向本地主机上的端口`80`发送了一个TCP确认包，确认号为249，窗口大小为511，并附带了时间戳选项。



**03:31:32.907214 IP localhost.42744 > localhost.80: Flags [F.], seq 77, ack 249, win 512, options [nop,nop,TS val 2311349856 ecr 2311349856], length 0**

这是一段抓包数据的输出，与之前的输出相对应。让我为你解释其中的各个部分：

`03:31:32.907214`：表示抓包的时间戳，以小时:分钟:秒.毫秒的格式显示。

`IP localhost.42744 > localhost.80`：表示源IP地址为`localhost`（本地主机），源端口号为`42744`，目标IP地址也是`localhost`，目标端口号为`80`。这表示本地主机通过源端口`42744`向本地主机上的端口`80`发送数据。

`Flags [F.]`：这是TCP协议的标志，`F.`表示这是一个带有标志位`FIN`（终止连接）的数据包。

`seq 77`：表示序列号（sequence number），表示数据包中的数据序列号。这里是77，表示发送的数据字节序列号为77。

`ack 249`：表示确认号（acknowledgment number），表示期望接收到的下一个字节的序列号。

`win 512`：表示窗口大小（window size），指示发送端还能接收多少字节的数据。

`options [nop,nop,TS val 2311349856 ecr 2311349856]`：这是TCP选项（TCP options）部分，提供了一些附加的信息。与之前的输出相比，选项内容基本相同，包括空操作（nop）和时间戳（TS val和ecr）。

`length 0`：表示数据包的长度为0字节，因为这是一个终止连接的数据包，不包含实际数据。

总结起来，这段抓包数据表示在本地主机上，通过端口`42744`向本地主机上的端口`80`发送了一个带有标志位`FIN`的数据包，数据包序列号为77，确认号为249，窗口大小为512，并附带了时间戳选项。这表示发送端希望终止与目标端口的连接。



**03:31:32.907566 IP localhost.80 > localhost.42744: Flags [F.], seq 249, ack 78, win 512, options [nop,nop,TS val 2311349856 ecr 2311349856], length 0**

这是一段抓包数据的输出，与之前的输出相对应。让我为你解释其中的各个部分：

`03:31:32.907566`：表示抓包的时间戳，以小时:分钟:秒.毫秒的格式显示。

`IP localhost.80 > localhost.42744`：表示源IP地址为`localhost`（本地主机），源端口号为`80`，目标IP地址也是`localhost`，目标端口号为`42744`。这表示本地主机通过源端口`80`向本地主机上的端口`42744`发送数据。

`Flags [F.]`：这是TCP协议的标志，`F.`表示这是一个带有标志位`FIN`（终止连接）的数据包。

`seq 249`：表示序列号（sequence number），表示数据包中的数据序列号。这里是249，表示发送的数据字节序列号为249。

`ack 78`：表示确认号（acknowledgment number），表示期望接收到的下一个字节的序列号。

`win 512`：表示窗口大小（window size），指示发送端还能接收多少字节的数据。

`options [nop,nop,TS val 2311349856 ecr 2311349856]`：这是TCP选项（TCP options）部分，提供了一些附加的信息。与之前的输出相比，选项内容基本相同，包括空操作（nop）和时间戳（TS val和ecr）。

`length 0`：表示数据包的长度为0字节，因为这是一个终止连接的数据包，不包含实际数据。

总结起来，这段抓包数据表示在本地主机上，通过端口`80`向本地主机上的端口`42744`发送了一个带有标志位`FIN`的数据包，数据包序列号为249，确认号为78，窗口大小为512，并附带了时间戳选项。这表示目标端口希望终止与发送端的连接。



**03:31:32.907575 IP localhost.42744 > localhost.80: Flags [.], ack 250, win 512, options [nop,nop,TS val 2311349856 ecr 2311349856], length 0**

这是一段抓包数据的输出，与之前的输出相对应。让我为你解释其中的各个部分：

`03:31:32.907575`：表示抓包的时间戳，以小时:分钟:秒.毫秒的格式显示。

`IP localhost.42744 > localhost.80`：表示源IP地址为`localhost`（本地主机），源端口号为`42744`，目标IP地址也是`localhost`，目标端口号为`80`。这表示本地主机通过源端口`42744`向本地主机上的端口`80`发送数据。

`Flags [.], ack 250`：这是TCP协议的确认标志，`.`表示这是一个确认包。`ack 250`表示确认号为250，表示已成功接收到序列号为250的数据。

`win 512`：表示窗口大小（window size），指示发送端还能接收多少字节的数据。

`options [nop,nop,TS val 2311349856 ecr 2311349856]`：这是TCP选项（TCP options）部分，提供了一些附加的信息。与之前的输出相比，选项内容基本相同，包括空操作（nop）和时间戳（TS val和ecr）。

`length 0`：表示数据包的长度为0字节，因为这是一个确认包，不包含实际数据。

总结起来，这段抓包数据表示在本地主机上，通过端口`42744`向本地主机上的端口`80`发送了一个TCP确认包，确认号为250，窗口大小为512，并附带了时间戳选项。这表示发送端已成功接收到目标端口发送的序列号为250的数据。



### wireshark







## 路由管理

### traceroute

跟踪路由

`traceroute` 是一种网络诊断工具，用于跟踪数据包从本地计算机到目标主机（例如网站或服务器）在IP网络上的路径，以帮助识别沿途的路由和潜在的网络问题或延迟。该工具在大多数类Unix操作系统上可用，包括Linux和macOS，以及在Windows系统上称为 `tracert`。

以下是 `traceroute` 命令的详细解释：

**语法：**

```
traceroute [选项] 目标
```

**参数：**

- `目标`：要追踪路径的目标主机的IP地址或主机名。
- `选项`：修改 `traceroute`命令行为的可选参数。一些常见的选项包括：
  - `-n`：绕过DNS解析，在输出中显示IP地址而不是主机名。
  - `-q 数量`：设置每一跳的查询次数，默认为三次。
  - `-w 超时`：设置等待响应的最大时间（以秒为单位），默认为五秒。
  - `-m 最大跳数`：设置在放弃之前要追踪的最大跳数，默认为30。

**`traceroute` 的工作原理：**

 当你运行 `traceroute` 命令时，它会发送一系列带有递增的TTL（Time-to-Live）值的UDP（用户数据报协议）或ICMP（Internet控制消息协议）数据包。TTL值最初设置为1，对于每一跳，它会递增1。TTL值决定了数据包在被中间路由器丢弃之前允许经过的跳数。当TTL值达到0时，接收数据包的路由器会丢弃它，并向源发送ICMP "Time Exceeded"消息，表示数据包未到达目标。

当 `traceroute` 发送这些数据包时，它记录每一跳的响应时间和响应的路由器的IP地址（或如果使用了DNS解析，则是主机名）。通过分析路由器序列和它们的响应时间，`traceroute` 可以提供有关你的计算机与目标之间的网络路径的有价值的信息。

**输出：**

 `traceroute` 命令显示一系列中间路由器（跳数），并列出每一跳的IP地址（或主机名）以及每一跳的响应时间。它从最接近你本地计算机的路由器开始，并一直延续到目标主机，或者直到达到最大TTL值。

以下是 `traceroute` 的示例输出：

```
traceroute 到 example.com (93.184.216.34)，最多 30 跳，60 字节数据包
 1  192.168.1.1 (192.168.1.1)  1.234 ms  1.123 ms  1.567 ms
 2  10.0.0.1 (10.0.0.1)  4.567 ms  5.234 ms  4.876 ms
 3  203.0.113.1 (203.0.113.1)  8.123 ms  9.234 ms  7.567 ms
 4  198.51.100.1 (198.51.100.1)  12.345 ms  11.876 ms  13.567 ms
 5  203.0.113.2 (203.0.113.2)  18.567 ms  17.123 ms  19.876 ms
 6  93.184.216.34 (93.184.216.34)  25.234 ms  23.567 ms  22.123 ms
```

**解释输出：**

- 最左边的列表示跳数。
- 第二列显示该跳的路由器的IP地址或主机名。
- 接下来的三列分别表示发送到该跳的三个探测数据包的往返时间（以毫秒为单位）。

**注意：** 

有些路由器可能不会响应 `traceroute` 数据包，因此你可能在某些跳上看到星号（*）而不是响应时间。

`traceroute` 是诊断网络问题、了解数据包路径以及识别潜在瓶颈或有问题的路由器的有用工具。请记住，网络条件可能会有所变化，因此多次运行 `traceroute` 或从不同位置运行可能提供更全面的网络路径信息。



### tracepath

跟踪路由

`tracepath` 命令是一个网络诊断工具，类似于 `traceroute`，用于跟踪数据包从本地计算机到目标主机（例如网站或服务器）在IP网络上的路径。它的功能与 `traceroute` 类似，但在一些系统上，`tracepath` 可能是更简化版本或替代品。

与 `traceroute` 不同，`tracepath` 不需要特权权限（如管理员权限）来运行，因此在某些情况下可能更方便。它使用类似的原理，通过逐跳增加TTL值并观察响应来确定数据包的路径和延迟。

**语法：**

```sh
tracepath [选项] 目标
```

**参数：**

- `目标`：要追踪路径的目标主机的IP地址或主机名。

**`tracepath` 的工作原理：** 

`tracepath` 命令发送一系列带有递增的TTL（Time-to-Live）值的UDP（用户数据报协议）数据包，类似于 `traceroute`。它从TTL值为1开始，并逐跳增加。对于每一跳，它等待获得响应并记录响应时间和响应的路由器的IP地址（或主机名）。

与 `traceroute` 不同的是，`tracepath` 不会发送三个数据包，而只发送一个数据包，并等待一个较短的时间来获取响应。这使得 `tracepath` 的输出相对简洁，但也可能导致在某些情况下丢失一些响应数据。

**输出：** 

`tracepath` 命令的输出显示目标主机的路径，类似于 `traceroute` 的输出。它列出每一跳的IP地址（或主机名）以及每一跳的响应时间。

以下是 `tracepath` 的示例输出：

```
1?: [LOCALHOST]                               pmtu 1500
1:  192.168.1.1                                       0.777ms 
1:  192.168.1.1                                       0.889ms 
2:  203.0.113.1                                       5.117ms 
3:  198.51.100.1                                     10.431ms 
4:  203.0.113.2                                     15.987ms 
5:  93.184.216.34                                    21.227ms reached
     Resume: pmtu 1500 hops 5 back 5 
```

**解释输出：**

- 第一行表示本地主机的路径MTU（最大传输单元）大小。
- 后续行显示每一跳的IP地址（或主机名）以及从本地主机到该跳的响应时间。

总体而言，`tracepath` 是一个简单实用的网络诊断工具，用于检查数据包在网络上的路径和延迟，帮助发现潜在的网络问题或瓶颈。如果你无法使用 `traceroute` 或希望获得更简洁的输出，`tracepath` 可能是一个不错的选择。



### mtr

跟踪路由

`mtr` 是一种网络诊断工具，结合了 `traceroute` 和 `ping` 的功能。它的全称是 "My TraceRoute"，是 `traceroute` 和 `ping` 命令的扩展和改进版本。`mtr` 可以提供更详细和实时的网络路径和延迟信息。

与单独使用 `traceroute` 和 `ping` 相比，`mtr` 在一个命令下执行连续的 traceroute 和 ping 操作，以便更好地监测网络路径的连通性和响应时间。

**语法：**

```
mtr [选项] 目标
```

**参数：**

- `目标`：要追踪路径和ping的目标主机的IP地址或主机名。

**`mtr` 的工作原理：**

 `mtr` 命令使用了 `traceroute` 和 `ping` 的原理。它发送一系列带有递增的TTL（Time-to-Live）值的UDP数据包（类似于 `traceroute`），然后等待目标主机的响应（类似于 `ping`）。但与 `traceroute` 不同的是，`mtr` 在连续的时间间隔内持续执行这些操作。

每次收到目标主机的响应后，`mtr` 会将得到的响应时间和经过的路由器记录下来，并显示在一个实时的表格中。这样，你可以不断地看到网络路径和每一跳的响应时间的变化情况。

**输出：** 

`mtr` 命令的输出显示一个表格，其中包含每一跳的IP地址（或主机名）、丢包率和平均往返时间（即平均响应时间）。表格的底部还会显示整个路径的平均往返时间和丢包率。

以下是 `mtr` 的示例输出：

```
Start: 2023-07-30T10:30:00+0000
HOST: MyComputer             Loss%   Snt   Last   Avg  Best  Wrst StDev
  1.|-- 192.168.1.1            0.0%    10    1.0   1.5   1.0   2.0   0.5
  2.|-- 203.0.113.1            0.0%    10    5.0   6.0   5.0   7.0   0.5
  3.|-- 198.51.100.1           0.0%    10   10.0  10.5  10.0  11.0   0.5
  4.|-- 203.0.113.2            0.0%    10   15.0  15.5  15.0  16.0   0.5
  5.|-- 93.184.216.34          0.0%    10   20.0  20.5  20.0  21.0   0.5
```

**解释输出：**

- `HOST` 列显示每一跳的IP地址或主机名。
- `Loss%` 列显示在发送数据包时丢失的百分比。
- `Snt` 列显示已发送的数据包数量。
- `Last`、`Avg`、`Best`、`Wrst` 和 `StDev` 列显示每一跳的响应时间的统计数据。

`mtr` 是一个非常有用的网络工具，尤其适用于实时监测网络路径和连通性，并帮助找出网络故障或延迟的原因。它可以为你提供关于网络路径的更全面信息，方便进行网络性能分析和故障排除。



### route

- route 命令可以管理路由表，来自net-tools包。
- **注意：此命令为临时生效，永久生效需写配置文件**

#### 查看路由表

```bash
route -n


# 输出说明：
Destination # 目标网络地址，表示可以到达的目标网络。
            # 0.0.0.0/0 表示所有未知网络，又称为默认路由，优先级最低。

Genmask # 目标网络对应的netmask

Gateway # 网关地址，即到达非直连的网络，将数据发送到临近(下一个)路由器的临近本主机的接口的IP地址。
        # 如果是直连络，gateway是0.0.0.0

Metric # 开销cost,值越小,路由记录的优先级最高

Iface # 到达对应网络,应该从当前主机哪个网卡发送出来
```

#### 添加路由表

**语法**

```
route add [-net|-host|default] target [netmask Nm] [gw GW] [[dev] If]
```

**范例**

```bash
route add -host 192.168.1.3 gw 172.16.0.1 dev eth0
# add -host，添加主机路由，目标主机为 192.168.1.3
# gw 网关为172.16.0.1
# dev 从 eth0 设备流出的流量


route add -net 192.168.0.0 netmask 255.255.255.0 gw 172.16.0.1 dev eth0
route add -net 192.168.0.0/24 gw 172.16.0.1 dev eth0
route add -net 192.168.8.0/24 dev eth1 metric 200
# 添加网络路由的三种方式，目标：192.168.0.0 网关：172.16.0.1


route add -net 0.0.0.0 netmask 0.0.0.0 gw 172.16.0.1
route add -net 0.0.0.0/0 gw 172.16.0.1
route add default gw 172.16.0.1
# 添加默认路由的三种方式，网关：172.16.0.1
```



#### 删除路由表

**语法**

```
route del [-net|-host] target [gw Gw] [netmask Nm] [[dev] If]
```

**范例**

```bash
route del -host 192.168.1.3
# 删除主机路由，目标：192.168.1.3 网关：172.16.0.1


route del -net 192.168.0.0 netmask 255.255.255.0
# 删除网络路由目标：192.168.0.0 网关：172.16.0.1


route del gw
route del -net 0.0.0.0 gw 10.0.0.2
# 删除默认路由的两种方式
```

### ip

- 使用ip命令来管理路由时，可以先使用 ip route 命令来查看路由信息；
- 要添加永久路由的话，可以直接复制输出的内容直接进行更改。

#### 查看路由信息

```bash
ip route
```

#### 临时添加路由

```bash
# 语法
ip route add 目标网络ID/子网掩码 via 网关 dev 网卡名 proto static metric 104


ip route add default via 10.0.0.2 dev eth0 proto static metric 101
# 临时添加默认路由
```

#### 删除路由

```bash
# 语法，信息有重名的情况下需要添加网关网卡名等信息，否则可省略
ip route add 目标网络ID/子网掩码 via 网关 dev 网卡名 proto static metric 104


ip route del default via 10.0.0.2 dev eth0 proto static metric 101
ip route del default dev eth0
# 删除默认路由的两种方式
```

#### 添加网关

```bash
ip route add default via GW dev IFACE
```





#### 网卡管理

#### ethtool

##### ethtool -i eth0

- `ethtool -i eth0`用于显示指定接口的驱动程序信息。

```sh
# ethtool -i eth0
driver: e1000 # 这表示以太网接口的驱动程序是 e1000。
version: 7.3.21-k8-NAPI # 这部分显示驱动程序的版本号，该版本为 7.3.21-k8-NAPI。
firmware-version: # 此行显示固件版本。由于输出中为空白，表示固件版本未提供。
expansion-rom-version: # 这部分显示扩展 ROM 的版本。由于输出中为空白，表示扩展 ROM 版本未提供。
bus-info: 0000:02:01.0 # 此行提供了与接口相关的总线信息。
supports-statistics: yes # 这表示接口支持统计信息的收集和报告。
supports-test: yes # 此行表示接口支持测试功能。
supports-eeprom-access: yes # 这表示接口支持 EEPROM 访问。
supports-register-dump: yes # 此行表示接口支持寄存器转储。
supports-priv-flags: no # 这部分显示接口是否支持私有标志（私有功能）。在此输出中，不支持私有标志。



# ethtool -i eth0
driver: virtio_net # 这表示以太网接口的驱动程序是 virtio_net。
version: 1.0.0 # 此行显示驱动程序的版本号，该版本为 1.0.0。
firmware-version: # 此行显示固件版本。由于输出中为空白，表示固件版本未提供。
expansion-rom-version: # 这部分显示扩展 ROM 的版本。由于输出中为空白，表示扩展 ROM 版本未提供。
bus-info: 0000:00:05.0 # 此行提供了与接口相关的总线信息。
supports-statistics: yes # 这表示接口支持统计信息的收集和报告。
supports-test: no # 此行表示接口不支持测试功能。
supports-eeprom-access: no # 这表示接口不支持 EEPROM 访问。
supports-register-dump: no # 此行表示接口不支持寄存器转储。
supports-priv-flags: no # 这部分显示接口是否支持私有标志（私有功能）。在此输出中，不支持私有标志。
```



##### ethtool eth0

- `ethtool eth0`用于显示指定接口的状态和设置，包括连接速度、双工模式、硬件特性等。

```sh
[root@7 ~]# ethtool eth0
Settings for eth0:
	Supported ports: [ TP ] # 此行表示接口支持的端口类型为 Twisted Pair（双绞线）。
	# 这部分显示接口支持的链路模式，包括各种速率和双工模式。在此输出中，eth0 支持 10 Mbps 和 100 Mbps 的半双工和全双工模式，以及 1000 Mbps 的全双工模式。
	Supported link modes:   10baseT/Half 10baseT/Full 
	                        100baseT/Half 100baseT/Full 
	                        1000baseT/Full 
	Supported pause frame use: No # 这表示接口不支持暂停帧的使用。
	Supports auto-negotiation: Yes # 此行表示接口支持自动协商功能。
	Supported FEC modes: Not reported # 这部分显示接口支持的前向纠错（FEC）模式。在此输出中，未报告支持的 FEC 模式。
	# 这表示接口宣告支持的链路模式，与上述的支持模式相同。
	Advertised link modes:  10baseT/Half 10baseT/Full 
	                        100baseT/Half 100baseT/Full 
	                        1000baseT/Full 
	Advertised pause frame use: No # 此行表示接口不宣告支持暂停帧的使用。
	Advertised auto-negotiation: Yes # 这表示接口宣告支持自动协商功能。
	Advertised FEC modes: Not reported # 这部分显示接口宣告支持的 FEC 模式。在此输出中，未报告宣告支持的 FEC 模式。
	Speed: 1000Mb/s # 此行显示接口的速度，该接口的速度为 1000 Mbps。
	Duplex: Full # 这表示接口的双工模式为全双工。
	Port: Twisted Pair # 此行表示接口的物理连接类型为双绞线。
	PHYAD: 0 # 这部分提供了物理层地址（PHYAD），在此输出中为 0。
	Transceiver: internal # 此行表示接口使用的是内置的传输器。
	Auto-negotiation: on # 这表示自动协商功能已开启。
	MDI-X: off (auto) # 此行显示 MDI-X 功能的状态。在此输出中，MDI-X 功能为关闭状态，但是设置为自动模式。
	Supports Wake-on: d # 这表示接口支持唤醒功能，但在此输出中具体的唤醒类型未提供。
	Wake-on: d # 此行显示当前的唤醒配置。在此输出中，唤醒配置为 "d"，具体的唤醒类型未提供。
	# 这部分显示当前消息级别的十六进制表示和对应的标志。在此输出中，消息级别为 7，对应的标志为 "drv"、"probe" 和 "link"。这表示当前正在记录与驱动程序、探测和链路相关的消息。
	Current message level: 0x00000007 (7)
			       drv probe link
	Link detected: yes # 此行表示链路检测到连接，即接口检测到物理链路的存在。




[root@8 ~]# ethtool eth0
Settings for eth0:
	Supported ports: [ TP ] # 此行表示接口支持的端口类型为 Twisted Pair（双绞线）。
	# 这部分显示接口支持的链路模式，包括各种速率和双工模式。在此输出中，eth0 支持 10 Mbps 和 100 Mbps 的半双工和全双工模式，以及 1000 Mbps 的全双工模式。
	Supported link modes:   10baseT/Half 10baseT/Full 
	                        100baseT/Half 100baseT/Full 
	                        1000baseT/Full 
	Supported pause frame use: No # 这表示接口不支持暂停帧的使用。
	Supports auto-negotiation: Yes # 此行表示接口支持自动协商功能。
	Supported FEC modes: Not reported # 这部分显示接口支持的前向纠错（FEC）模式。在此输出中，未报告支持的 FEC 模式。
	# 这表示接口宣告支持的链路模式，与上述的支持模式相同。
	Advertised link modes:  10baseT/Half 10baseT/Full 
	                        100baseT/Half 100baseT/Full 
	                        1000baseT/Full 
	Advertised pause frame use: No # 此行表示接口不宣告支持暂停帧的使用。
	Advertised auto-negotiation: Yes # 这表示接口宣告支持自动协商功能。
	Advertised FEC modes: Not reported # 这部分显示接口宣告支持的 FEC 模式。在此输出中，未报告宣告支持的 FEC 模式。
	Speed: 1000Mb/s # 此行显示接口的速度，该接口的速度为 1000 Mbps。
	Duplex: Full # 这表示接口的双工模式为全双工，Full表示全双工。
	Port: Twisted Pair # 此行表示接口的物理连接类型为双绞线。
	PHYAD: 0 # 这部分提供了物理层地址（PHYAD），在此输出中为 0。
	Transceiver: internal # 此行表示接口使用的是内置的传输器。
	Auto-negotiation: on # 这表示自动协商功能已开启。
	MDI-X: off (auto) # 此行显示 MDI-X 功能的状态。在此输出中，MDI-X 功能为关闭状态，但是设置为自动模式。
	Supports Wake-on: d # 这表示接口支持唤醒功能，但在此输出中具体的唤醒类型未提供。
	Wake-on: d # 此行显示当前的唤醒配置。在此输出中，唤醒配置为 "d"，具体的唤醒类型未提供。
	# 这部分显示当前消息级别的十六进制表示和对应的标志。在此输出中，消息级别为 7，对应的标志为 "drv"、"probe" 和 "link"。这表示当前正在记录与驱动程序、探测和链路相关的消息。
	Current message level: 0x00000007 (7)
			       drv probe link
	Link detected: yes # 此行表示链路检测到连接，即接口检测到物理链路的存在，no表示网线断了。


[root@azheng-aliyun-A ~]# ethtool eth0
Settings for eth0:
	Supported ports: [ ] # 此行表示接口不支持特定类型的端口。
	Supported link modes:   Not reported # 这部分表示接口未报告支持的链路模式。
	Supported pause frame use: No # 此行表示接口不支持暂停帧的使用。
	Supports auto-negotiation: No # 这表示接口不支持自动协商功能。
	Supported FEC modes: Not reported # 这部分表示接口未报告支持的前向纠错（FEC）模式。
	Advertised link modes:  Not reported # 这表示接口未报告宣告支持的链路模式。
	Advertised pause frame use: No # 此行表示接口不宣告支持暂停帧的使用。
	Advertised auto-negotiation: No # 这表示接口不宣告支持自动协商功能。
	Advertised FEC modes: Not reported # 这部分表示接口未报告宣告支持的 FEC 模式。
	Speed: Unknown! # 此行显示接口的速度未知。
	Duplex: Unknown! (255) # 这表示接口的双工模式未知，值为 255。
	Port: Other # 此行表示接口的物理连接类型为其他类型。
	PHYAD: 0 # 这部分提供了物理层地址（PHYAD），在此输出中为 0。
	Transceiver: internal # 此行表示接口使用的是内置的传输器。
	Auto-negotiation: off # 这表示自动协商功能已关闭。
	Link detected: yes # 此行表示链路检测到连接，即接口检测到物理链路的存在
# 根据输出信息，接口 eth0 没有提供关于支持的链路模式、速度、双工模式和自动协商的详细信息。速度、双工模式和物理连接类型也未知。然而，链路状态被检测到为连接状态。这可能是因为接口配置的特定情况或其他因素导致的。如果需要进一步了解接口的配置和功能，请参考设备文档或联系网络管理员。
```



#### mii-tools

截至2021年9月，`mii-tools`实用程序在Linux中并不广泛使用，并且被认为有些过时。`mii-tools`用于管理和诊断以MII（Media Independent Interface）标准为基础的以太网网络接口。

自那时以来，Linux网络工具的情况可能已经发生了变化，可能出现了更新、功能更丰富的替代工具。一些发行版可能仍包含`mii-tools`以保持兼容性，但可能已经没有在积极地进行维护或更新。

对于管理现代Linux系统上的以太网接口，您可能会找到更好的选择，比如`ip`（iproute2）、`ifconfig`、`ethtool`和`nmcli`（NetworkManager命令行接口）。这些工具提供了更全面的功能，更好地支持不同的网络配置，并提供更好的性能。

如果您正在寻找网络管理工具或故障排除实用程序，建议使用更新的、更广泛采用的工具，以确保兼容性，并获得最新的功能和错误修复。

在使用任何特定工具之前，建议查阅您的Linux发行版的文档和社区资源，以确定适用于您系统版本的推荐和支持的网络管理工具。

- 查看网卡的信息，FD全双工，HD半双工，Tx表示双绞线

```bash
# 简要信息
# mii-tool eth0
eth0: negotiated 1000baseT-FD flow-control, link ok #no link表示网线断了


# 详细信息
# mii-tool eth0 -v
eth0: negotiated 1000baseT-FD flow-control, link ok
  product info: Yukon 88E1011 rev 3
  basic mode:   autonegotiation enabled
  basic status: autonegotiation complete, link ok
  capabilities: 1000baseT-FD 100baseTx-FD 100baseTx-HD 10baseT-FD 10baseT-HD
  advertising:  1000baseT-FD 100baseTx-FD 100baseTx-HD 10baseT-FD 10baseT-HD
  link partner: 1000baseT-HD 1000baseT-FD 100baseTx-FD 100baseTx-HD 10baseT-FD 10baseT-HD
```

- "**eth0: negotiated 1000baseT-FD flow-control, link ok**"：这表示eth0以千兆速率（1000baseT）进行全双工通信（FD），并启用了流控制。此外，该行还指示链路状态正常（link ok）。
- "**product info: Yukon 88E1011 rev 3**"：这部分提供了以太网控制器的产品信息。根据输出，控制器型号为Yukon 88E1011，版本为3。
- "**basic mode: autonegotiation enabled**"：基本模式显示自动协商已启用。自动协商是一种以太网设备之间用于确定适当连接参数的过程，如速率、双工模式等。
- "**basic status: autonegotiation complete, link ok**"：基本状态显示自动协商已完成，并且链路状态正常。
- "**capabilities: 1000baseT-FD 100baseTx-FD 100baseTx-HD 10baseT-FD 10baseT-HD**"：此行列出了以太网接口支持的不同能力。根据输出，eth0支持1000兆速率的全双工（1000baseT-FD）、100兆速率的全双工（100baseTx-FD）、100兆速率的半双工（100baseTx-HD）、10兆速率的全双工（10baseT-FD）和10兆速率的半双工（10baseT-HD）。
- "**advertising: 1000baseT-FD 100baseTx-FD 100baseTx-HD 10baseT-FD 10baseT-HD**"：这部分显示以太网接口当前向对端设备宣告的支持能力。根据输出，eth0宣告支持1000兆速率的全双工、100兆速率的全双工、100兆速率的半双工、10兆速率的全双工和10兆速率的半双工。
- "**link partner: 1000baseT-HD 1000baseT-FD 100baseTx-FD 100baseTx-HD 10baseT-FD 10baseT-HD**"：这一部分显示与eth0相连的对端设备所宣告的支持能力。根据输出，对端设备宣告支持1000兆速率的半双工（1000baseT-HD）、1000兆速率的全双工、100兆速率的全双工、100兆速率的半双工、10兆速率的全双工和10兆速率的半双工。



##### 报错

```sh
# mii-tool eth0
SIOCGMIIPHY on 'eth0' failed: Operation not supported
```

在你提供的命令输出中，出现了 "SIOCGMIIPHY on 'eth0' failed: Operation not supported" 错误。这个错误通常表示 `mii-tool` 命令在你的系统中无法使用。

可能的原因是：

1. 你的系统可能使用了不支持 `mii-tool` 命令的网络接口驱动程序。`mii-tool` 命令通常用于管理和配置传统的以太网接口，但在某些情况下，特别是使用较新的网络接口或不同的驱动程序时，该命令可能不可用。
2. 你的系统可能使用了其他命令或工具来管理和配置网络接口。在较新的 Linux 发行版中，`ethtool` 命令通常用于替代 `mii-tool`，提供更多功能和支持更多网络接口。

**建议尝试使用 `ethtool` 命令来查看和配置以太网接口**。你可以使用以下命令来查看接口的状态：

```
ethtool eth0
```

请注意，具体的命令和选项可能因系统配置和网络接口的类型而有所不同。你可以参考操作系统的文档或使用 `man` 命令来获取更多关于 `ethtool` 命令的信息：

```
man ethtool
```

使用 `ethtool` 命令，你应该能够获取有关接口状态、速度、双工模式等的信息，并进行一些基本的网络接口配置。



## 网卡管理

### ip

- 以下配置皆为临时生效

#### 查看网卡状态

- 使用 `ip a` 或 `ip link` 都可以

##### 7

###### lo

```sh
[root@7 ~]# ip a show dev lo
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
```

根据你提供的命令输出，以下是关于回环接口 lo 的详细解释：

- "**1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000**"：这部分提供了有关接口的基本信息。"lo" 表示回环接口的名称。
  - "<LOOPBACK,UP,LOWER_UP>" 表示接口是回环接口，并且已经启用且处于活动状态。
  - "mtu 65536" 表示接口的最大传输单元大小为 65536 字节。
  - "qdisc noqueue" 表示没有定义用于队列调度的队列规则。
  - "state UNKNOWN" 表示接口的状态未知。
  - "group default qlen 1000" 表示接口所属的默认组和队列长度为 1000。
- "**link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00**"：这部分提供了关于接口的链路层信息。
  - "link/loopback" 表示接口类型为回环接口。
  - "00:00:00:00:00:00" 表示接口的链路层地址（MAC 地址）。
- "**inet 127.0.0.1/8 scope host lo**"：这部分提供了接口的 IPv4 地址信息。
  - "127.0.0.1/8" 表示接口的 IPv4 地址是 127.0.0.1，子网掩码为 8 位（255.0.0.0）。
  - "scope host" 表示该地址是一个本地主机地址，只能通过回环接口进行访问。
- "**inet6 ::1/128 scope host**"：这部分提供了接口的 IPv6 地址信息。
  - "::1/128" 表示接口的 IPv6 地址是 ::1，子网前缀长度为 128 位。
  - "scope host" 表示该地址是一个本地主机地址，只能通过回环接口进行访问。
- "**valid_lft forever preferred_lft forever**"：这部分提供了关于地址的生存期信息。
  - "valid_lft forever" 表示该地址的有效生存期是永久的，没有过期时间限制。
  - "preferred_lft forever" 表示该地址的优先生存期是永久的，没有过期时间限制。

通过这些输出信息，你可以了解回环接口 lo 的配置和地址信息。回环接口用于本地主机进行自我测试和通信，IPv4 地址为 127.0.0.1，IPv6 地址为 ::1。这些地址只能通过回环接口访问，并且具有永久的生存期。

###### eth0

```sh
[root@7 ~]# ip a show dev eth0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:e8:e9:b0 brd ff:ff:ff:ff:ff:ff
    inet 10.0.0.7/24 brd 10.0.0.255 scope global noprefixroute eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fee8:e9b0/64 scope link 
       valid_lft forever preferred_lft forever
```

根据你提供的命令输出，以下是关于以太网接口 eth0 的详细解释：

- "**2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000**"：这部分提供了有关接口的基本信息。"eth0" 表示以太网接口的名称。
  - "<BROADCAST,MULTICAST,UP,LOWER_UP>" 表示接口支持广播和多播，并且已经启用且处于活动状态。
  - "mtu 1500" 表示接口的最大传输单元大小为 1500 字节。
  - "qdisc pfifo_fast" 表示接口使用的队列调度算法是 pfifo_fast。
  - "state UP" 表示接口的状态为启用。
  - "group default qlen 1000" 表示接口所属的默认组和队列长度为 1000。
- "**link/ether 00:0c:29:e8:e9:b0 brd ff:ff:ff:ff:ff:ff**"：这部分提供了关于接口的链路层信息。
  - "link/ether" 表示接口类型为以太网。
  - "00:0c:29:e8:e9:b0" 表示接口的链路层地址（MAC 地址）。
- "**inet 10.0.0.7/24 brd 10.0.0.255 scope global noprefixroute eth0**"：这部分提供了接口的 IPv4 地址信息。
  - "10.0.0.7/24" 表示接口的 IPv4 地址是 10.0.0.7，子网掩码为 24 位（255.255.255.0）。
  - "brd 10.0.0.255" 表示接口的广播地址为 10.0.0.255。
  - "scope global" 表示该地址是一个全局地址，可在整个网络中使用。
  - "noprefixroute" 表示不使用任何前缀路由。
- "**inet6 fe80::20c:29ff:fee8:e9b0/64 scope link**"：这部分提供了接口的 IPv6 地址信息。
  - "fe80::20c:29ff:fee8:e9b0/64" 表示接口的 IPv6 地址是 fe80::20c:29ff:fee8:e9b0，子网前缀长度为 64 位。
  - "scope link" 表示该地址是一个链路本地地址，仅在链路范围内可用。
- "**valid_lft forever preferred_lft forever**"：这部分提供了关于地址的生存期信息。
  - "valid_lft forever" 表示该地址的有效生存期是永久的，没有过期时间限制。
  - "preferred_lft forever" 表示该地址的优先生存期是永久的，没有过期时间限制。

综上所述，接口 eth0 配置了一个 IPv4 地址为 10.0.0.7，子网掩码为 255.255.255.0，广播地址为 10.0.0.255。此外，该接口还具有一个 IPv6 链路本地地址 fe80::20c:29ff:fee8:e9b0/64。这些地址可以用于与网络中的其他设备进行通信。





##### 8

###### lo

```bash
[root@8 ~]# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP #DONW表示网线断了 group default qlen 1000
    link/ether 00:0c:29:1e:30:8b brd ff:ff:ff:ff:ff:ff
    inet 10.0.0.8/16 brd 10.0.255.255 scope global noprefixroute eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe1e:308b/64 scope link 
       valid_lft forever preferred_lft forever
```

#### 禁用网卡

```bash
ip link set 网卡名 down
```

#### 启用网卡

```bash
ip link set 网卡名 up
```



### ifconfig

ifconfig 命令默认显示的是目前活动的网卡地址，要显示全部活动与非活动网卡的地址需要加-a选项

#### 禁用网卡

```
ifconfig eth1 down
```

#### 启用网卡

```
ifconfig eth1 up 
```





















## IP 管理

### ip

**语法**

```bash
ip addr { add | del } IFADDR dev STRING [label LABEL] [scope {global|link|host}]
[broadcast ADDRESS]

# [label LABEL]：添加地址时指明网卡别名
# [scope {global|link|host}]：指明作用域,global: 全局可用，link: 仅链接可用，host: 本机可用
# [broadcast ADDRESS]：指明广播地址 
```

**范例**

```bash
# 给网卡增加新地址
ip {a|addr|address} {a|add} IP地址/子网掩码 dev 网卡名 [label eth0:label]


# 删除增加的地址
ip {a|addr|address} del IP地址/子网掩码 dev 网卡名


# 清空增加的地址
# 慎用！如果将正在远程连接的网卡ip删除将无法进行远程连接
ip {a|addr|address} flush dev 网卡名
```





### ifconfig

ifconfig 命令默认显示的是目前活动的网卡地址，要显示全部活动与非活动网卡的地址需要加-a选项

```bash
ifconfig eth1 IP/mask # 修改网卡的IP地址以及子网掩码

ifconfig eth1 0.0.0.0/0 # 临时清空地址（地址删除）

ifconfig eth1:alias IP/mask # 给网卡起别名，一个网卡就可以有多个地址了

ifconfig eth1:alias down # 删除网卡别名
```



## 网络 IO

ifconfig 命令默认显示的是目前活动的网卡地址，要显示全部活动与非活动网卡的地址需要加-a选项

### ifconfig

```sh
ifconfig -s # 查看网络流量等状态

# 输出说明：
MTU # 传输数据帧大小
RX # 接受
TX # 发送
```



## 端口

### ss

```bash
-n, --numeric       don't resolve service names   #不解析服务名称
-t, --tcp           display only TCP sockets   #只显示tcp的接口
-u, --udp           display only UDP sockets   #只显示udp的接口
-l, --listening     display listening sockets  #只显示正在监听的接口
-p, --processes     show process using socket  #展开正在使用的进程
```



### netstat

- 查看网络状态
- 功能和ss命令基本一致，但性能不及ss，生产中推荐使用ss命令

recv-Q 表示网络接收队列
表示收到的数据已经在本地接收缓冲，但是还有多少没有被进程取走，recv()
如果接收队列Recv-Q一直处于阻塞状态，可能是遭受了拒绝服务 denial-of-service 攻击。

send-Q 表示网路发送队列
对方没有收到的数据或者说没有Ack的,还是本地缓冲区.

```bash
-a #显示全部
-n #不解析名称

netstat -ntlpa

-r #查看路由表
```



## nmcli

- 依赖NetworkManager服务，此服务是管理和监控网络设置的守护进程

- help：

  - 官方文档：https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/configuring-an-ethernet-connection_configuring-and-managing-networking#configuring-a-static-ethernet-connection-using-nmcli_configuring-an-ethernet-connection

  - ```bash
    #查看指定选项的帮助
    nmcli con add help
    ```


- **注意：通过nmcli生成的配置文件可以作为参考，然后加以修改在进行使用**

### 查看网卡配置信息

#### 显示所有网卡配置信息

- 绿色表示目前属于活跃连接

```bash
# nmcli connection show 
NAME                UUID                                  TYPE      DEVICE 
eth0                5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03  ethernet  eth0   
Wired connection 1  2e80a002-50e8-3a14-a11e-4b9bebacdeed  ethernet  -- 

#每个连接配置信息都对应一个配置文件
# ls /etc/sysconfig/network-scripts/
ifcfg-eth0  ifcfg-Wired_connection_1

#每个配置文件中的NAME= 都对应前面命令输出中的NAME
# cat /etc/sysconfig/network-scripts/ifcfg-eth0 
DEVICE=eth0
NAME=eth0 #对应
IPADDR=10.0.0.38
PREFIX=16
BOOTPROTO=static
ONBOOT=yes
GATEWAY=10.0.0.2
# cat /etc/sysconfig/network-scripts/ifcfg-Wired_connection_1 
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=dhcp
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME="Wired connection 1" #对应
UUID=2e80a002-50e8-3a14-a11e-4b9bebacdeed
DEVICE=eth666
ONBOOT=yes
AUTOCONNECT_PRIORITY=-999
```

#### 显示目前所有活动连接

- 即所有显示绿色的连接

```bash
# nmcli con show --active
NAME  UUID                                  TYPE      DEVICE 
eth0  5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03  ethernet  eth0
```

#### 显示网络连接配置

- 此命令显示的非常详细

```bash
# nmcli con show eth0 
...

# nmcli con show Wired\ connection\ 1
...
```

#### 显示设备状态

```bash
# nmcli device 
DEVICE  TYPE      STATE      CONNECTION 
eth0    ethernet  connected  eth0       
lo      loopback  unmanaged  --     
```

#### 显示网络接口属性

```bash
# nmcli dev show eth0
GENERAL.DEVICE:                         eth0
GENERAL.TYPE:                           ethernet
GENERAL.HWADDR:                         00:0C:29:CC:63:39
GENERAL.MTU:                            1500
GENERAL.STATE:                          100 (connected)
GENERAL.CONNECTION:                     eth0
GENERAL.CON-PATH:                       /org/freedesktop/NetworkManager/ActiveConnection/4
WIRED-PROPERTIES.CARRIER:               on
IP4.ADDRESS[1]:                         10.0.0.38/16
IP4.GATEWAY:                            10.0.0.2
IP4.ROUTE[1]:                           dst = 10.0.0.0/16, nh = 0.0.0.0, mt = 100
IP4.ROUTE[2]:                           dst = 0.0.0.0/0, nh = 10.0.0.2, mt = 100
IP6.ADDRESS[1]:                         fe80::20c:29ff:fecc:6339/64
IP6.GATEWAY:                            --
IP6.ROUTE[1]:                           dst = ff00::/8, nh = ::, mt = 256, table=255
IP6.ROUTE[2]:                           dst = fe80::/64, nh = ::, mt = 256
```



### 修改网卡配置

#### 创建新连接

- **创建新连接default，IP自动通过dhcp获取**

```bash
# nmcli con add con-name test_default type Ethernet ifname eth0
Connection 'test_default' (fa843fcf-9435-444b-9b6c-122f28d4d1ae) successfully added.

#生成的配置信息
# nmcli connection show 
NAME          UUID                                  TYPE      DEVICE 
eth0          5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03  ethernet  eth0   
test_default  fa843fcf-9435-444b-9b6c-122f28d4d1ae  ethernet  --    #生成的

#生成的配置文件
# cat /etc/sysconfig/network-scripts/ifcfg-test_default 
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=dhcp #无dhcp场景可将此项删除在使用
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=test_default
UUID=fa843fcf-9435-444b-9b6c-122f28d4d1ae
DEVICE=eth0
ONBOOT=yes
```

- **创建新连接static ，指定静态IP，不自动连接**

```bash
# nmcli con add con-name test_static ifname eth0 autoconnect yes type ethernet ipv4.addresses 10.0.0.66/24 ipv4.gateway 10.0.0.88

#生成的配置信息
# nmcli connection show 
NAME          UUID                                  TYPE      DEVICE 
eth0          5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03  ethernet  eth0   
test_default  fa843fcf-9435-444b-9b6c-122f28d4d1ae  ethernet  --     
test_static   3b80000d-5064-4b08-a1a0-9bea812c3026  ethernet  --   #生成的

#生成的配置文件
#  cat /etc/sysconfig/network-scripts/ifcfg-test_static 
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=dhcp #如何
IPADDR=10.0.0.66
PREFIX=24
GATEWAY=10.0.0.88
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=test_static
UUID=0724c0c5-ab9a-4374-b52e-fb791bc63784
DEVICE=eth0
ONBOOT=yes
```

#### 启用连接

- **启用static连接配置**

```bash
nmcli con up test_static

#范例：
-----------------------------------------------------------------------------------------
#启动前
# nmcli device 
DEVICE  TYPE      STATE      CONNECTION 
eth0    ethernet  connected  eth0       
lo      loopback  unmanaged  --         
# nmcli connection show 
NAME          UUID                                  TYPE      DEVICE 
eth0          5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03  ethernet  eth0   
test_default  fa843fcf-9435-444b-9b6c-122f28d4d1ae  ethernet  --     
test_static   0724c0c5-ab9a-4374-b52e-fb791bc63784  ethernet  --     
# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         10.0.0.2        0.0.0.0         UG    100    0        0 eth0
10.0.0.0        0.0.0.0         255.255.0.0     U     100    0        0 eth0
# hostname -I
10.0.0.8
-----------------------------------------------------------------------------------------
#启动后
# nmcli con up test_static
# nmcli device 
DEVICE  TYPE      STATE      CONNECTION  
eth0    ethernet  connected  test_static #使用了
lo      loopback  unmanaged  --          
# nmcli connection show
NAME          UUID                                  TYPE      DEVICE 
test_static   0724c0c5-ab9a-4374-b52e-fb791bc63784  ethernet  eth0 #使用了  
eth0          5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03  ethernet  --     
test_default  fa843fcf-9435-444b-9b6c-122f28d4d1ae  ethernet  --     
# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         10.0.0.88       0.0.0.0         UG    100    0        0 eth0
10.0.0.0        0.0.0.0         255.255.255.0   U     100    0        0 eth0
10.0.0.0        0.0.0.0         255.255.255.0   U     100    0        0 eth0
# hostname -I
10.0.0.205 10.0.0.66
```

- **启用default连接配置**

```bash
nmcli con up test_default
```

#### 修改连接设置

```bash
nmcli con mod “static” connection.autoconnect no
nmcli con mod “static” ipv4.dns 172.25.X.254
nmcli con mod “static”  +ipv4.dns  8.8.8.8
nmcli con mod “static”  -ipv4.dns  8.8.8.8
nmcli con mod “static” ipv4.addresses “172.16.X.10/24  172.16.X.254”
nmcli con mod “static”  +ipv4.addresses 10.10.10.10/16

#DNS设置存放在/etc/resolv.conf，PEERDNS=no 表示当IP通过dhcp自动获取时，dns仍是手动设置，不自动获取等价于下面命令
nmcli con mod “system eth0” ipv4.ignore-auto-dns yes
```

#### 删除连接

- 本质上就是将其对应的配置文件删除

```bash
nmcli con del default

#范例：
# nmcli connection show 
NAME                UUID                                  TYPE      DEVICE 
eth0                5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03  ethernet  eth0   
Wired connection 1  2e80a002-50e8-3a14-a11e-4b9bebacdeed  ethernet  --     
# ls /etc/sysconfig/network-scripts/
ifcfg-eth0  ifcfg-Wired_connection_1
# nmcli connection delete Wired\ connection\ 1
Connection 'Wired connection 1' (2e80a002-50e8-3a14-a11e-4b9bebacdeed) successfully deleted.
# ls /etc/sysconfig/network-scripts/
ifcfg-eth0
```



### 重启网卡

```bash
nmcli c reload #重新加载网卡配置文件，c是connection的缩写

nmcli c up 网卡名NAME   #启用网卡
```



### 多网卡绑定

```bash
#添加bonding接口
nmcli con add type bond con-name mybond0 ifname bond0 mode active-backup
#添加从属接口
nmcli con add type bond-slave ifname ens7 master bond0
nmcli con add type bond-slave ifname ens3 master bond0
#注：如无为从属接口提供连接名，则该名称是接口名称加类型构成

#要启动绑定，则必须首先启动从属接口
nmcli con up bond-slave-eth0
nmcli con up bond-slave-eth1

#启动绑定
nmcli con up mybond0
```





## nc

号称网络界的瑞士军刀

- **查看端口是否被占用**

```bash
#语法
nc -l [-u] portnumber

--------------------------------------------------------------------------------

#范例
[root@aliyun ~]# nc -l 9527
Ncat: bind to 0.0.0.0:9527: Address already in use. QUITTING. #默认监听TCP协议

#udp未被占用，-u表示udp协议
[root@aliyun ~]# nc -l 9527 -u
[root@aliyun ~]# ss -nul|grep 9527
UNCONN    0         0                  0.0.0.0:9527             0.0.0.0:*       
UNCONN    0         0                     [::]:9527                [::]:*       
```

- **模仿通讯**

```bash
[root@8 ~]# nc -l 1111

[root@18 ~]# nc 10.0.0.8 1111
haha

[root@8 ~]# nc -l 1111
haha
```

- **探测目标IP的端口是否存在 或 是否能与对方端口连通**

```bash
# nc 8.140.166.135 80
hello
HTTP/1.1 400 Bad Request
Server: nginx
Date: Thu, 07 Apr 2022 07:11:38 GMT
Content-Type: text/html
Content-Length: 150
Connection: close

<html>
<head><title>400 Bad Request</title></head>
<body>
<center><h1>400 Bad Request</h1></center>
<hr><center>nginx</center>
</body>
</html>

# nc 8.140.166.135 9527
SSH-2.0-OpenSSH_8.0
```



## tc

- 流量控制工具
- 范例：

```bash
tc qdisc add dev eth0 root netem loss 50%
tc qdisc add dev eth0 root netem delay 1000ms
tc qdisc show dev eth0
tc qdisc del  
```













## nmap

- 安全扫描工具，扫描网络|网段中开放的端口，来自nmap包
- 扫描远程主机工具，功能远超越用世人皆知的 Ping 工具发送简单的 ICMP 回声请求报文
- 官方帮助：https://nmap.org/book/man.html

### 语法

```bash
nmap [Scan Type(s)] [Options] {target specification}
```

### 参数

```bash
-sT #TCP connect() 扫描，这是最基本的 TCP 扫描方式。这种扫描很容易被检测到，在目标主机的日志中会记录大批的连接请求以及错误信息    

-sS #TCP 同步扫描 (TCP SYN)，因为不必全部打开一个 TCP 连接，所以这项技术通常称为半开扫描(half-open)。这项技术最大的好处是，很少有系统能够把这记入系统日志   

-sF,-sX,-sN #秘密 FIN 数据包扫描、圣诞树 (Xmas Tree)、空 (Null) 扫描模式。这些扫描方式的理论依据是：关闭的端口需要对你的探测包回应 RST 包，而打开的端口必需忽略有问题的包    

-sP #ping 扫描，用 ping 方式检查网络上哪些主机正在运行。当主机阻塞 ICMP echo 请求包是ping 扫描是无效的。nmap 在任何情况下都会进行 ping 扫描，只有目标主机处于运行状态，才会进行后续的扫描    
-sU #UDP 的数据包进行扫描，想知道在某台主机上提供哪些 UDP 服务，可以使用此选项    

-sA #ACK 扫描，这项高级的扫描方法通常可以用来穿过防火墙。    

-sW #滑动窗口扫描，非常类似于 ACK 的扫描    

-sR #RPC 扫描，和其它不同的端口扫描方法结合使用。    

-b #FTP 反弹攻击 (bounce attack)，连接到防火墙后面的一台 FTP 服务器做代理，接着进行端口扫描。

-P0 #在扫描之前，不 ping 主机。

-PT #扫描之前，使用 TCP ping 确定哪些主机正在运行    

-PS #对于 root 用户，这个选项让 nmap 使用 SYN 包而不是 ACK 包来对目标主机进行扫描。    

-PI #设置这个选项，让 nmap 使用真正的 ping(ICMP echo 请求）来扫描目标主机是否正在运行。

-PB #这是默认的 ping 扫描选项。它使用 ACK(-PT) 和 ICMP(-PI) 两种扫描类型并行扫描。如果防火墙能够过滤其中一种包，使用这种方法，你就能够穿过防火墙。  

-O #这个选项激活对 TCP/IP 指纹特征 (fingerprinting) 的扫描，获得远程主机的标志，也就是操作系统类型

-I #打开 nmap 的反向标志扫描功能

-f #使用碎片 IP 数据包发送 SYN、FIN、XMAS、NULL。包增加包过滤、入侵检测系统的难度，使其无法知道你的企图    

-v #冗余模式。强烈推荐使用这个选项，它会给出扫描过程中的详细信息。    

-S <IP> #在一些情况下，nmap 可能无法确定你的源地址 。在这种情况使用这个选项给出指定 IP 地 址   

-g port #设置扫描的源端口

-oN #把扫描结果重定向到一个可读的文件 logfilename 中  

-oS #扫描结果输出到标准输出。    

--host_timeout #设置扫描一台主机的时间，以毫秒为单位。默认的情况下，没有超时限制    

--max_rtt_timeout #设置对每次探测的等待时间，以毫秒为单位。如果超过这个时间限制就重传或者超时。默认值是大约 9000 毫秒    

--min_rtt_timeout #设置 nmap 对每次探测至少等待你指定的时间，以毫秒为单位    

-M count #置进行 TCP connect() 扫描时，最多使用多少个套接字进行并行的扫描
```

### 范例

```bash
#扫描 203.90.146.0/24 网络里所有开放 8081端口的ip
nmap -p 8081 203.90.146.0/24


#Tcp ack 扫描，并发2000，速度快
nmap -n -PA --min-parallelism 2000 172.16.0.0/16  


#仅列出指定网段上的每台主机,不发送任何报文到目标主机.
[root@centos8 ~]#nmap -sL 10.0.0.0/24
Starting Nmap 7.70 ( https://nmap.org ) at 2020-04-23 12:28 CST
Nmap scan report for 10.0.0.0
Nmap scan report for 10.0.0.1
......
Nmap scan report for 10.0.0.254
Nmap scan report for 10.0.0.255
Nmap done: 256 IP addresses (0 hosts up) scanned in 1.04 seconds


#可以指定一个IP地址范围
[root@centos8 ~]#nmap -sP 10.0.0.1-10
Starting Nmap 7.70 ( https://nmap.org ) at 2020-04-23 12:30 CST
Nmap scan report for 10.0.0.1
Host is up (0.000081s latency).
MAC Address: 00:50:56:C0:00:08 (VMware)
Nmap scan report for 10.0.0.2
Host is up (0.00034s latency).
MAC Address: 00:50:56:F0:1E:25 (VMware)
Nmap scan report for 10.0.0.6
Host is up (0.00031s latency).
MAC Address: 00:0C:29:4D:EF:2C (VMware)
Nmap scan report for 10.0.0.7
Host is up (0.00036s latency).
MAC Address: 00:0C:29:29:F9:26 (VMware)
Nmap scan report for 10.0.0.8
Host is up.
Nmap done: 10 IP addresses (5 hosts up) scanned in 2.89 seconds


#批量扫描一个网段的主机存活数
nmap -sP -v 192.168.1.0/24
nmap –v –sn ip/24


#有些主机关闭了ping检测,所以可以使用-P0跳过ping的探测,可以加快扫描速度.
nmap -P0 192.168.1.100


#扫描主机
nmap –v –A IP  


#一次性扫描多台目标主机
[root@centos8 ~]#nmap 10.0.0.6 10.0.0.7
Starting Nmap 7.70 ( https://nmap.org ) at 2020-04-23 12:39 CST
Nmap scan report for 10.0.0.6
Host is up (0.00055s latency).
Not shown: 998 closed ports
PORT   STATE SERVICE
22/tcp open  ssh
111/tcp open rpcbind
MAC Address: 00:0C:29:4D:EF:2C (VMware)
Nmap scan report for 10.0.0.7
Host is up (0.00050s latency).
Not shown: 999 closed ports
PORT   STATE SERVICE
22/tcp open  ssh
MAC Address: 00:0C:29:29:F9:26 (VMware)
Nmap done: 2 IP addresses (2 hosts up) scanned in 101.01 seconds


#从一个文件中导入IP地址,并进行扫描
[root@centos8 ~]#cat hosts.txt 
10.0.0.7
10.0.0.6
58.87.87.99
[root@centos8 ~]#nmap -iL hosts.txt
Starting Nmap 7.70 ( https://nmap.org ) at 2020-04-23 12:43 CST
Nmap scan report for 10.0.0.7
Host is up (0.0024s latency).
Not shown: 999 closed ports
PORT   STATE SERVICE
22/tcp open  ssh
MAC Address: 00:0C:29:29:F9:26 (VMware)
Nmap scan report for 10.0.0.6
Host is up (0.0032s latency).
Not shown: 998 closed ports
PORT   STATE SERVICE
22/tcp open  ssh
111/tcp open rpcbind
MAC Address: 00:0C:29:4D:EF:2C (VMware)
Nmap scan report for 58.87.87.99
Host is up (0.016s latency).
Not shown: 998 filtered ports
PORT     STATE SERVICE
80/tcp   open http
3306/tcp open mysql
Nmap done: 3 IP addresses (3 hosts up) scanned in 120.33 seconds


#探测目标主机开放的端口,可指定一个以逗号分隔的端口列表(如-PS22,443,80)
[root@centos8 ~]#nmap -PS22,80,443 10.0.0.1
Starting Nmap 7.70 ( https://nmap.org ) at 2020-04-23 12:31 CST
Nmap scan report for 10.0.0.1
Host is up (0.00042s latency).
Not shown: 996 filtered ports
PORT     STATE SERVICE
135/tcp open msrpc
139/tcp open netbios-ssn
445/tcp open microsoft-ds
8082/tcp open blackice-alerts
MAC Address: 00:50:56:C0:00:08 (VMware)
Nmap done: 1 IP address (1 host up) scanned in 12.65 seconds


#使用SYN半开放扫描
[root@centos8 ~]#nmap -sS 10.0.0.1
Starting Nmap 7.70 ( https://nmap.org ) at 2020-04-23 12:33 CST
Nmap scan report for 10.0.0.1
Host is up (-0.052s latency).
Not shown: 996 filtered ports
PORT     STATE SERVICE
135/tcp open msrpc
139/tcp open netbios-ssn
445/tcp open microsoft-ds
8082/tcp open blackice-alerts
MAC Address: 00:50:56:C0:00:08 (VMware)
Nmap done: 1 IP address (1 host up) scanned in 10.07 seconds


#扫描开放了TCP端口的设备
[root@centos8 ~]#nmap -sT 10.0.0.1
Starting Nmap 7.70 ( https://nmap.org ) at 2020-04-23 12:34 CST
Nmap scan report for 10.0.0.1
Host is up (0.00040s latency).
Not shown: 996 filtered ports
PORT     STATE SERVICE
135/tcp open msrpc
139/tcp open netbios-ssn
445/tcp open microsoft-ds
8082/tcp open blackice-alerts
MAC Address: 00:50:56:C0:00:08 (VMware)
Nmap done: 1 IP address (1 host up) scanned in 4.52 seconds


#扫描开放了UDP端口的设备
[root@centos8 ~]#nmap -sU 10.0.0.1
Starting Nmap 7.70 ( https://nmap.org ) at 2020-04-23 12:34 CST
Nmap scan report for 10.0.0.1
Host is up (0.00046s latency).
Not shown: 999 open|filtered ports
PORT   STATE SERVICE
137/udp open netbios-ns
MAC Address: 00:50:56:C0:00:08 (VMware)
Nmap done: 1 IP address (1 host up) scanned in 18.52 seconds


#只扫描UDP端口
nmap –e eth1 -sU -O 10.0.0.1  


#扫描TCP和UDP端口
nmap -sTU -O 10.0.0.1  


#用于扫描目标主机服务版本号
[root@centos8 ~]#nmap -sV 10.0.0.7
Starting Nmap 7.70 ( https://nmap.org ) at 2020-04-23 12:37 CST
Nmap scan report for 10.0.0.7
Host is up (0.0011s latency).
Not shown: 999 closed ports
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.4 (protocol 2.0)
MAC Address: 00:0C:29:29:F9:26 (VMware)
Service detection performed. Please report any incorrect results at 
https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 1.97 seconds


#查看主机当前开放的端口
nmap localhost    


#查看主机端口（1024-65535）中开放的端口
nmap -p 1024-65535 localhost  


#探测目标主机开放的端口
nmap -PS 10.0.0.1   


#探测所列出的目标主机端口
nmap -PS22,80,3306 10.0.0.1  


#探测目标主机操作系统类型
nmap -O 10.0.0.1


#探测目标主机操作系统类型
nmap -A 10.0.0.1
```



## tcpreplay

`tcpreplay` 是一个开源工具，用于在计算机网络中重放网络数据包。它允许用户将预先捕获的网络流量重新发送到网络中，以便在测试、调试或分析网络设备和应用程序时使用。以下是 `tcpreplay` 命令的详解：

```
tcpreplay [options] <pcap_file(s)>
```

**选项：**

- `-i <interface>`：指定要发送数据包的网络接口。
- `-l <loop count>`：指定要重复发送数据包的次数。
- `-t`：启用时间戳模式，将数据包发送到网络时保留原始时间戳。
- `-K`：启用统计模式，显示有关数据包发送的统计信息。
- `-P`：启用混合模式，在发送数据包之前暂停一段时间，以模拟实际网络流量的间隔。
- `-D <delay>`：设置混合模式的延迟时间（以微秒为单位）。
- `-c`：指定发送数据包的速率（每秒发送的数据包数量）。
- `-Q`：启用快速模式，禁用数据包发送之间的睡眠时间。
- `-M <MTU>`：设置最大传输单元 (MTU) 大小。
- `-x <percent>`：指定要发送数据包的百分比。
- `-T <time>`：设置发送数据包的持续时间。

**示例用法：**

1. 将单个 pcap 文件重放到网络接口：

   ```
   tcpreplay -i eth0 packet.pcap
   ```

2. 重复发送 pcap 文件到网络接口 10 次：

   ```
   tcpreplay -i eth0 -l 10 packet.pcap
   ```

3. 在混合模式下以 1Mbps 的速率发送 pcap 文件：

   ```
   tcpreplay -i eth0 -P -c 1000 packet.pcap
   ```

4. 启用时间戳模式并显示发送统计信息：

   ```
   cssCopy code
   tcpreplay -i eth0 -t -K packet.pcap
   ```













# 其它命令

## dd

格式：dd if(源) of(目标) bs(块大小) count(块数量) seek(跳过目标的块数量)  skip(跳过源的块数量)



## lastb

lastb 可以查看登录终端失败的信息

```bash
lastb # 可以查看登录终端失败的信息
 
/var/log/btmp # 登录失败的信息放置于此文件

lastb -f file # 查看登录失败的文件信息
```



## hostnamectl

- `hostnamectl` 命令可以实现修改主机名

- 主机名存放目录：`/etc/hostname`

```bash
# 永久修改主机名
hostnamectl set-hostname azheng
```



## watch

- 按照设定的时间间隔来执行cmd并监视执行结果

```sh
# 每秒钟查看一个命令的执行结果（每1秒钟执行一次ls -l /data/）
watch -n1 ls -l /data/

# 每秒钟执行依次ls -l 命令，并监视执行结果
watch -n1 ls -l /data/backup/

# 每0.1秒执行依次ls -l 命令，并监视执行结果
watch -n0.1 ls -l /data/backup/
```



## ls

```bash
#查看目录下的所有目录
ls -d /etc/*/

#查看目录下的所有隐藏文件
ls -d .[^.]*
```





## echo

```bash
# 不换行
echo -e "haha\c"
```





## histroy

```bash
[root@centos ~]# echo "HISTTIMEFORMAT='%F %T '" >> ~/.bashrc
[root@centos ~]# HISTTIMEFORMAT='%F %T '
[root@centos ~]# export HISTTIMEFORMAT

#或者
[root@centos ~]# echo "HISTTIMEFORMAT='%F %T '" >> ~/.bashrc
[root@centos ~]# . ~/.bashrc
```



## wget

```bash
# 解决wget报错ERROR: The certificate of ‘xxxxx’ is not trusted
--no-check-certificate #不验证服务器证书
```

- 下载整个目录

```bash
wget -r -np -nH -R index.html www.localyum.com/BaseOS/

#各个参数的含义：
-r : 遍历所有子目录
-np : 不到上一层子目录去
-nH : 不要将文件保存到主机名文件夹
-R index.html : 不下载 index.html 文件
```





---

# 网络管理
## fping
- 快速扫描在线/离线IP
```sh
# 只显示在线的主机，-g后面跟要扫描的网段
fping -a -g 172.16.0.0/24 2>/dev/null

# 只显示不在线的主机，-g后面跟要扫描的网段
fping -u -g 172.16.0.0/24 2>/dev/null
```

## ip
```sh
ip -br a # 查看所有网卡的简略信息
```

## mtr
- 路由追踪

## nc
- 网络瑞士军刀

监听TCP端口：
```sh
nc -knl 35793 # 监听在所有IP
nc -knl 172.31.25.128 35793 # 监听在指定IP
```

# 其他
## tmux
- 保持会话
**1. 基本使用流程：**
```sh
# 启动新会话
tmux # 方法一
tmux new -s mysession # 方法二，mysession 是会话名字，可自由替换。

# 脱离会话（让任务继续在后台跑）
Ctrl + b，然后松开，按 d

# 恢复会话
tmux attach -t mysession

# 查看所有会话
tmux ls

# 关闭会话
直接在 tmux 中执行 exit，或者执行 tmux kill-session -t mysession
```

**2. 窗口和分屏操作：**
```sh
# 新建窗口（像标签页）：
Ctrl + b，然后按 c

# 切换窗口
Ctrl + b，然后按 n（下一个），Ctrl + b，然后按 p（上一个）

# 垂直分屏
Ctrl + b 然后按 %

# 水平分屏
Ctrl + b 然后按双引号

# 切换面板焦点
Ctrl + b 然后按方向键（←↑↓→）
```

## nohup
- 让程序置于后台运行



## 111
```sh
# 用户管理
chown
usermod
groups

# xxx
ls
pwd
chmod
chown
poweroff
reboot
df
du
lsblk
blkid
mount
lvm
dd
top
htop
btop
iotop
lsof
ip
traceroute
tcpdump
telnet
nc
ss
nethogs
dig
nslookup
mtr
netplan
vim
vimdiff
nano
more
less
wc
head
tail
date
timedatectl
hostnamectl
stress
lspci
lscpu
ethtool
w

jq
yq
```