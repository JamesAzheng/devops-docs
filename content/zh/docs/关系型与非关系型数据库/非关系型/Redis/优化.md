---
title: "优化"
---

# 解决redis启动后的三个报警信息

### tcp-backlog

```bash
#默认最大等待队列数量为128，值较低，建议优化

#在日志中可以看到此报警信息
[root@centos8 ~]#tail -f /var/log/redis/redis.log
WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
[root@centos8 ~]#cat /proc/sys/net/core/somaxconn
128

#优化方法：修改内核参数
[root@centos8 ~]$echo net.core.somaxconn = 1024 >> /etc/sysctl.conf
[root@centos8 ~]$sysctl -p
net.core.somaxconn = 1024

#或者把redis中的默认值调成低于128，只起到不会报警的作用
[root@centos8 ~]$grep backlog /etc/redis.conf
# TCP listen() backlog.
# In high requests-per-second environments you need an high backlog in order
# make sure to raise both the value of somaxconn and tcp_max_syn_backlog
tcp-backlog 511
```

### vm.overcommit_memory

```bash
WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.

#优化方法：修改内核参数
[root@centos8 ~]$echo vm.overcommit_memory = 1 >> /etc/sysctl.conf
[root@centos8 ~]$sysctl -p
net.core.somaxconn = 1024
vm.overcommit_memory = 1

#vm.overcommit_memory内核参数说明
0：表示内核将检查是否有足够的可用内存空间供应用进程使用，如果有足够的可用内存，内存申请允许，否则，内存申请失败，并把错误返回给应用进程
1：表示内核允许分配所有的物理内存，而不管当前的内存状态如何
2：表示内核允许分配超过所有物理内存和交换空间总和的内存
```

### Transparent Huge Pages

```bash
WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.

#解决办法
[root@centos8 ~]$echo 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' >> /etc/rc.d/rc.local 
[root@centos8 ~]$chmod +x /etc/re.d/rc.local
[root@centos8 ~]$bash /etc/rc.d/rc.local
```



# 禁用危险操作

```bash
[root@aliyun ~]# vim /etc/redis.conf
rename-command KEYS ""
rename-command FLUSHALL ""
rename-command FLUSHDB ""
#或者改成别名
rename-command KEYS "xxx"
rename-command FLUSHALL "xxx"
rename-command FLUSHDB "xxx"
```



# 主从复制优化

**避免全量复制**

- 第一次全量复制不可避免，后续的全量复制可以利用小主节点(内存小)，业务低峰时进行全量
- 节点运行ID不匹配：主节点重启会导致运行ID变化，可能会触发全量复制，可以利用故障转移，例如哨兵或集群 
- 复制积压缓冲区不足：将 repl-backlog-size 值调大

**避免复制风暴**

- 单主节点复制风暴
- 当主节点重启，多从节点复制
- **解决方法：更换复制拓扑**（一主带多从变成一主一从 一从再带多从）

**避免单机复制风暴**

- 机器宕机后，大量全量复制

- **解决方法：主节点分散多机器**

  假设A机器多实例全部为主，B机器多实例全部为从，A机器如果宕机runid则会改变，会导致大量的全量复制产生

  如果将A机器和B机器平均分散的分配主和从的话会减轻全量复制的压力



# Redis 慢查询优化

- 慢查询发生在执行命令阶段，在这之前还有客户端发送命令 redis排队执行 以及redis返回结果阶段
- 所以 比如说客户端超时不一定慢查询，但慢查询是客户端超时的一个可能因素

```bash
[root@8 ~]# grep slowlog /apps/redis/etc/redis.conf 
slowlog-log-slower-than 10000 #超时时间多久记录慢查询，微秒为单位，10000微秒=10毫秒
slowlog-max-len 128 #慢查询日志记录的条数，生产中建议调大，如：1024

127.0.0.1:6379> SLOWLOG LEN #查看慢查询记录的条数
(integer) 0

127.0.0.1:6379> SLOWLOG get [n] #查看慢查询日志的n条记录

127.0.0.1:6379> SLOWLOG RESET #清空慢查询日志的记录
```





Redis的慢查询可以通过设置slowlog-log-slower-than参数来进行优化，该参数用于设置慢查询阈值，单位为微秒。

通常建议将慢查询阈值设置为1000微秒（即1毫秒）左右，这个值可以根据具体的业务场景和系统负载情况进行适当的调整。

设置慢查询阈值可以通过修改Redis的配置文件来完成，常见的配置文件为/etc/redis/redis.conf，在该文件中可以设置以下参数来设置慢查询阈值：

```
slowlog-log-slower-than 1000
```

其中，slowlog-log-slower-than参数表示设置慢查询阈值为1000微秒。

需要注意的是，Redis的慢查询日志功能默认是关闭的，需要手动开启。可以通过以下命令来开启：

```sh
config set slowlog-max-len 1000 # 设置慢查询日志最大长度
config set slowlog-log-slower-than 1000 # 设置慢查询阈值
config set slowlog-get 1 # 开启慢查询日志功能
```

以上命令可以开启慢查询日志功能，并设置慢查询阈值和最大长度，具体的参数值需要根据实际情况进行调整。





# 用redis用户运行redis

- **redis进程要以redis身份运行，不要以root身份运行**

```bash
#设置成root身份运行的话可能会导致黑客通过修改dir的方式从root家目录中的.ssh目录中的auth文件导入公钥，从而间接的登录root
[root@aliyun ~]# ps -ef |grep redis
redis      38189       1  0 14:05 ?        00:00:00 /usr/bin/redis-server 127.0.0.1:6379
```

# redis登录要设置密码



# 给redis的内存

```bash
# maxmemory <bytes>
redis使用的最大内存，单位为bytes字节，0为不限制，建议设置为物理内存的一半，需要注意的是缓冲区是不计算maxmemory内，生产中如果不设置此项，可能会导致OOM（内存满后乱杀进程）
#8G内存的计算方式：8(G)*1024(MB)*1024(KB)*1024(bytes)/2
#1G内存的计算方式：echo 2^20*1024/2|bc
```

