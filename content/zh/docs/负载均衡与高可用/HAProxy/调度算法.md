---
title: "调度算法"
---

# 前言

- HAproxy 通过 balance 来定义使用的负载均衡算法，该参数可以配置在 defaults、listen、backend 段中
- HAproxy 的调度算法分为静态和动态调度算法，但是有些算法可以根据参数在静态和动态算法中相互转换
- 官方文档：http://cbonte.github.io/haproxy-dconv/2.0/configuration.html#4.2-balance



# 静态算法

- 按照实现定义的规则进行轮询公平调度，**不关心后端服务器的当前负载、连接数和响应速度等**
- **socat命令在静态算法中只支持动态上线和下线(0%和100%)，不支持动态权重调整及后端服务器慢启动**
- 动态调整权重只能使用reload将haproxy重新加载

## static-rr 静态加权轮询

- 基于权重轮询调度，对后端主机数量没有限制，相当于LVS中的wrr
- 支持修改配置文件权重项后重启haproxy使其生效

### 范例：使用static-rr调度

```bash
#haproxy
[root@haproxy ~]# vim /apps/haproxy/etc/conf.d/xiangzheng.vip.cfg
listen xiangzheng_vip_80
    mode http
    bind 192.168.0.200:80
    balance static-rr #定义
    server web1 10.0.0.38:80 check
    server web2 10.0.0.48:80 check

------------------------------------------------------------------------------

#client
#测试 默认不加权重比例1:1
[root@client ~]# while true ;do curl 192.168.0.200;sleep 0.5 ;done
web1.xiangzheng.vip page
web1.xiangzheng.vip page
web2.xiangzheng.vip page
web2.xiangzheng.vip page
```

### 范例：重新加载haproxy实现权重修改

```bash
#haproxy
#定义
[root@haproxy ~]# vim /apps/haproxy/etc/conf.d/xiangzheng.vip.cfg
listen xiangzheng_vip_80
    mode http
    bind 192.168.0.200:80
    balance static-rr
    server web1 10.0.0.38:80 check weight 1
    server web2 10.0.0.48:80 check weight 3
#重新加载service
[root@haproxy ~]# systemctl reload haproxy.service 

------------------------------------------------------------------------------

#client
#测试 比例1:3
[root@client ~]# while true ;do curl 192.168.0.200;sleep 0.5 ;done
web1.xiangzheng.vip page
web1.xiangzheng.vip page
web2.xiangzheng.vip page
web2.xiangzheng.vip page
web2.xiangzheng.vip page
web2.xiangzheng.vip page
web2.xiangzheng.vip page
web2.xiangzheng.vip page
```

### 范例：使用socat动态上下线

```bash
#修改权重前 比例1:3
[root@client ~]# while true ;do curl 192.168.0.200;sleep 0.5 ;done
web1.xiangzheng.vip page
web1.xiangzheng.vip page
web2.xiangzheng.vip page
web2.xiangzheng.vip page
web2.xiangzheng.vip page
web2.xiangzheng.vip page
web2.xiangzheng.vip page
web2.xiangzheng.vip page
[root@haproxy ~]# vim /apps/haproxy/etc/conf.d/xiangzheng.vip.cfg
listen xiangzheng_vip_80
    mode http
    bind 192.168.0.200:80
    balance static-rr
    server web1 10.0.0.38:80 check weight 1 #1
    server web2 10.0.0.48:80 check weight 3 #3

#socat修改权重，不支持运行时利用socat进行权重的动态调整(只支持0%和100% 不支持其他值)
[root@haproxy ~]# echo "set weight xiangzheng_vip_80/web2 1" | socat stdio /apps/haproxy/run/haproxy.sock
Backend is using a static LB algorithm and only accepts weights '0%' and '100%'.

#socat修改权重为0，即下线
[root@haproxy ~]# echo "set weight xiangzheng_vip_80/web2 0" | socat stdio /apps/haproxy/run/haproxy.sock

#0表示下线，那么就只能调度到web1上面了
[root@client ~]# while true ;do curl 192.168.0.200;sleep 0.5 ;done
web1.xiangzheng.vip page
web1.xiangzheng.vip page
web1.xiangzheng.vip page

#socat修改权重为100%，即恢复上线
[root@haproxy ~]# echo "set weight xiangzheng_vip_80/web2 100%" | socat stdio /apps/haproxy/run/haproxy.sock

#恢复上线
[root@client ~]# while true ;do curl 192.168.0.200;sleep 0.5 ;done
web1.xiangzheng.vip page
web2.xiangzheng.vip page
web2.xiangzheng.vip page
web2.xiangzheng.vip page
```

## first

- 根据服务器在列表中的位置，自上而下进行调度，但是其只会当第一台服务器的连接数达到设定的阈值时才会将请求分发给下一台server，因此会忽略server的权重，**生产中使用较少**
- 并且不设置阈值的话那就表示请求只会分发给第一台server

### 范例：使用first调度

```bash
[root@haproxy ~]# vim /apps/haproxy/etc/conf.d/xiangzheng.vip.cfg
listen xiangzheng_vip_80
    mode http
    bind 192.168.0.200:80
    balance first #定义
    server web1 10.0.0.38:80 check 
    server web2 10.0.0.48:80 check
    
#测试
[root@client ~]# while true ;do curl 192.168.0.200;sleep 0.5 ;done
web1.xiangzheng.vip page
web1.xiangzheng.vip page
web1.xiangzheng.vip page
web1.xiangzheng.vip page
```



# 动态算法

- 基于后端服务器的状态进行动态调度，且**权重可以在haproxy运行时动态调整 无需重启或重新加载**，**支持socat对haproxy进行动态权重调整**

## roundrobin 动态加权轮询

- roundrobin 是基于权重的轮询动态调度算法，也是**默认调度算法，也是生产中最常用的调度算法**
- 此调度算法还支持慢启动(新加的服务器会逐渐增加转发次数)
- 但是每个后端backend中最多只支持4095个real server 但这通常也不是问题

### 范例：使用roundrobin调度

```bash
#haproxy
[root@haproxy ~]# vim /apps/haproxy/etc/conf.d/xiangzheng.vip.cfg
listen xiangzheng_vip_80
    mode http
    bind 192.168.0.200:80
    balance roundrobin #定义
    server web1 10.0.0.38:80 check
    server web2 10.0.0.48:80 check

------------------------------------------------------------------------------

#client
#测试 默认不加权重比例1:1
[root@client ~]# while true ;do curl 192.168.0.200;sleep 0.5 ;done
web1.xiangzheng.vip page
web2.xiangzheng.vip page
```

### 范例：重新加载haproxy实现权重修改

```bash
#haproxy
#定义
[root@haproxy ~]# vim /apps/haproxy/etc/conf.d/xiangzheng.vip.cfg
listen xiangzheng_vip_80
    mode http
    bind 192.168.0.200:80
    balance static-rr
    server web1 10.0.0.38:80 check weight 1
    server web2 10.0.0.48:80 check weight 3
#重新加载service
[root@haproxy ~]# systemctl reload haproxy.service 

------------------------------------------------------------------------------

#client
#测试 比例1:3
[root@client ~]# while true ;do curl 192.168.0.200;sleep 0.5 ;done
web1.xiangzheng.vip page
web2.xiangzheng.vip page
web2.xiangzheng.vip page
web2.xiangzheng.vip page
```

### 范例：使用socat实现动态权重修改

```bash
#修改权重前 比例1:3
[root@client ~]# while true ;do curl 192.168.0.200;sleep 0.5 ;done
web1.xiangzheng.vip page
web2.xiangzheng.vip page
web2.xiangzheng.vip page
web2.xiangzheng.vip page
[root@haproxy ~]# vim /apps/haproxy/etc/conf.d/xiangzheng.vip.cfg
listen xiangzheng_vip_80
    mode http
    bind 192.168.0.200:80
    balance roundrobin
    server web1 10.0.0.38:80 check weight 1 #1
    server web2 10.0.0.48:80 check weight 3 #3

#socat修改权重为1
[root@haproxy ~]# echo "set weight xiangzheng_vip_80/web2 1" | socat stdio /apps/haproxy/run/haproxy.sock


#修改权重前 比例1:1
[root@client ~]# while true ;do curl 192.168.0.200;sleep 0.5 ;done
web1.xiangzheng.vip page
web2.xiangzheng.vip page
```



## leastconn 加权最少连接

- 将客户端新发起的连接 调度到连接数最少的后端real server
- 支持权重动态调整和慢启动
- 比较适合长连接的场景使用，如：MySQL等场景

```bash
listen xiangzheng_vip_80
    mode http
    bind 192.168.0.200:80
    balance roundrobin #定义
    server web1 10.0.0.38:80 check
    server web2 10.0.0.48:80 check
```



## random

- 1.9版本新增加的动态调度算法，其基于随机数作为一致性hash的key
- random负载均衡对于大型IDC机房或经常添加或删除服务器非常有用
- 支持权重动态调整

### 范例：使用random调度

```bash
listen xiangzheng_vip_80
    mode http
    bind 192.168.0.200:80
    balance random #定义
    server web1 10.0.0.38:80 check
    server web2 10.0.0.48:80 check
```





# 其他算法

- 其他算法即可作为静态算法，又可以通常选项成为动态算法

## source 源地址hash

- **生产中使用较少，因为目前用户主要是通过SNAT的方式进行上网 即多个用户使用同一个公网IP，这样会导致同一个局域网中的多个用户同时访问时出现问题**

- 基于用户源地址做hash运算 并将请求转发给real server，后续同一个源地址请求将被分发至同一个real server
- 此方式当后端服务器数量发生变化时，会导致很多用户的请求被分发到新的服务器
- 默认为静态方式，但是可以通过hash-type支持的选项更改
- **这个算法一般是在不插入Cookie的TCP模式下使用，也可给拒绝会话Cookie的客户提供最好的会话粘性，适用于session会话保持但不支持cookie和缓存的场景**
- 源地址有两种转发客户端请求到后端服务器的服务器选取计算方式，分别是取模法和一致性hash
- 源地址hash有两种计算方式 分别是 取模法和一致性hash：

### map-base 取模法

- **对source地址进行hash计算，再基于服务器总权重取模**，最终结果决定将此请求转发至对应的后端服务器
- **不支持动态调整权重，只支持动态上下线**
- hash-type 指定的默认值为此算法，可以进行修改

```ABAP
取模运算就是计算两个数相除后的余数: 10%7=3 7%3=1

map-based算法 基于权重取模：hash(source_ip)%所有后端服务器的权重相加之合
```

#### 范例：使用map-base调度

```bash
listen xiangzheng_vip_80
    mode http
    bind 192.168.0.200:80
    balance source #定义
    hash-type map-base #选择计算方式
    server web1 10.0.0.38:80 check
    server web2 10.0.0.48:80 check
```

### consistent 一致性hash

- 当服务器的总权重发生变化时，对调度结果的影响是局部的 不会引起大的变动
- **支持动态调整权重 和 慢启动**

#### 算法：

```ABAP
1：key1=hash(source_ip)%(2^32) [0---4294967295]
2：keyA=hash(后端服务器虚拟ip)%(2^32)
3：将key1和keyA都放在hash环上，将用户请求调度到离key1最近的keyA对应的后端服务器
```

#### bash环偏斜问题：

```ABAP
增加虚拟服务器IP数量，比如：一个后端服务器根据权重为1生成1000个虚拟IP，再hash。而后端服务器权重为2则生成2000的虚拟IP，再bash，最终在hash环上生成3000个节点，从而解决hash环偏斜的问题
```

#### 范例：使用consistent调度

```bash
listen xiangzheng_vip_80
    mode http
    bind 192.168.0.200:80
    balance source #定义
    hash-type consistent #选择计算方式
    server web1 10.0.0.38:80 check
    server web2 10.0.0.48:80 check
```



## uri

- 基于对用户请求的uri左半部分或整个uri做hash，再将hash结果对总权重进行取模后，根据最终结果将请求转发到后端指定的服务器
- 适用于后端是缓存服务器的场景
- 默认是静态算法，也可以通过hash-type指定map-based和consistent，来定义使用取模法还是一致性hash

### uri说明：

```bash
https://blog.csdn.net/122030128?utm_medium #整个URL

/122030128?utm_medium #整个URI

/122030128 #左半部分URI
```

### uri取模法配置范例

```bash
listen xiangzheng_vip_80
    mode http
    bind 192.168.0.200:80
    balance uri #定义uri调度法，不定义则默认使用uri取模法
    server web1 10.0.0.38:80 check
    server web2 10.0.0.48:80 check
```

### uri取一致性hash配置范例

```bash
listen xiangzheng_vip_80
    mode http
    bind 192.168.0.200:80
    balance uri #定义uri调度法
    hash-type consistent #定义一致性bash计算方式
    server web1 10.0.0.38:80 check
    server web2 10.0.0.48:80 check
```

### 范例：使用uri取模法调度

```bash
#haproxy定义
[root@haproxy ~]# vim /apps/haproxy/etc/conf.d/xiangzheng.vip.cfg
listen xiangzheng_vip_80
    mode http
    bind 192.168.0.200:80
    balance uri #定义uri调度法，不定义则默认使用uri取模法
    server web1 10.0.0.38:80 check
    server web2 10.0.0.48:80 check
    
----------------------------------------------------------------------------

#client测试，访问相同的uri则调度到相同的real server
[root@client ~]#curl 192.168.0.200/test1.html
web1.xiangzheng.vip page
[root@client ~]#curl 192.168.0.200/test2.html
web2.xiangzheng.vip page
```



## url_param

- 对用户请求的uri中的params部分中的一个参数key对应的value值做hash计算，并由服务器总权重相除以后派发至某挑出来的服务器
- 通常用于追踪用户，以确保来自同一个用户的请求始终发往同一个real server，如果无key 则按roundrobin算法

### url_param说明

```bash
#假设：
https://www.xiangzheng.vip/app/post.php?key=value

#则：
host = "www.xiangzheng.vip"
uri_param = "key=value"
```

### url取模法配置范例

```bash
listen xiangzheng_vip_80
    mode http
    bind 192.168.0.200:80
    balance url_param userid #定义url_param调度法，userid为key，不定义则默认使用uri取模法
    server web1 10.0.0.38:80 check
    server web2 10.0.0.48:80 check
```

### url取一致性hash配置范例

```bash
listen xiangzheng_vip_80
    mode http
    bind 192.168.0.200:80
    balance url_param userid #定义url_param调度法，userid为key
    hash-type consistent #定义一致性bash计算方式
    server web1 10.0.0.38:80 check
    server web2 10.0.0.48:80 check
```

### 测试访问：

```bash
[root@client ~]# curl 192.168.0.200/index.html?userid=<NAME_ID>
[root@client ~]# curl 192.168.0.200/index.html?userid=<NAME_ID>&typeid=<TYPE_ID>
```



## hdr

- 针对用户每个http头部(header)请求中的指定信息做hash，此处由name指定的http首部将会被取出并做hash计算，然后由服务器总权重取模以后派发至某挑出的服务器，如果无有效值，则会使用默认的轮询调度

### hdr取模法配置范例

```bash
listen xiangzheng_vip_80
    mode http
    bind 192.168.0.200:80
    balance hdr(User-Agent) #定义hdr调度法，并将User-Agent做哈希运算
    #balance hdr(host)
    server web1 10.0.0.38:80 check
    server web2 10.0.0.48:80 check
```

### hdr取一致性hash配置范例

```bash
listen xiangzheng_vip_80
    mode http
    bind 192.168.0.200:80
    balance hdr(User-Agent) #定义hdr调度法，并将User-Agent做哈希运算
    hash-type consistent #定义一致性bash计算方式
    server web1 10.0.0.38:80 check
    server web2 10.0.0.48:80 check
```

### 测试访问：

- 不同的请求报文头部会返回不同的页面

```bash
[root@client ~]# curl -V 192.168.0.200/index.html
[root@client ~]# curl -VA 'Firefox' 192.168.0.200/index.html
[root@client ~]# curl -VA 'Chrome' 192.168.0.200/index.html
```



## rdp-cookie

- rdp-cookie可以对远程windows桌面进行调度，使用cookie保持回话，默认是静态，也可以通过hash-type指定map-base和consistent，来定义使用取模法还是一致性hash
- 只能使用tcp协议

### hdr取模法配置范例

```bash
listen xiangzheng_vip_80
    mode tcp #使用tcp协议
    bind 192.168.0.200:80
    balance rdp-cookie #定义rdp-cookie调度法
    server web1 10.0.0.38:80 check
    server web2 10.0.0.48:80 check
```

### hdr取一致性hash配置范例

```bash
listen xiangzheng_vip_80
    mode tcp #使用tcp协议
    bind 192.168.0.200:80
    balance rdp-cookie #定义rdp-cookie调度法
    hash-type consistent #定义一致性bash计算方式
    server web1 10.0.0.38:80 check
    server web2 10.0.0.48:80 check
```



# 调度算法总结

```bash
#静态
static-rr  ---> tcp/http
first      ---> tcp/http

#动态
roundrobin ---> tcp/http
leastconn  ---> tcp/http
random     ---> tcp/http

#以下静态和动态取决于hash_type是否consistent
source     ---> tcp/http
uri        ---> http
uri_param  ---> http
hdr        ---> http
rdp-cookie ---> tcp
```



# 各调度算法使用场景

```bash
static-rr  ---> #做了session共享的web集群
first      ---> #较少使用
roundrobin ---> #做了session共享的web集群，默认算法，常用
leastconn  ---> #数据库
random     ---> #对于大型IDC机房或经常添加或删除服务器非常有用
source     ---> #基于客户端公网IP的会话保持
uri        ---> #缓存服务器，CDN服务商百度、阿里、腾讯等
uri_param  ---> #可以实现session保持
hdr        ---> #基于客户端的响应报文头部类型转发
rdp-cookie ---> #基于Windows主机 很少使用
```





